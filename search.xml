<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[day6_梯子理论,尝试与用户建立关联]]></title>
      <url>%2F2017%2F06%2F25%2Fday6-%E6%A2%AF%E5%AD%90%E7%90%86%E8%AE%BA-%E5%B0%9D%E8%AF%95%E4%B8%8E%E7%94%A8%E6%88%B7%E5%BB%BA%E7%AB%8B%E5%85%B3%E8%81%94%2F</url>
      <content type="text"><![CDATA[从产品到用户,文案的四个层次 属性 : 产品有什么属性和功能? 利益 : 这个功能带给我什么利益? 心理利益 : 这个利益,会帮我达成什么目标? 价值观 : 我为什么在乎这个目标? 案例 :属性 : 低价利益 : 省钱心理利益 : “可以留出钱来买更好的东西”价值观 : “把钱花的漂亮是本事” 工厂里的产品 : 低能量膳食纤维 有维生素的D的钙片 新疆长绒棉被子用户在乎事情 : 展示最美的自己 能照顾好自己 保持充沛精力 梯子理论的本质 产品属性 : 低能量膳食纤维利益 : 吃得更少心理利益 : 没有那么胖价值观 : 展现最美的自己 产品属性 : 有维生素d的钙片利益 : 补钙吸收好心理利益 : 每天上楼不费劲价值观 : 能照顾好自己 产品属性 : 新疆长绒棉被子利益 : 温暖舒适的被窝心理利益 : 睡个好觉价值观 : 保持充沛精力 你需要提供一个动机的利益! 盗梦空间的问题属性 : 你想让别人做的事情属性 : “解散你爸的公司”利益 : “获得白手起家的机会”心理利益 : “白手起家，证明自己，不让父亲失望”价值观 : “真正的成功依靠自己而不是父亲” 高端婚礼糖果(喜糖)利益 : 高端 / 稀缺心理利益 : 高端伴手礼,婚礼更有面子 / 婚礼只有一次,不能卖大街货价值观 : 婚礼就是有面子 / 婚礼要有独特的回忆 右边的价值观 : 一定更受年轻人的欢迎!当攻击竞争对手的时候,一定要找到竞争对手的劣势进行攻击! 用户访谈模板：属性 : 对于这个产品,你最在乎什么功能？利益 : 为什么这个功能很重要？心理利益 : 这个利益,会帮助我们达成什么目标？价值观 : 你为什么在乎这个目标？ 榴莲旅游探访 :属性 : 行程规划要好.利益 : 只去值得去的地方 / 把应该去的地方去全.心理利益 : 省的去了才发现,原来是坑爹的,浪费时间,错过了精彩的东西白来了.价值观 : 对同行的家人负责,时间宝贵,好不容易来一次该看的都要看. 刚被发明出来的MP3属性 : 体积少,容量很大；利益 : 把1000首歌曲装进裤袋;心理利益 : 随时随地,想听就听;价值观 : 我就是我,不受约束; 无孔防盗门锁属性 : 无孔防盗门锁利益 : 小偷常用撬锁方式失效心理利益 : 更加安全价值观 : 珍爱自己的家庭 神州专车属性 : 自营司机,专有车辆利益 : 安全心理利益 : 接重要的人价值观 : 好好对待哪些人,对我们重要的人 快方送药属性 : 优势供应链系统利益 : 28分钟良药送到家心理利益 : 别的都能等,但身体不适不能等价值观 : 拼命奋斗的你,应该好好照顾自己 工厂里的东西和消费者心智里的东西之间有一些鸿沟,你需要建立桥梁. 作业 属性 : 手持美容仪利益 : 不用整天去美容院美容,在家也可以心理利益 : 花最短的时间,使自己变的更美价值观 : 做理想自我,让自己成为白富美 属性 : 买有设计感的家具利益 : 让家庭变得更美丽心理利益 : 让家更具感觉,提升个人气质.价值观 : 尝下新颖的家具,提升爱家的感觉. 总结实现用户与产品的价值观链接!不能只关心属性.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[day5_对需求寻找最终的反馈]]></title>
      <url>%2F2017%2F06%2F21%2Fday5-%E5%AF%B9%E9%9C%80%E6%B1%82%E5%AF%BB%E6%89%BE%E6%9C%80%E7%BB%88%E7%9A%84%E5%8F%8D%E9%A6%88%2F</url>
      <content type="text"><![CDATA[消费者如果做出选择(10种需求方法)假如你是一个大学生,最近为了备考期末考试每天晚上去图书馆.现在刚在食堂吃过晚饭,下面两个选择你会怎么选:1.像往常一样去图书馆复习2.回宿舍,看一部一直想看的外国电影 假如你是一个大学生,最近为了备考期末考试每天晚上去图书馆.现在刚在食堂吃过晚饭,下面两个选择你会怎么选:1.像往常一样去图书馆复习2.去听一个新颖讲座 假如你是一个大学生,最近为了备考期末考试每天晚上去图书馆.现在刚在食堂吃过晚饭,下面两个选择你会怎么选:1.回宿舍,看一部一直想看的外国电影2.去听一个高级别讲座 听讲座&gt;图书馆&gt;看电影&gt;听讲座 证明:消费者并不是做出最好的选择,而是比过去的某个选择感觉更好的选择! 所以我们要找到不同的需求,本质上就能确定消费者拿什么产品来选择对比.从十大需要来找: 低价,过程体验,新颖,便捷性,可达性,定制化,性能,高端,减低风险,理想自我; 例如 : 美容仪器选择你的理由,过去默认的选择!新颖需求(互补品).如一句话文案:买个美容仪,让面膜效果更好!–&gt;可以认为面膜效果有限! (产生了对比,如115与现在OA产品对比.) 营销人应该有条件反射:当下消费者的默认选择是什么? 最低级的营销人 : 可能是本地区最好的电影院?错的!凭什么,老子不服. 大部分用卖货的思维去思考问题:- 我要卖美容仪- 买给中产阶段女性- 让你变美! 没有抓住痛点思维 : 消费者过去的默认选择是什么? 这个选择有什么不合理的? 为什么我能解决这个不合理** 如消费者当时默认选择为”钉钉”,这个选择存在不合理就是没有更好的效率为老板服务,我能解决这个需求就是事情及时反馈. 大部分只做对了一半!手持美容仪能让你变得更美.你认为的手持美容仪,只是在心里默认做了对比.所以,只有前面的思维,下面是走不通的! 当我们决定了最终的需求,也就决定了各种策略.然后我们再从:定价,产品,公关,渠道,广告…入手 如:买个美容仪,让你的面膜更好;花2000买美容仪,永久免费美容;买个美容仪,每天护理; 因为前面有十种思维,每天都需要强迫自己思考找到真正的需求.就是:消费者如何做出真正的选择? 选择主打需求的本质: 不是选最大的优势; 不是把事情说清楚; 而是让别人行动; 手持美容仪1,比美容仪低价;2,比美容仪便捷;3,让面膜功效更好;4,美容应该每天进行; 我在帮助顾客做他本身非常想做的事情吗? 顾客对现状真的不满意吗? 顾客愿意为不满做出改变吗? 顾客打算为不满做出改变的时候,你是首选方案吗? 消费者要选择你的方案,是否面临风险? 当消费者真的选择你的方案,那你的方案有扬长避短吗? 你愿意为针对不满作出改变吗?这个是重点.最小行为改变让消费者以更小的改变就可以采用产品. 手工美食(有物);找整条大街,还不如下载一个app; 李叫兽的反馈训练法最有效的训练方法就是,看到一个成功或失败的案例或事件时,把自己置身于当时的环境,想象自己会如何判断,如何决策 ,最后拿结果来反馈. 其实这个反馈训练法,小到一个想法的启发,大到一个公司重大选择,都同样适合.比如当时事关英特尔命运的重要对话: 1985年的一天,格鲁夫在办公室里意气消沉地与董事长兼首席执行官摩尔谈论公司的困境,那时英特尔已经在漫无目的的徘徊中度过了一年.格鲁夫问摩尔:”如果我们下了台,另选一名新总裁,你认为他会采取什么行动?摩尔犹豫了一下,答道:”他会放弃存储器的生意.格鲁夫目不转睛地望着摩尔,说:你我为什么不走出这扇门,然后自己动手?” 这个决心很难下.在所有人的心目中,英特尔就等于存储器.但格鲁夫说做就做,他力排众议,顶住层层压力,坚决砍掉了存储器生产,而把微处理器作为新的生产重点. 格鲁夫的这种决策方式也是预测—反馈法的表现,就是想象自己置于当时的环境,作出何种决策,这种方式能启发想法,建立自己的判断力. 总结 让消费者做出最小的改变,这个是重点 消费者过去默认的选择是什么,我们拿来对比.(而不是让产品跟心来对比).我们要科学营销.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[day4_十大需求自检]]></title>
      <url>%2F2017%2F06%2F14%2Fday4-%E5%8D%81%E5%A4%A7%E9%9C%80%E6%B1%82%E8%87%AA%E6%A3%80%2F</url>
      <content type="text"><![CDATA[案例企业:懒财网需求 : 低价需求思考模板 : 你的目标消费者,是否渴望完成某个任务?但过去因为价格太高,不得不放弃或采用不爽的替代方案?你的产品能否帮助他们解决这个问题? 在银行存个好的债券理财产品,起点都要5万元起,而理财网1元起透,更低的门槛,更高的利息.所以懒财网满足这一类需求,因此文案可以这样表达 就算你只有1块钱,我们也要把他投到优质的理财产品中.懒财网,认真对待你的每一块. 过程体验思考模板 : 模板消费者,过去在做某事时,在忍受什么糟糕的体验?你的产品能否帮助他们进行提升? 以前理财的时候,各种年利率把人算晕,不知道自己的资金是否在增值,有些理财得到第二天才可以看到昨天是否盈利.而懒财网创的”秒付息”,让你每一秒都可以看到你的资金动态,让人更有体验感. 别人按天付息,我们按秒付息.懒财网,理财让你看得见. 不排队,不纠结,省下时间去赚钱. 新颖性思考模板 : 我的消费者,过去在做某事时,是否存在一成不变的解决方案,从而让过去的效果受到了限制?我的服务,能为他们提供更好的选择吗? 便携性思考模板 : 你的消费者,过去是否会因为太麻烦而放弃完成某个很想要完成的目标?你的服务,如何帮他们节省麻烦? 以前当有好的债券类的产品出来的时候,大家都要抢着去银行排队购买,有时候还不一定买得到.而懒财网,可以随时将资金投到与债券一样好的优质资产上,不需要排队,只需要手机转账即可投资. 不需要排队购买优质债券,你只需要一部手机即可.你在银行排队的时间,我的工资又涨了.懒财网,你的工资不闲置. 可达性思考模板 : 你的消费者,过去是否非常渴望成为某种人或者做某件事,但始终没有实现他的手段? ​商务生意人士平时更多时间应酬,没有时间打理自己的财务,当他们听到一些所谓的理财顾 问提出的理财建议后,总感觉很高端,也很希望自己能够跟他们一样,掌握一门理财技能, 但碍于时间与精力因素,没有办法掌握更多的技能.有了懒财网后,不需要懂太多理财技能, 但却能像理财经理一样去掌控自己的每一分钱财. 懒财网,让你跟理财大师一样理财. 定制化思考模板 : ​你的消费者,是否需求的差异性很大?你为什么可以满足某种人的不同需求? 很多生意人很善于打理自己的事业，同时再理财方面更要求定制化。,懒财网独特的分散投 资功能.更能像私人定制般的去理财,就算是一块钱,也要按当时经济情况,定制化分散投 资到各个优质的资产上. 一块钱,我们都要拆开定制化投资.–懒财网,定制化般的理财. 性能思考模板 : 你的消费者,一直希望完成什么任务?相比于过去的选择,你提升了什么性能,以帮助他们完成这个任务? 一些白领每个月发完工资后都存到余额宝,希望借余额宝的高利率来提高工资的增值,但是用了懒财网后,利率更高了.所以白领这个群体有着“性能”这个需求. 隔壁老王说银行活期利率又下降了,工资又贬值了.我悄悄地用了懒财网管理我的工资,现在又升值了. 高端思考模板 : 使用过去的方式,有什么地方显得很 low,配不上现在的目标消费者? 你用计算器计算你的理财资金,不如让懒财网云数据运营你的理财资金. 商业都要讲究云数据,你的理财更要云智能. 降低风险 思考模板 : 使用产品的过程中,消费者会遇到什么风险?你如何能消除这种风险? 爱理财的这群人经常定投股票基金或者别的高风险理财产品,以追求高利率回报.但是由于缺乏研究,经常会资金风险.而用了懒财网后,懒财网的专业团队把资金合理科学地分配到许多优质的项目上,这样可以避免因为自己的不专业而使资金出现风险. 你的每一分变动,你都可以看得到.——懒财网,精确你的每一分. 理想自我思考模板 : 对你的目标用户而言,如何他们设置一个“说出来他们就很想做,但又很难完成的目标?”; 你能够替他们完成这个目标. 我们每个人都知道分散投资才能规避风险,我们也知道将资金进行系统化的投资,才能保证最大的汇报.但是简单的道理做起来很难,很多人没有办法学到如何系统化投资,也没有办法持续性将资金及时分散出去投资,而懒财网就能随时随地地做到这一点. 当你把钱存入那一刻,懒财网已经开始为您系统化理财了. 手持激光美容仪主动需求 : 过程体验 新颖性 便携性 可达性 性能 理想自我 这种美容仪主要是针对的消费者 : 男性消费者 : 别以为男人不需要美容,其他现在很多男人(包括我)也有去美容的习惯,还去美容院开了卡,有些男同胞也有在家里跟着老婆(半身的可能就没有)一起做美容吧!爱美之心人皆有之,但目前最大的痛点是很多美容院都是对女性开放,男性却大都望而却步,羞于进去! 于是我分析这款美容仪针对消费是: 青春期长痘痘,爱清爽的男生;工作繁忙怕衰老怕皱纹,又不敢于去美容院的中老年男士; 具体需求 :足不出户一样可以美容!用了它,痘痘不见了,终于敢和心仪的女生拍照了. 女性消费者 : 这块是美容产品较大的消费群体,如中产阶级白领女性,但如果是手持的,可以在家操作的,我想一些高中大学女生也是主要消费群,还有一些退休的中老年妇女也是值得开发的! 痛点是 : 美容院很多难以选择,要办美容卡,消费贵,没有时间或不能如约去做的时间限制. 花一次的钱,享受终生美容. 有物手工电商美食平台主动需求 : 过程体验 新颖性 便携性 可达性 性能 理想自我 定制化 高端 应该针消费者 : 如中产高级白领;真正的吃货;注重健康安全的消费者;喜欢小资生活的人,有选 择困难症的人,有品质私人小聚会(年会,下午茶等)需要美食的客户,需要优质个性礼品的客户. 具体需求 :健康的,纯手工的,天然的.匠心独具的口感超棒的,别人不可复制的.独特的地理区域特产,美食,风味,追寻有回忆有情感的味道.公众号平台运营销售,不用去其他大电商平台很费时间的困难选择. 挑美食,我放心交给”有物!”. 有物手工制作应该主打“降低风险”需求,文案是:无添加、看得见、只为家人制作. 与其到处去“淘”真货，不如来优集品选“好”货 优集网 新颖分析 : 找到不合理的点——穿精心包装身体,却不会精心包装生活空间;穿设计师品牌/限量款服装却用着流水线的家居产品;独自旅游愿意花更多钱选择装饰更有格调的酒店住一晚,却不愿为居一生的小窝花钱添置品质家居用品. 你用限量款 LV 包装着你一周用品,却用塞满快餐式家居的家/快餐式的家装着你 一生的时光. 升级→你用限量款 LV 包装点一身,却用流水线的家居装点一生. 住过五星级的高端酒店了,现在想拥有五星级的家了吗? 家居审美,是时候来点儿新鲜的了!→新世纪的你还用着上世纪审美的旧沙发 便捷分析 : 如果想凑齐全家的有质感的家居用品需要逛遍全市的家居用品店,很麻烦,有优品网 一站式制备齐全. 一站式购齐全球品质/设计师风格家居 理想自我 分析 : 为什么要买好的家居用品呢?因为我们想证明自己有在用心的生活,有好好照顾自己. 让别人觉得我们生活的很有逼格. 认真生活你需要?每周一三敷面膜,不亏待你的皮肤**每周二四去夜跑,不亏待你的身材每周五六听讲座,不亏待你的大脑或是:先从买一床养眼又舒适的被子开始,不亏待你自己. 升级版→如何赢得朋友圈晒照逼格大赛?你可以晒登顶海拔 3000 米高原红的笑脸晒失败了 45 次终于做好的法式料理,晒 30 天魔鬼训练练出的马甲线，或是晒出温馨卧室里的 1 室阳光.我哪儿也没去,我只是在百分之一百的用心生活. 手持激光美容仪2 便携分析 : 去美容院需要很大程度要面对的是办卡推销,预约排队,需要找休息的整块儿时间.手持美容仪可以解决这些痛点 . 聪明的女人,用整块儿的时间读书养心,用碎片的时间仪器护肤.手持激光美容仪,随时随地连续性的为你的青春续费. 有物 定制化用一块带匠心余温的甜点抚慰工业化都市里的胃.有物手作,用手作美食给你的胃将一个独一无二的故事. 总结需要我们去了解产品,才能对产品进行分析,进行模板套用,多问问自己为什么?找到不合理的点,再从点出发刺激用户.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[day3_需求自检清单]]></title>
      <url>%2F2017%2F06%2F14%2Fday3-%E9%9C%80%E6%B1%82%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%2F</url>
      <content type="text"><![CDATA[李叫兽需求自检六大问 我是在帮消费者做他特别渴望的事情吗? 在我的产品之前,消费者的选择是什么,他存在不满吗? 当消费者产生了不满,他/她愿意为这样的不满做出改变吗吗 当消费者打算为这样的不满做出改变时,你是他的首选方案吗? 消费者购买你的产品时,是否面临巨大的风险? 当消费者真的选择你的产品,你是否做到了扬长避短? ​作业一(慧择保险简介)它的主要功能有: 汇集了各类保险信息,在上面你可以找到上百种保险项目 有专业的保险专家可以为你规划和设计保险方案 他目前的文案是:这么多保险,任你比,随你挑现在,请首先假设你是一位消费者,打算要购买保险,你甚至上网搜索了比如人寿保险,平安保险等项目(请不要跳过此步,这对于你的训练很关键),甚至询问了父母朋友的建议 下面,在假设你就是消费者的同时,请按顺序回答下面的六条需求自检的问题: “这么多保险,任你比,随你挑” 是消费者在购买保险时原本就渴望做,原本就愿意做的事情吗? 为什么? 我认为消费者不是渴望做的,用户只是想清楚哪一个对自身保障更好.那一个更合适我.而不是让用户在选购上面浪费时间. 在消费者购买保险时,他们原本就存在什么不满是什么? 对保险的价格费用比较高,对自身的好处不大.以往的保险没有自我推荐. (回想一下如果你作为消费者,整个购买保险的过程,你觉得很不爽的地方有什么? ) 消费者不愿花时间了解保险的产品,和保险的信用度和假设发生事故的处理速度. 假如你刚刚发现了消费者在购买保险过程中存在的不满,那么请思考,假设惠泽保险现在说,它可以解决这样的不满,那么你认为消费者愿意花费时间和金钱,在惠泽保险平台购买保险吗? 觉得金钱还是会愿意花的,但是时间不太可能.因为用户的时间是宝贵的,用户只希望用极少的时间来听与之相关的东西. 假设慧择保险的确可以解决你刚刚提及的不满,但你确定当消费者尝试解决这样的不满时,他们的首要选择是惠泽保险吗? (而不是诸如人寿,平安一类的保险) 觉得消费者还是会选择的,因为别人也没有那么看重我们. 你认为当消费者在惠泽保险平台购买保险时,他们可能还有哪些顾虑?你认为可以如何消除这些顾虑? 信任问题,出险的速度问题.做好自主品牌声誉. 你认为慧择保险平台在解决消费者的不满时,处于扬长避短的态势吗?为什么? 属于,因为不发现问题,只解决了问题.就好像一直没有发现事实. 作业二:利用“李叫兽需求自检六大问”来做三道判断题,看看咱们学员写的文案违反了哪些原则?为什么? 这三句文案分别是有关优集品,手持美容仪,有物: “纯手工制作,吃的健康放心” (为有物写的文案)请问这句文案违反了什么需求原则,为什么? 我是在帮消费者做他特别渴望的事情吗? 因为手工制作,就代表了健康了吗? ”告别瓶瓶罐罐,肌肤问题一机全搞定” (为美容仪写的文案)请问这句文案违反了什么需求原则,为什么? 我是在帮消费者做他特别渴望的事情吗? 因为手工制作,就代表了健康了吗? “优集品,让你成为你家的设计师” (为优集品写的文案)请问这句文案违反了什么需求原则,为什么? 在我的产品之前,消费者的选择是什么,他存在不满吗? 成为家的设计师? 作业三:好,在判断过学员写的案例,现在请你重新思考一下并写下,你之前为优集品,或手持美容仪,或有物所写的需求文案,违反了自检六大问中的哪些原则? 优集品是一家出售更有设计感和质感家居用品的电商平台,比如在上面,用户能挑选到没有添加剂的洗发水,更有设计感的茶杯,高颜值的烧水壶.但它发现,很多消费者在产生家居用品的购物需求时,往往会选择买些普通货(比如他们可能会买些沃尔玛、家乐福就能买到的品牌),而不会上优集品. 请简要分析,对优集品来说,它应该针对哪些消费者,主打什么需求?从而让他们选择到优集品上买东西,而不是像过去一样买些普通货?并尝试为它撰写一句话文案. ~~主要针对消费者是:选择症困难户;主打需求:挑选好货;一句话文案:我们只挑选好货. ~~ 我是在帮消费者做他特别渴望的事情吗?消费者针对优集品,解决了用户选择困难症,主打需求是拽好货;目前认为没有错! 在我的产品之前,消费者的选择是什么,他存在不满吗?在我的产品前,消费者往往会选择到各大超市选择不是经过优选的货,但往往买回来后发觉不好用,以至于浪费. 当消费者产生了不满,他/她愿意为这样的不满做出改变吗?会发生改变,可能下次和同事讨论,让同事推荐购买好货,或者收集别人的一些建议. 当消费者打算为这样的不满做出改变时,你是他的首选方案吗?会询问信任的朋友,让其推荐那些产品好用,那些产品靠谱. 消费者购买你的产品时,是否面临巨大的风险?会面临不信任的危机,觉得优集品的货物还是比较贵. 当消费者真的选择你的产品,你是否做到了扬长避短?我之前的一句话文案没有考虑到的问题,我没有做到扬长避短.所以现在更改的文案为 : 让身为朋友的我,为你挑选适合你的好货. 课中笔记(不要被伪需求屏蔽你的眼睛)别人只会接受有限的意见,他们一直应该做,但是还没有做的事情呢?从这个角度去思考消费者.不要把钱放在一个篮子里面,特指的是分散投资.如:懒财网:普通人的分散投资的工具.首创智能分散投资,(证据:)年年收益7.5%总结:就是与别的互联网产品拉开可比性需求. 真正会用看似复杂的方法你会发现世界正变得更加简单!痛点需求自检 我在帮助顾客做他本身非常想做的事情吗?任何的产品出来都是在帮用户做一件事?—&gt;好像监控机器人…看管孩子? 但是这是否是伪需求?原则:不要帮用户做他本身就不想做的事情.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 68 Persistent 纠缠不休]]></title>
      <url>%2F2017%2F06%2F14%2FLesson-68-Persistent-%E7%BA%A0%E7%BC%A0%E4%B8%8D%E4%BC%91%2F</url>
      <content type="text"><![CDATA[单词讲解 persistent adj.坚持的,固执的 presist v.坚持,执意Jim was fired, because he persisted in causing trouble.We are persisting with policies that are good for the market.His cough grew more persistent.persistent effort 坚持不懈的努力 avoid v.避开He tried every means to avoid any trouble.Jane stayed in the restroom to avoid her ex-boyfriend.Jane tired to avoid meeting him. insist v.坚持做Sam insisted on the truth of his story.The manager insisted on keeping to the plan.They insisted that Ryan (should) leave.(坚持要做)insist + that + 主语 + (should) + 动词原形 语法讲解 I crossed the street to avoid meeting him…cross == go acrossavoid + n.avoid + doing 避免做某事只跟名词性宾语(名词/动名词)的动词:avoid,enjoy,fancy,finish,mind… …but he saw me and came running towards me.running towards me 是现在分词短语作伴随状语Vicky ran towards me waving her hand. It was no use pretending(假装) that…Pretending was no use.Pretending that I had not seen him was no use.It was no use pretending that I had not seen him. It’s no use doing sth… 做…是没有用的了It’s no use saying sorry to her.跟他说对不起已经是没有用的了.It’s no use reviewing the lessons just before the exam. No matter how busy you are, he…no matter + 疑问词(what,when,where,who,how)让步状语从句 “无论……”No matter where you go, you have to give me a call. 无论你在哪里,你都给我打个电话.No matter what you do, you have to tell me. Wherever you go, whatever you do, I will be right here waiting for you.No matter where you go, no matter what you do, I will be right here waiting for you. insist on doing 坚持做William insisted on attending the meeting. I had to think of a way of preventing…think of 想出…a way of …的方法a way of preserving food 保存食物的方法prevent sb.from doing sth.阻止某人做某事The experts prevented the disease from spreading. Fancy meeting you…fancy v.想象,设想(用于祈使句表示异议,震惊,不相信)fancy doingHe was wearing a tuxedo.Fancy Lily being so rude! You’re not busy doing…be busy doing 忙于做…反意疑问句“前肯后否,前否后肯”Ted is a nice boss, isn’t he? Would you mind…Would you mind doing…? 你介意做某事吗?Would you mind closing the window? … you mind my coming…动名词的动作执行者与句子主语不一致时,动名词前可以加所有格形容词,宾格代词,或所有格名词,作为动名词的逻辑主语.Would you mind me /Sam’s closing the window?Paul insisted on his paying the bill.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 67 Volcanoes 火山]]></title>
      <url>%2F2017%2F06%2F13%2FLesson-67-Volcanoes-%E7%81%AB%E5%B1%B1%2F</url>
      <content type="text"><![CDATA[单词讲解 volcano n.火山active volcanoes 活火山 violently adv.猛烈地,剧烈地The building shook violently in the earthquake. liquid adj.液态的solid 固gas 气 escape v.逃脱The prisoner attempted to escape but failed.Their conversation did not escape my notice.We all want to escape form the reality sometimes. 语法讲解 Haroun Tazieff,the Polish scientist, has spent his lifetime(一生) studying(研究) active(活的) volcanoes and deep(深的) caves in all parts of the world.(世界各地) the Polish scientist 同位语has spent 现在完成时spend 时间 (in) doing sth.all parts of the world 全世界all over the world Tazieff was able to set up … camp very close to the volcano while it was erupting violently.要知道他以前是做过某事的;区别 can / be able to…相同点 : 能表示能力,”能够”(can / could; be able to 时态更灵活)不同点 :表示过去已经成功做到的,用was/were able to,不用could.can表示猜测,允许. Though(尽管) he managed to(相方设法做某事) take a number of brilliant(精彩的) photographs, he could not stay… for very long.managed to do sth. = was/ were able to do sth. 相方设法做某事=能够做某事 It threatened to(威胁) surround him completely, but Tazieff managed to(相方设法) escape … in time. He waited until the volcano became quiet and he was able to return… This time, he managed to climb into the mouth of kituro so that he could take photographs and… Tazieff has often risked his life in this way. He has been able to tell us more about… volcanoes than any man alive.复习现在完成时 知识扩展区别 can / be able to : 相同点: 都表示能力,”能够”(can / could; be able to时态更灵活)不同点: 表示过去已经成功做到的,用 was/were able to,而不用could can 表示猜测,允许表示过去成功的做了某事 :was / were able to do sth.managed to do sth.succeed in doing sth. 表示过去没有成功的做了某事could not do sth.failed to do sth.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 66 Sweet as honey! 像蜜一样甜!]]></title>
      <url>%2F2017%2F06%2F06%2FLesson-66-Sweet-as-honey-%E5%83%8F%E8%9C%9C%E4%B8%80%E6%A0%B7%E7%94%9C!%2F</url>
      <content type="text"><![CDATA[单词讲解 Lancaster n.兰开斯特 bomber n.轰炸机 remote adj.偏僻的a remote villagethe remote pasta remote cousinremote control Pacific n.太平洋the Pacific Ocean damage v.毁坏Mike damaged his car in an accident.The incident damaged Bob’s reputation. wreck n.残骸the wreck of a ship.The car was a wreck after the accident. rediscover v.重新发现re- + discoverPeople are trying to rediscover the history.I rediscovered the toy that I enjoyed when I was a child. aerial adj.航空的aerial view 鸟瞰图aerial photograph 空中拍摄的照片 survey n.调查make a survey of public attitudes 进行民意调查market survey 市场调查 rescue v.营救He rescued a boy from drowning.Paul rescued a cat from the high tree. package v.把…打包He packaged up the magazines and put them in the box.The candy is packaged in pretty wrappers. enthusiast n.热心人a pop music enthusiastTed is a great sports enthusiast. restore v.恢复The damaged painting was restored.A good rest will restore him to health.(恢复健康) imagine v.想象You can’t imagine the situation there.It’s hard to imagine living on a lonely island.You imagine how excited he was. packing case 包装箱 colony n.群a colony of antsa colony of bees bee n.蜂 hive n.蜂房 preserve v.保护We will make every effort to preserve the forest.preserve ancient buildingspreserve fruit in the fridge beeswax n.蜂蜡 语法讲解 In 1963 a Lancaster bomber crashed…crash v.跌毁,撞碎The plane crashed near an island.Bob’s car crashed into the rear of a van. … Wallis Island, a remote place… a remote place in the South Pacific,a long way west of Samoa 都作同位语,说明Wallis Island 的具体位置 表示方位的词 + of + 地名Beijing is north of Hong Kong. … but over the years…over prep. during 在…期间We will be at home over Christmas. … and the wreck remained undisturbed.undisturbed adj.未动过的,未被扰乱的.Everything is undisturbed in the room.The village is peaceful and undisturbed. (安宁平静) … the plane was accidentally rediscovered…accidentally – by accident By this time, a Lancaster bomber….reasonable adj.尚好的,合理的a reasonable man 讲道理的人The price of the car is reasonable.in … condition 处于…的状况The car is in excellent condition. … and worth rescuing.be worth doing 值得…的The soup is worth eating. 这汤值得一喝.It’s not worth mentioning. The French authorities had the plane packaged…have sth .done 把某事…Sally had her computer repaired. 电脑被修.in parts 分成部分地 … going to have the plane restored.have sth. done … need to have only three of them rebuilt.have sth. done Imagine their surprise and delight…delight n. – joy 高兴,欢喜Mary read the letter with delight. A colony of bees had turned…a colony of 一群…a colony of bessturn into 把…变成…turn the couch into a bed 知识扩展 have sth done “让某人做某事”ask sb else to do sth过去分词(done)表示这个动作由他人(即非主语本身)来完成,含有被动意义,且强调动作已完成.Sam had his bicycle repaired. 汤姆找人修了他的自行车. have sb to “让某人做某事”let / make sb do不定式往往表示一次性的具体动作,且强调动作已经完成或尚未完成. Nick had Ted answer that question.尼克让特德回答那个问题. 翻译 :在寒冷的冬天,村民总是整夜地让火燃烧起来.In cold winter, villagers always have the fire burning all night long.格林先生让园丁在院里种上鲜花.Mr.Green had the gardener plant some flowers in the yard.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 65 Jumbo versus the police 小象对警察]]></title>
      <url>%2F2017%2F06%2F06%2FLesson-65-Jumbo-versus-the-police-%E5%B0%8F%E8%B1%A1%E5%AF%B9%E8%AD%A6%E5%AF%9F%2F</url>
      <content type="text"><![CDATA[单词讲解 versus prep.对 vs Christmas n.圣诞节Merry Christmas !Christmas Eve ought modal verb(情态动词).应该ought to do sth. = should do sth. fortune n. 命运 fortune-teller 运气 Fortune favours fools 财富 make a fortune fortunate adj. 语法讲解 Dressed up as Father Christmas and accompanied by a ‘guard of honour’ of six pretty girls,he set off down the main street of the city riding a baby elephant called Jumbo. He should have known that the police would never allow this sort of thing.宾语从句this sort of thingshould have known ??? 情态动词 should + do现在应该做(真实) should + have done 虚拟(过去本来应该做,但实际上没有做) ought to + have done(过去本来应该做,但实际上没有做) shouldn’t have done(本来不应该做,但是做了) need have done could / would / might / + have done A policeman approached Jimmy and told him he ought to have gone along a side street as Jumbo was holding up the traffic. 知识扩展 should + have done = ought to + have done shouldn’t have done need have done could / would / might + have done]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 64 The Channel Tunnel 英吉利海峡隧道]]></title>
      <url>%2F2017%2F06%2F06%2FLesson-64-The-Channel-Tunnel-%E8%8B%B1%E5%90%89%E5%88%A9%E6%B5%B7%E5%B3%A1%E9%9A%A7%E9%81%93%2F</url>
      <content type="text"><![CDATA[单词讲解 tunnel n.隧道the Channel Tunnel port n.港口The city is the largest port of the country. ventilate v.通风a well-ventilate room chimney n.烟囱Father Christmas comes down the chimney to send presents. sea level 海平面The mountain is about 10000 feet above sea level.below sea level double adj.双的a double room 双人间The word “bigger” has a double “g” in the middle. ventilation n.通风 fear v.害怕David fears nothing.Sally feared that she was late for the meeting.(担心,恐怕) invasion n.入侵,侵略invade v.Hitler invaded Poland in 1939.You can’t invade my private life.(侵犯)n.Asking that question is an invasion of privacy. officially adv.正式地official adj.官方的,正式的official duties 公务an official statement 正式声明They officially announced the news to the public. connect v.连接This railway line connects the city and the small town.You have to connect what you hear with what you see.(你应该把你听到的和看到的联系起来.)Operator,Please connect me to the manager.(给…接通电话) European adj.欧洲的Europe n.欧洲 continent n.大陆,大洲the continents of Africa and Asia. 语法讲解 … arrived in England with a plan for…plan for : …的计划Angela made a plan for her summer vacation.The manager drew out a plan for the project. This platform would serve as a port…serves as : 担任,充当, 起…的作用He serves as president for eight years.This room serves as both living room and guest room. The tunnel would be well-ventilated if…此句是对将来的推测 In 1860 , a better plan was put forward…put forward (提出计划,建议)put forward a planput forward a proposal He suggested that…v.(建议,要求,命令) + that + 主语 + (should) + 动词原形虚拟语气suggest, recommend, demand, order, insist, require…I suggest that Ted(should) leave now.Ted insisted that he (should) meet Vicky in person.When I suggested that some villagers must have come in for a free drink.(暗示) If, at the time ,The British had not feared invasion,…if 引导的非真实条件句If he had taken the subway, he would not have missed the flight. It was officially opened on March 7,1994…finally connecting … continent 现在分词作结果状语connect … to … 把…和…连接起来connect the speakers to the mp3 player. 知识扩展if引导的非真实条件句 从句 主句 与过去事实相反的假设 if+主语+had+过去分词 主语+should/would/could/might+have+过去分词 If Nick had got to the office earlier, he would not have missed the interview. If Frank hadn’t turned down Sam’s suggestion,he would have achieved his goal. If David had checked out his email, he would have known about the cancellation of the meeting.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[day2_为产品找需求]]></title>
      <url>%2F2017%2F06%2F06%2Fday2-%E4%B8%BA%E4%BA%A7%E5%93%81%E6%89%BE%E9%9C%80%E6%B1%82%2F</url>
      <content type="text"><![CDATA[低价需求对花费巨大或者购买不给力的替代品:唯品会利用了品牌的低价需求,获取用户.低价意味着对高价的渴望而产生替代品.低价需求需要渴望者本身想完成的任务.所以低价需求必须存在:多个消费者本身想完成的任务,但过去因为价格太高而无法完成. 如举例的手持激光美容仪:能在家完成的事情何必到美容院跑一趟? 过程体验目标消费者,过去在做某事,在忍受什么糟糕的体验?你能否在产品提升它们? 如举例的优集品:过去会为了买一些货物有选择困难症,从此遇上它再也不用. 新颖品如果市场上的一些消费者对过去某一成不变的解决方法感觉到不满,就渴望尝试更好的东西. 洗了一辈子的头发,你洗过头皮吗? 无硅油洗头水. 你已经尝试过美国最好的啤酒了,何时不来尝下最好的德国啤酒. 你已经谈过无数地区的黄瓜了,为何不来尝试下最好的化州黄瓜? 思维:我的消费者,过去在做某事时,是否存在一成不变的解决方案,从而让过去的效果受到限制?我的服务,能为它们提供更好的选择吗? 如举例懒财网:过去一成不变的理财在银行,为何不来尝试下网上理财的快捷性? 便捷性如果市场上有这样的消费者,他们渴望亲自完成某一目标,但完成这个目标却非常麻烦,常常付出巨大的时间,精力,这时就渴望有省麻烦,更便捷的解决方案.本质:降低消费者非货币的成本; 常用的广告策略:用了XXX,不用到处找… 用了XXX,在家就能做. 来突出消费者过去在解决某个问题的麻烦. 可达性目标消费者一直渴望达到某个目标,成为某种人,而始终没有途径做到,他们希望存在一种实现目标的手段. 曾经错过大学,别再错过本科.用科学自考的服务,吸引了大批量消费者报名. 广告策略:突出你现在也可以行为某种人,或者做到某种事情. 手持激光美容仪,过去常常需要到美容院来美容,现在能在家美容. 定制化定制化需求注意:如果消费者的需求跟差别不大,那么你主打定制化就没有用.广告策略:不同人的需求不一样,你的专属xxx等.例如专门为创业公司提供工位的写字楼,可以突出”创业公司的办公需求,跟大公司不一样”,’创业公司的专属工位”,”专为创业者设计”; 如举例有物手工电商美食平台:手工美食,就是跟机械化有差别; 性能在南孚之前,一些厂家都是打电力强劲,耐用持久.但是这样的说话,消费者难以接受,而南孚改变了消费者的视野,不是关注电池的容量,而是关注电池能否控制电量的流失,而聚能环就是这个技术,解决了电池的耐用性; 在性能需求时,要提升性能的目的,是帮助消费者完成他们一直想完成的任务,如果消费者本身不想做某件事,那么你提升相关性能也没有用; 广告策略:某种性能帮助消费者更好的完成某个任务时,达到了一种更惊奇的效果,比如超轻的跑鞋让你跑过猎豹等. 你的消费者,一直希望完成什么任务?相对于过去的选择,你提升了什么性能,以帮助他们完成任务? 如举例超声波香薰机:让超声波香薰机替代药物吧; 高端要注意:如果消费者不在意是否高端,那么你打高端的广告是没有用的. 如举例优集品:过去消费者不在意是否高端,商品的好看性,现今是能够解决问题的. 降低风险就好像购买鞋子,消费者不愿意买到不合适的鞋子; 但需要注意问题:如果风险不是阻碍主流消费者使用某个产品的关键因素,那么主打需求就没有用.广告策略:提升你存在某种风险(比如打不到车),或者提供信任并作出保证(假一罚三).觉得本地月饼厂商,可以提供直播消费清单; 理想自我我想给消费者提供什么建议?(比如懒财网就要问自己:我到底想要给消费者提供什么建议,我建议消费者怎么理财?然后让自己的产品成为这个建议的必要路径.) ‘理想自我的需求”:你对面前的消费者会提供什么他们自己很难完成但又觉得应该做的建议?(这意味着他们会通过购买来完成这个建议) 思考:对你的用户而言,如何他们设置一个’说出来就很想做,但又难以完成的目标?你能够替代他们完成这个目标吗?’ 举例当地月饼厂商:对用户而言,很想知道来源料子的真实性,但是消费者无从心知.那么就是打造自我; 总结归纳低价需求&gt;过程体验&gt;新颖品&gt;便捷性&gt;可达性&gt;定制化&gt;性能&gt;高端&gt;降低风险&gt;理想自我.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[day1_课前思考]]></title>
      <url>%2F2017%2F06%2F06%2Fday1-%E8%AF%BE%E5%89%8D%E6%80%9D%E8%80%83%2F</url>
      <content type="text"><![CDATA[#​ 案例企业1:懒财网懒财网是一家互联网活期理财平台,现在它想让用户认为 “理财投资,就上懒财网”.懒财网与其它理财产品的区别在于: 懒财网提供活期7.5%的收益率,用户资金面临的风险较低;大多数活期理财,收益率维持在3%左右,风险较低;懒财网的高收益是因为其拥有平台智能算法,可将用户的钱分散地投入到不同的优质投资资产上,从而实现降低风险,保证收益 在获取7.5%的收益率的同时,用户可以将资金随存随取,提现时没有最高的提现金额限制,每笔提现会被收取固定3元手续费;收益同在7.5%的其他的理财产品,多为固定期限投资,无法实现随存随取,提现时若还在期限以内,会被收取较多的手续费用 请简要分析,对懒财网来说,它应该针对哪些消费者,主打什么需求?从而让他们选择懒财网,而不是其他理财产品?并尝试为它撰写一句话文案. 针对的消费者是:上班族,主动:没风险理财.不想在理财方面浪费太多时间与精力;一句话文案:尽情享受生活,把理财交给我们! 案例企业2:优集品优集品是一家出售更有设计感和质感家居用品的电商平台,比如在上面,用户能挑选到没有添加剂的洗发水,更有设计感的茶杯,高颜值的烧水壶.但它发现,很多消费者在产生家居用品的购物需求时,往往会选择买些普通货(比如他们可能会买些沃尔玛、家乐福就能买到的品牌),而不会上优集品. 请简要分析,对优集品来说,它应该针对哪些消费者,主打什么需求?从而让他们选择到优集品上买东西,而不是像过去一样买些普通货?并尝试为它撰写一句话文案. 主要针对消费者是:选择症困难户;主打需求:挑选好货;一句话文案:我们只挑选好货. 案例企业3:有物手工电商美食平台有物是一家手工电商美食平台,在上面,消费者可以购买到的都是手工制作的美食,比如“xx小姐手工制作的凤梨酥和柚子茶”,而不是在其他地方所买到的机器批量化生产的普通食品.现在,这一美食平台想要吸引更多用户使用自己的产品购买美食. 请简要分析,对有物来说,它应该针对哪些消费者,主打什么需求?从而让他们选择到这里购买食品?并尝试为它撰写一句话文案. 针对消费者:吃货人群;主打需求:手工美食产品;一句话文案:用手改变生活! 案例企业4:南海科日公司所开发的超声波香薰机南海科日公司卡发出了这样一款产品-超声波香薰机,它体积小、使用便捷,安全环保,当加入精油打开时,能够发出柔和的香味帮助用户改善身心健康,比如帮助睡眠.而过去,用户往往会选择通过吃药、针灸、运动等方式改善身心健康(比如吃安眠药助眠). 请简要分析,对超声波香薰机来说,它应该针对哪些消费者,主打什么需求?从而让他们选择购买香薰机. 针对消费者:养生人群;主打需求:睡前方式减压一句哈文案:改善身心健康,不仅仅是吃药能解决的; 案例企业5:手持激光美容仪某公司开发出了这样一款手持激光美容仪,用户在产生祛痘、嫩肤需求时,可以自己手持产品,针对面部进行美容护理.但这家公司发现,很多他们的目标用户(中产阶级白领)在产生美容需求时,往往会选择去美容院或者医院接受专业服务,而不是自己解决. 请简要分析,对手持美容仪来说,应该针对哪些消费者,主打什么需求?从而让他们选择购买? 针对消费者:爱美人士;主打需求:美容,方便;一句话文案:我的皮肤我做主! 线上目标线上化州特产”我是线上化州特产创始人,我们的产品都是严格挑选的好货,但是不确认纯线上这块如何精准策划,用户的接受度有多高;因为我们的定位是远在他乡的人群能享受到化州特色的美味;所以通过自学本课程来获取灵感. 营销人员只能发现事实,你不能说虚假需求.你跟美好生活只差58到家?这不是事实.人不能发明成功,但是成功可以复制. 低价需求:让你5万元购买一台奔驰车; 过程体验:美图秀秀,非专业人士也能美图; 可达性; 替你做:自己做不了交给别人做;(如维生素,每天的不同维生素,我都愿意做成复合维生素); 新颖:你洗了头发,洗过头皮吗?都尝试,不要被思维所限制; 文案:激发和唤起用户疼点营销:跟用户疼点联系-&gt;(心理阶梯;用户视角;) 战略:发现需求(机会)找需求模板,需求自检清单;珍爱生命,远离后见之明;放弃碎片化知识;要解决例题;系统化的方法(框架+清单);组合接受(主动+被动学习); 以训练过程为重点;一直都是接受,从没改变; 推荐书籍:好战略坏战略(基本的战略思维);定位;让创意更有黏性;奢侈品:划分档次;高档品:犒劳自己;时尚品:社会模仿;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 63 She was not amused 她并不觉得可笑]]></title>
      <url>%2F2017%2F05%2F05%2FLesson-63-She-was-not-amused-%E5%A5%B9%E5%B9%B6%E4%B8%8D%E8%A7%89%E5%BE%97%E5%8F%AF%E7%AC%91%2F</url>
      <content type="text"><![CDATA[单词讲解circle n.圈子draw a circleaa large circle of friends admire v.赞美admire sb. for sth.We admire him for his knowledge close /s/ adj.亲密的,近的Our home is close to the school.get close to…closest friends/z/ v.关闭 sort n.种类this sort of thingsort of… 语法讲解 Everybody admires him for his great sense of humour… …everybody, that is, except his six-year-old daughter,jenny. Recently, one of Jeremy’s closest friends asked him to make a speech…one of : 表示什么范围之一,所以后面加可数名字. This is the sort of thing that Jeremy loves.(定语从句)挨着谁,就是什么从句.(在名词后面)n. + that 从句定语从句或同位语从句We hava no idea that the boss has come.(同位语从句)It is the most interesting move that I have ever seen.(定语从句) He had included a large number of funny stories in the speech…include v.包括,包含contain v.container n.容器a number of…a large / great number of… As soon as he had finished, Jenny told him she wanted to go home.Jenny told him (that) she wanted to go home.vt. + 人 + 从句双宾语结构 Jereny was a little disappointed … but he did as his daughter asked.as + 句子 “按照…方式”引导方式状语从句When in Rome, do as Romans do.(按照罗马的方式去做事情)Do it as I told you last week. … he asked Jenny if she had enjoyed the speech.if (是否)vt. + 人 + 从句双宾语结构宾语从句 Jeremy asked her why this was so and she told him that she did not like to see so many people laughing at him!Jeremy asked her why this was so andshe told him that she did not like to see…!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 62 After the fire 火灾后]]></title>
      <url>%2F2017%2F05%2F05%2FLesson-62-After-the-fire-%E7%81%AB%E7%81%BE%E5%90%8E%2F</url>
      <content type="text"><![CDATA[单词讲解 control n.控制Paul took control of the business after his father retired.(接管)Everything is under control.(在掌控之后)The situation is out of control.(失控) smoke n.烟have a smokeThere’s no smoke without fire. 无火不起烟.Where there’s smoke there’s fire. 无风不起浪;事出有因. desolate adj.荒凉的a desolate island threaten v.威胁threat(n.) + enThe boss threatened to fire the waiter.The robber threatened the man with a gun. surrounding adj.周围的the surrounding countriesin the surrounding area destruction n.破坏,毁坏the destruction of the forestThe forest fire caused widespread destruction flood n.洪水,水灾 authority n. 当局the French authoritiesMr. Johnson is an authority on econmics.(学术权威专家) grass- seed n.草籽 spray v.喷洒John sprayed paint on / over the wall. quanitity n.数量quality n.质量Sam drank a large quantity of beer.(大量的)Nick has read quantities of books. (大量的) root n.根 century n.世纪A century is a period of a hundred years.At the turn of the country, great changes took place in this country.(在世纪之交) patch n.小片There is a patch on his pants. (补丁)a patch of land 语法讲解 Firemen had been fighting the forest fire…had been doing : 过去完成进行时强调动作在过去更早的某段时间内一直进行常连用的表示时间的词 : for,since,before… I had been waiting for Tom for an hour by the time he came.Sam had been looking for his car key for days befor he found it. … before they could get it under control.get … under control 使…得到控制The police has got the situation under control. … great trees had covered the countryside…around 在周围,四周There is no house for miles around. Winter was coming on…come on 开始,来临There is a storm coming on.The show is coming on. … the hills threatened the surrounding…threaten … with … 以(某种方式或手段)威胁The man tied her up and threatened her with a knife.The father threatened the boy with a beating. wash away 冲走,冲掉The floods washed away the bridge. When the fire had at last been put out…put out 熄灭put out the lightput out the candle ton n.吨a ton of coal 一顿煤tons of oil 数吨石油 … over the ground in huge quantities…quantity 数量a large quantity of 大量的a small quantity of 少量的a large / small quantity of waterquantities 大量The mother bought toys in large quantities for her boy.The mother bought quantities of toys for her boy. … the grass had already taken root.take toot 生根The little tree has taken root.The idea has taken root in his mind.(想法扎根) In place of the great trees…in place of 替代,取代Tim was sick. I had to take the business trip in place of him. in the place of 在…的地方When you think over the question, you may put yourself in the place of the boss. 知识扩展过去完成进行时had been doing表示开始于过去某个时刻(A)之前的动作(B)持续到过去这一时刻(A),并继续持续下去. 与过去完成进行时常连用的时间状语for + 时间段since + 时间点all morningall daybefore…When I got home, my brother had been repairing his bicycle for several hours.当我回家的时候,我的兄弟还在那修自行车修了几个小时了. When I got to the office, Frank had been waiting for me for an hour.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 61 Trouble with the Hubble 哈勃望远镜的困境]]></title>
      <url>%2F2017%2F04%2F05%2FLesson-61-Trouble-with-the-Hubble-%E5%93%88%E5%8B%83%E6%9C%9B%E8%BF%9C%E9%95%9C%E7%9A%84%E5%9B%B0%E5%A2%83%2F</url>
      <content type="text"><![CDATA[单词讲解 space n.空间outer spaceThere is no space in my room. distant adj.遥远的 distance n.距离different adj.difference n.important adj.importance n.significant adj.significance n.convenient adj.convenience n. billion n.十亿 语法讲解 The Hubble telescope was launched into space by NASA… at a cost of over a billion dollars. Right form the start there was trouble with…There be + n. + 介词短语There is a girl in the classroom.There are problems in front of us. The pictures it sent us were very disappointing because its main mirror was faulty.分析句子 :标准化的步骤标点符号,关键词,分析主谓The pictures it sent(谓) us were(谓) disappointing…!名词 + 从句 是定语从句他发给我的图片令人失望. NASA is… going to put the telescope right, so it will … be sending up four astronauts to repair it. A robot-arm … will grab the telescopeand hold it .while the astronauts make the necessary repairs. By the time you read this, the Hubble’s eagle eye will have sent us… pictures.by + 时间 表示”截止到…时间”,与完成时连用.by the time + 句子 引导时间状语从句by the time you read this 时间状语从句,一般现在时表示将来by the time 一般现在时到将来用将来完成时 知识扩展 将来完成时 考点 :by + 将来完成时by the time + 句子(一般现在时)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[看 ‘北大最短毕业致辞’ 的感受]]></title>
      <url>%2F2017%2F04%2F05%2F%E7%9C%8B-%E2%80%98%E5%8C%97%E5%A4%A7%E6%9C%80%E7%9F%AD%E6%AF%95%E4%B8%9A%E8%87%B4%E8%BE%9E%E2%80%99-%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
      <content type="text"><![CDATA[做自己尊重的人在祝福裹着告诫呼啸而来的毕业季，请原谅我不敢祝愿每一位毕业生都成功、都幸福；因为历史不幸地记载着：有人的成功代价是丧失良知；有人的幸福代价是损害他人。 从物理学来说，无机的原子逆热力学第二定律出现生物是奇迹； 从生物学来说，按进化规律产生遗传信息指导组装人类是奇迹。 超越化学反应结果的每一位毕业生都是值得珍惜的奇迹； 超越动物欲望总和的每一位毕业生都应做自己尊重的人。 过去、现在、将来，能够完全知道个人行为和思想的只有自己； 世界很多文化借助宗教信仰来指导人们生活的信念和世俗行为； 而对无神论者——也就是大多数中国人——来说，自我尊重是重要的正道。 在你们加入社会后看到各种离奇现象，知道自己更多弱点和缺陷，可能还遇到小难大灾后，如何在诱惑和艰难中保持人性的尊严、赢得自己的尊重并非易事，却很值得。 这不是： 自恋、自大、自负、自夸、自欺、自闭、自缚、自怜； 而是： 自信、自豪、自量、自知、自省、自赎、自勉、自强。 自尊支撑自由的精神、自主的工作、自在的生活。 我祝愿： 退休之日，你觉得职业中的自己值得尊重； 迟暮之年，你感到生活中的自己值得尊重。 不要问我如何做到，50年后返校时告诉母校你如何做到：在你所含全部原子再度按热力学第二定律回归自然之前，它们既经历过物性的神奇，也产生过人性的可爱。 演讲视频]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP请求模型和头信息参考]]></title>
      <url>%2F2017%2F03%2F28%2FHTTP%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%A4%B4%E4%BF%A1%E6%81%AF%E5%8F%82%E8%80%83%2F</url>
      <content type="text"><![CDATA[HTTP请求模型一、连接至Web服务器一个客户端应用(如Web浏览器)打开到Web服务器的HTTP端口的一个套接字(缺省为80). 例如:http://www.myweb.com:8080/index.html在Java中,这将等同于代码 :12InputStreamin=socket.getInputStream();OutputStreamout=socket.getOutputStream(); 二、发送HTTP请求通过连接,客户端写一个ASCII文本请求行,后跟0或多个HTTP头标,一个空行和实现请求的任意数据. 一个请求由四个部分组成 : 请求行、请求头标、空行和请求数据. 请求行 : 请求行由三个标记组成:请求方法、请求URI和HTTP版本,它们用空格分隔. 例如 : GET/index.htmlHTTP/1.1 HTTP规范定义了8种可能的请求方法 : GET检索URI中标识资源的一个简单请求 HEAD与GET方法相同,服务器只返回状态行和头标,并不返回请求文档 POST服务器接受被写入客户端输出流中的数据的请求 PUT服务器保存请求数据作为指定URI新内容的请求 DELETE服务器删除URI中命名的资源的请求 OPTIONS关于服务器支持的请求方法信息的请求 TRACEWeb服务器反馈Http请求和其头标的请求 CONNECT已文档化但当前未实现的一个方法,预留做隧道处理 请求头标 : 由关键字/值对组成,每行一对,关键字和值用冒号(:)分隔.请求头标通知服务器有关于客户端的功能和标识,典型的请求头标有 : User-Agent客户端厂家和版本 Accept客户端可识别的内容类型列表 Content-Length附加到请求的数据字节数 空行 : 最后一个请求头标之后是一个空行,发送回车符和退行,通知服务器以下不再有头标. 请求数据 : 使用POST传送数据,最常使用的是Content-Type和Content-Length头标. 三、服务端接受请求并返回HTTP响应Web服务器解析请求,定位指定资源.服务器将资源副本写至套接字,在此处由客户端读取. 一个响应由四个部分组成;状态行、响应头标、空行、响应数据. 状态行 : 状态行由三个标记组成:HTTP版本、响应代码和响应描述. HTTP版本 : 向客户端指明其可理解的最高版本. 响应代码 : 3位的数字代码,指出请求的成功或失败,如果失败则指出原因. 响应描述 : 为响应代码的可读性解释. 例如 : HTTP/1.1200OK HTTP响应码 :1xx:信息,请求收到,继续处理2xx:成功,行为被成功地接受、理解和采纳3xx:重定向,为了完成请求,必须进一步执行的动作4xx:客户端错误 : 响应头标 : 像请求头标一样,它们指出服务器的功能,标识出响应数据的细节. 空行 : 最后一个响应头标之后是一个空行,发送回车符和退行,表明服务器以下不再有头标. 响应数据 : HTML文档和图像等,也就是HTML本身. 四、服务器关闭连接,浏览器解析响应 浏览器首先解析状态行,查看表明请求是否成功的状态代码. 然后解析每一个响应头标,头标告知以下为若干字节的HTML. 读取响应数据HTML,根据HTML的语法和语义对其进行格式化,并在浏览器窗口中显示它. 一个HTML文档可能包含其它需要被载入的资源引用,浏览器识别这些引用,对其它的资源再进行额外的请求,此过程循环多次. 五、无状态连接HTTP模型是无状态的,表明在处理一个请求时,Web服务器并不记住来自同一客户端的请求. ##实例 浏览器发出请求GET/index.htmlHTTP/1.1 服务器返回响应HTTP/1.1200OK Date:Apr11200615:32:08GMT Server:Apache/2.0.46(win32) Content-Length:119 Content-Type:text/html&lt;HTML&gt;&lt;HEAD&gt;&lt;LINKREL=&quot;stylesheet&quot;HREF=&quot;index.css&quot;&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;IMGSRC=&quot;image/logo.png&quot;&gt;&lt;/BODY&gt;&lt;/HTML&gt; 浏览器发出请求GET/index.cssHTTP/1.1 服务器返回响应HTTP/1.1200OK Date:Apr11200615:32:08GMT Server:Apache/2.0.46(win32) Connection:Keep-alive,close Content-Length:70 Content-Type:text/plane h3{ font-size:20px; font-weight:bold; color:#005A9C; } 浏览器发出请求GETimage/logo.pngHTTP/1.1 服务器返回响应HTTP/1.1200OK Date:Apr11200615:32:08GMT Server:Apache/2.0.46(win32) Connection:Keep-alive,close Content-Length:1280 Content-Type:text/plane {Binaryimagedatafollows} 附录 HTTP规范 : Internet工程制定组织(IETF)发布的RFC指定Internet标准,这些RFC被Internet研究发展机构广泛接受.因为它们是标准文档,故一般用正规语言编写,如立法文标一样. RFC : RFC一旦被提出,就被编号且不会再改变,当一个标准被修改时,则给出一个新的RFC.作为标准,RFC在Internet上被广泛采用. HTTP的几个重要RFC :RFC1945HTTP1.0描述RFC2068HTTP1.1初步描述RFC2616HTTP1.1标准 资源标识符URI(UniformResourceIdentifter,URI) HTTP参考 一、HTTP码应码响应码由三位十进制数字组成,它们出现在由HTTP服务器发送的响应的第一行. 响应码分五种类型,由它们的第一位数字表示: 1xx:信息,请求收到,继续处理 2xx:成功,行为被成功地接受、理解和采纳 3xx:重定向,为了完成请求,必须进一步执行的动作 4xx:客户端错误,请求包含语法错误或者请求无法实现 5xx:服务器错误,服务器不能实现一种明显无效的请求 下表显示每个响应码及其含义 :12345678910111213141516171819202122232425262728293031323334353637383940100 继续101 分组交换协200 OK201 被创建202 被采纳203 非授权信息204 无内容205 重置内容206 部分内容300 多选项301 永久地传送302 找到303 参见其他304 未改动305 使用代理307 暂时重定向400 错误请求401 未授权402 要求付费403 禁止404 未找到405 不允许的方法406 不被采纳407 要求代理授权408 请求超时409 冲突410 过期的411 要求的长度412 前提不成立413 请求实例太大414 请求URI太大415 不支持的媒体类型416 无法满足的请求范围417 失败的预期500 内部服务器错误501 未被使用502 网关错误503 不可用的服务504 网关超时505 HTTP版本未被支持 二、HTTP头标 头标由主键/值对组成.它们描述客户端或者服务器的属性、被传输的资源以及应该实现连接. 四种不同类型的头标 : 通用头标 : 即可用于请求,也可用于响应,是作为一个整体而不是特定资源与事务相关联. 请求头标 : 允许客户端传递关于自身的信息和希望的响应形式. 响应头标 : 服务器和于传递自身信息的响应. 实体头标 : 定义被传送资源的信息.即可用于请求,也可用于响应.头标格式 : &lt;name&gt;:&lt;value&gt;&lt;CRLF&gt; 下表描述在HTTP/1.1中用到的头标 Accept : 定义客户端可以处理的媒体类型,按优先级排序;在一个以逗号为分隔的列表中,可以定义多种类型和使用通配符.例如:Accept: image/jpeg,image/png,/ Accept-Charset : 定义客户端可以处理的字符集,按优先级排序;在一个以逗号为分隔的列表中,可以定义多种类型和使用通配符.例如 : Accept-Charset: iso-8859-1,*,utf-8 Accept-Encoding : 定义客户端可以理解的编码机制.例如:Accept-Encoding:gzip,compress Accept-Language : 定义客户端乐于接受的自然语言列表.例 如:Accept-Language: en,de Accept-Ranges : 一个响应头标,它允许服务器指明:将在给定的偏移 和长度处,为资源组成部分的接受请求.该头标的值被理解为请求范围的度量单位.例如Accept-Ranges: bytes或Accept-Ranges: none Age : 允许服务器规定自服务器生成该响应以来所经过的时间长度,以秒为单位.该头标主要用于缓存响应.例如:Age: 30 Allow : 一个响应头标,它定义一个由位于请求URI中的次源所支持的HTTP方法列表.例如:Allow: GET,PUT aUTHORIZATION : 一个响应头标,用于定义访问一种资源所必需的授权(域和被编码的用户ID与口令).例如 : Authorization: Basic YXV0aG9yOnBoaWw= Cache-Control : 一个用于定义缓存指令的通用头标.例如:Cache-Control: max-age=30 Connection : 一个用于表明是否保存socket连接为开放的通用头标.例如 : Connection: close或Connection: keep-alive Content-Base : 一种定义基本URI的实体头标,为了在实体范围内解析相对URLs.如果没有定义Content-Base头标解析相对URLs,使用Content-Location URI(存在且绝对)或使用URI请求.例如:Content-Base: Http://www.myweb.com Content-Encoding : 一种介质类型修饰符,标明一个实体是如何编码的.例如:Content-Encoding: zip Content-Language : 用于指定在输入流中数据的自然语言类型.例如 : Content-Language: en Content-Length : 指定包含于请求或响应中数据的字节长度.例如 : Content-Length:382 Content-Location : 指定包含于请求或响应中的资源定位(URI).如果是一绝.对URL它也作为被解析实体的相对URL的出发点.例如 : Content-Location:http://www.myweb.com/news Content-MD5 : 实体的一种MD5摘要,用作校验和.发送方和接受方都计算MD5摘要,接受方将其计算的值与此头标中传递的值进行比较.例如 : Content-MD5: Content-Range : 随部分实体一同发送;标明被插入字节的低位与高位字节偏移,也标明此实体的总长度.例如 : Content-Range : 1001-2000/5000 Contern-Type : 标明发送或者接收的实体的MIME类型.例如 : Content-Type: text/html Date : 发送HTTP消息的日期.例如:Date: Mon,10PR 18:42:51 GMT ETag : 一种实体头标,它向被发送的资源分派一个唯一的标识符.对于可以使用多种URL请求的资源,ETag可以用于确定实际被发送的资源是否为同一资源.例如 : ETag: “208f-419e-30f8dc99” Expires : 指定实体的有效期.例如 : Expires: Mon,05 Dec 2008 12:00:00 GMT Form : 一种请求头标,给定控制用户代理的人工用户的电子邮件地址.例如 : From:webmaster@myweb.com Host被请求资源的主机名.对于使用HTTP/1.1的请求而言,此域是强制性的.例如 : Host : www.myweb.com If-Modified-Since如果包含了GET请求,导致该请求条件性地依赖于资源上次修改日期.如果出现了此头标,并且自指定日期以来,此资源已被修改,应该反回一个304响应代码.例如 : If-Modified-Since: Mon,10PR 18:42:51 GMT If-Match : 如果包含于一个请求,指定一个或者多个实体标记.只发送其ETag与列表中标记区配的资源.例如 : If-Match : “208f-419e-308dc99” If-None-Match : 如果包含一个请求,指定一个或者多个实体标记.资源的ETag不与列表中的任何一个条件匹配,操作才执行.例如 : If-None-Match : “208f-419e-308dc99” If-Range : 指定资源的一个实体标记,客户端已经拥有此资源的一个拷贝.必须与Range头标一同使用.如果此实体自上次被客户端检索以来,还不曾修改过,那么服务器只发送指定的范围,否则它将发送整个资源.例如 : Range: byte=0-499If-Range:”208f-419e-30f8dc99” If-Unmodified-Since : 只有自指定的日期以来,被请求的实体还不曾被修改过,才会返回此实体.例如 : If-Unmodified-Since:Mon,10PR 18:42:51 GMT Last-Modified : 指定被请求资源上次被修改的日期和时间.例如:Last-Modified: Mon,10PR 18:42:51 GMT Location : 对于一个已经移动的资源,用于重定向请求者至另一个位置.与状态编码302(暂时移动)或者301(永久性移动)配合使用.例如 : Location : http://www2.myweb.com/index.jsp Max-Forwards : 一个用于TRACE方法的请求头标,以指定代理或网关的最大数目,该请求通过网关才得以路由.在通过请求传递之前,代理或网关应该减少此数目.例如:Max-Forwards: 3 Pragma : 一个通用头标,它发送实现相关的信息.例如 : Pragma: no-cache Proxy-Authenticate : 类似于WWW-Authenticate,便是有意请求只来自请求链(代理)的下一个服务器的认证.例如 : Proxy-Authenticate: Basic realm-admin Proxy-Proxy-Authorization : 类似于授权,但并非有意传递任何比在即时服务器链中更进一步的内容.例如 : Proxy-Proxy-Authorization: Basic YXV0aG9yOnBoaWw= Public : 列表显示服务器所支持的方法集.例如 : Public : OPTIONS,MGET,MHEAD,GET,HEAD Range : 指定一种度量单位和一个部分被请求资源的偏移范围.例如 : Range : bytes=206-5513 Refener : 一种请求头标域,标明产生请求的初始资源.对于HTML表单,它包含此表单的Web页面的地址.例如 : Refener : http://www.myweb.com/news/search.html Retry-After : 一种响应头标域,由服务器与状态编码503(无法提供服务)配合发送,以标明再次请求之前应该等待多长时间.此时间即可以是一种日期,也可以是一种秒单位.例如:Retry-After: 18 Server : 一种标明Web服务器软件及其版本号的头标.例如 : Server : Apache/2.0.46(Win32) Transfer-Encoding : 一种通用头标,标明对应被接受方反向的消息体实施变换的类型.例如:Transfer-Encoding: chunked Upgrade : 允许服务器指定一种新的协议或者新的协议版本,与响应编码101(切换协议)配合使用.例如 : Upgrade : HTTP/2.0 User-Agent : 定义用于产生请求的软件类型(典型的如Web浏览器).例如 : User-Agent : Mozilla/4.0(compatible; MSIE 5.5; Windows NT; DigExt) Vary : 一个响应头标,用于表示使用服务器驱动的协商从可用的响应表示中选择响应实体.例如:Vary: * Via : 一个包含所有中间主机和协议的通用头标,用于满足请求.例如 : Via: 1.0 fred.com, 1.1 wilma.com Warning : 用于提供关于响应状态补充信息的响应头标.例如:Warning: 99 www.myweb.com Piano needs tuning www-Authenticate : 一个提示用户代理提供用户名和口令的响应头 标,与状态编码401(未授权)配合使用.响应一个授权头标.例如 : www-Authenticate: Basic realm=zxm.mgmt]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第2章 算法]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[算法 :算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作. 1. 两种算法的比较一个求 1 + 2 + 3 + … +100结果的程序 : 123456int i, sum = 0, n = 100;for( i = 1; i &lt;= n; i++)&#123; sum = sum + i;&#125;printf("%d",sum); 高斯解析道 :sum = 1 + 2 + 3 + … + 99 + 100sum = 100 +99 + 98 + … + 2 + 12xsum = 101 + 101 + 101 + … + 101 + 101共 100 个 / 所以 sum = 5050 用程序实现如下 :123int i, sum = 0, n = 100;sum = (1+n) * n / 2;printf("%d",sum); 2. 算法的定义 算法是解决特定问题求解步骤的描述,在计算机中表现为指令有限序列,并且每条指令表示一个或多个操作. 3. 算法的特征算法具有五个基本特征 : 输入 / 输出 / 有穷性 / 确定性和可行性. 输入输出 :算法具有零个或多个输入.算法至少有一个输出或多个输出. 有穷性 :指算法在执行有限的步骤之后,自动结束而不会出现无限循环,并且每一个步骤在可接受的时间内完成. 确定性 :算法的每一步骤具有确定的含义,不会出现二义性.算法在一定条件下,只有一条执行路径,相同的输入只能有唯一的输出结果.算法的每个步骤被精准定义而无歧义. 可行性 :算法的每一步都必须是可行的,也就是说,每一步都能够通过执行有限的次数完成. 4. 算法设计的要求 正确性 :算法的正确性是指算法至少应该具有输入,输出和加工处理无歧义,能正确反映问题的需求,能够得到问题的正确答案. 可读性 :算法设计的另一目的是为了便于阅读,理解和交流. 健壮性 :当输入数据不合法时,算法也能做出相关的处理,而不是产生异常或莫名其妙的问题. 时间效率高和存储量低 :时间效率指的是算法的执行时间,对于同一个问题,如果有多个算法能够解决,执行时间短的算法效率最高,存储量需求指的是算法在执行过程中需要的最大存储空间,主要是指算法程序运行时所占用的内存或外部硬盘存储空间.设计算法应该尽量满足时间效率高和存储量低的需求.花最少的时间,办最大的事. 5. 算法效率的度量方法 事后统计方法 :这种方法主要是通过设计的好的测试程序和数据,利用计算机时器对不同算法编制的程序的运行时间进行比较,从而确定算法效率的高低. (因受机器的影响,我们考虑不予采纳) 事前分析估算方法 :在计算机程序编制前,依据统计方法对算法进行估算.一个程序的运行时间,依赖于算法的好坏和问题的输入规模,所谓问题输入规模是指输入量的多少. 第一种算法 : 123456int i, sum = 0, n = 100; //执行一次for( i = 1; i &lt;= n; i++) //执行N+1次&#123; sum = sum + i; //执行N次&#125;printf("%d",sum); //执行一次 第二种算法 : 123int i, sum = 0, n = 100; //执行一次sum = (1+n) * n / 2; //执行一次printf("%d",sum); //执行一次 显然第一种执行了2n+3次,而第二种算法执行了3次.最终,在分析程序的运行时间时,最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤. 6. 函数的渐近增长 函数的渐进增长 : 给定两个函数 f(n) 和 g(n) ,如果存在一个整数 N ,使得对于所有的 n &gt; N, f(n) 总是比 g(n) 大,那么,我们说 f(n) 的增长渐近快于 g(n). 判断一个算法的效率时,函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数. 某个算法,随着n的增大,它会越来越优于另一个算法,或者越来越差于另一个算法. 7. 算法时间复杂度定义 在进行算法分析时,语句总的执行次数 T(n) 是关于问题规模 n 的函数,进而分析 T(n) 随 n 的变化情况而确定 T(n) 的数量级.算法的时间复杂度,也就是算法的时间量度.记做 : T(n) = O(f(n)).它表示随问题规模 n 的增大,算法执行时间的增长率和 f(n) 的增长率相同,称作算法的渐近时间复杂度.简称为时间复杂度.其在 f(n) 是问题规模 n 的某个函数. 一般情况下, T(n) 增长最慢的算法为最优算法. 推导大 O 阶方法 用常数 1 取代运行时间中所有的加法常数. 在修改后的运行次数函数中,只保留最高阶项. 如果最高阶项在且不是 1 ,则去除与这个项相乘的常数. 常数阶如高斯算法运行次数 f(n) = 3 ,第一步就是把常数项3改为1,所以为 O(1). 线性阶如 : for(i = 0; i &lt; n; i++){} 它的循环时间复杂度为 O(n) ,因为循环体中的代码须要执行 n 次. 对数阶int count = 1; while(count&lt;n){ count = count * 2; } 由于每次 count 乘以 2 之后,就距离 n 更近了一分.也就说说,有多少个 2 相乘后大于 n,则会退出循环. 由 2^x=n 得到 x=log2n.所以这个循环的时间复杂度为O[logn] 平方阶下面是循环嵌套,它的内循环时间复杂度为 : O(n).12345678 int i,j; for(i=0; i&lt;n; i++)&#123; for(j=0; j&lt;n; j++) &#123; // 时间复杂度为O(1)的程序步骤系列 &#125;&#125; 对于外循环,不过是内部这个时间复杂度为 O(n) 的语句,再循环n次.所以这段代码的时间复杂度为 O(n^2).如果外循环的次数改为m,时间复杂度为 O(m*n). 总结出 :循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数. 12345678 int i,j; for(i=0; i&lt;n; i++)&#123; for(j=i; j&lt;n; j++) &#123; // 时间复杂度为O(1)的程序步骤系列 &#125;&#125; 由于 i = 0 时,内循环执行了 n 次,当 i = 1 时,执行了 n-1 次,… 当 i = n - 1 时,执行了1次.所以总的执行次数为 : 用大 O 阶的方法,该段代码时间复杂度为 O(n^2). 12345678910 int i,j; for(i=0; i&lt;n; i++)&#123; function(i);&#125;void function(int count)&#123; print(count);&#125; 整体的时间复杂度为 O(n). 8. 常见的时间复杂度 常用的时间复杂度所耗费的时间从小到大依次是 : 9. 最坏情况和平均情况最坏情况运行时间是一种保证,那就是运行时间将不会再坏了.在应用中,这是一种最重要的需求.通常,除非特别指定,我们提到的运行时间都是最坏情况下的运行时间. 平均运行时间是所有情况中最有意义的,因为它是期望的运行时间. 10. 算法空间的复杂度算法的空间复杂度通过计算算法所需的存储空间实现,算法空间复杂度的计算公式记做 : S(n) = O(f(n)),其中,n 为问题的规模, f(n) 为语句 n 所占存储空间的函数. 11. 总结 算法的定义 :算法是解决特定问题求解步骤的描述,在计算机中为指令的有限序列,并且每条指令表示一个或多个操作. 算法的特征 :有穷性,确定性,可行性,输入,输出. 算法的设计要求 :正确性,可读性,健壮性,高效性和低存储量需求. 算法的度量方法 :事后统计方法(不科学),事前分析估算方法. 函数的渐近增长 :给定两个函数 f(n) 和 g(n) ,如果存在一个整数 N ,使得对于所有的 n &gt; N ,f(n) 总是比 g(n) 大,那么,我们说 f(n) 的增长渐近快于 g(n). 可以分析出 : 随着 n 的变大, 它会越来越优于另一算法,或者越来越差于另一算法. 推导大 O 阶 : 用常数 1 取代运行时间中所有加法常数 在修改后的运行次数函数中,只保留最高阶项 如果最高阶项存在且不是1,则去除与这个项相乘的常数得到的结果就是大 O 阶.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第1章 数据结构绪论]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[数据结构 : 是相互之间存在一种或多种特定关系的数据元素的集合.数据结构是一种研究非数值计算的程序设计问题的操作对象,以及它们之间的关系和操作等相关问题的学科. 程序设计 = 数据结构 + 算法 数据 : 是描述客观事物的符号,是计算机可以操作的对象,是能被计算机识别,并输入到计算机处理的符号集合.数据不仅仅包括整型 / 实数等数值类型,还包括字符及声音 / 图像 / 视频等非数值类型. 可以输入到计算机中 能被计算程序处理 数据元素 : 是组成数组的 / 有一定意义的基本单位,在计算机中通常作为整体处理,也被称为元素.如人类中,人就是数据元素. 数据项 : 一个数据元素可以由若干个数据项组成.如人的数据元素中,可以有眼,耳,嘴,鼻,手,脚等这些数据项. 数据项是数据不可分割的最小单位. 数据对象 : 是性质相同的数据元素的集合,是数据的子集.是指数据元素具有相同数量和类型的数据项.如 : 人都有姓名 / 生日 / 性别等相同的数据项. 在现实世界中,不同数据元素之间不是独立的,而是存在特定关系,我们将这些关系称为结构. 数据结构 : 是相互之间存在一种或多种特定关系的数据元素的集合. 在计算机中,数据元素并不是孤立/杂乱无章的,而是具有内在联系的数据集合.数据元素之间存在的一种或多种特定关系,也就是数据的组织形式. 逻辑结构 : 是指数据对象中数据元素之间的相互关系. 集合结构 : 集合结构中的数据元素除了同属于一个集合外,它们之间没有其他关系.各个数据元素是”平等”的,它们的共同属性是”同属于一个集合”. 线性结构 : 线性结构中的数据元素之间是一对一的关系. 树形结构 : 树形结构中的数据元素之间存在一种一对多的层次关系. 图形结构 : 图形结构的数据元素是多对多的关系. 将每一个数据元素看做一个结点,用圆圈表示. 元素之间的逻辑关系用结点之间的连线表示,如果这个关系是有方向的,那么用带箭头的连线表示. 物理结构 : 是指数据的逻辑结构在计算机中的存储方式.数据元素的存储结构形式有两种 : 顺序存储和链式存储. 顺序存储结构 : 是把数据元素存放在地址连续的存储单元里,其数据间的逻辑关系和物理关系是一致的. 链式存储结构 : 是把数据元素存放在任意的存储单元里,这组逻辑单元可以使连续的,也可以是不连续的.数据元素的存储关系并不能反映其逻辑关系,因此需要用一个指针存放数据元素的地址,这些通过地址就可以找到相关联数据元素的位置. (如银行的排队系统,当我领取到号码后,我不需要总是站着等排队) 数据类型 : 是指一组性质相同的值集合及定义在此集合上的一些操作的总称.数据类型是按照值的不同进行划分,在高级语言中,每个变量,常量和表达式都有各自的取值范围.类型就用来说明变量或表达式的取值范围和所能进行的操作. 在C语言中,按照取值的不同,数据类型可以分为两类 : 原子类型 : 是不可以再分解的基本类型,包括整型,实型,字符型等. 结构类型 : 由若干个类型组合而成,是可以再分解的.例如,整型数组是由若干整型数据组成的. 抽象是指抽取出事物具有的普遍性的本质.它是抽出问题的特征而忽略非本质的细节,是对具体事物的一个概括.抽象是一种思考问题的方式,它隐藏了繁杂的细节,只保留实现目标所必须的信息. 抽象数据类型 : 是指一个数学模型及定义在该模型上的一组操作.抽象数据类型的定义仅取决于它的一组逻辑特征,而非其在计算机内部如何表示和实现无关. 事实上,抽象数据类型体现了程序设计中问题分解,抽象和信息隐藏的特征.抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题,然后建立一个计算机能处理的数据模型,并把每个功能模块的实现细节作为一个独立的单元,从而使具体实现过程隐藏起来. 总结 : 数据结构是相互之间存在一种或多种特定关系的数据元素集合.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第5章 条件,循环和其他语句]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC5%E7%AB%A0-%E6%9D%A1%E4%BB%B6-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B6%E4%BB%96%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[1. print 和 import 的更多信息 提示对于很多应用程序来说,使用logging模块记日志比print语句更合适. 1.1 使用逗号输出12345&gt;&gt;&gt; name = 'kevin'&gt;&gt;&gt; age = 19&gt;&gt;&gt; print name,agekevin 19&gt;&gt;&gt; 1.2 把某些事作为另一件事导入从模块导入函数,通常可以使用 : import somemodule from somemodule import somefunction from somemodule import somefunction,anotherfunction,yetanotherfuction from somemodule import * 如果两个模板都有相同函数,可以在语句末尾增加一个as子句,在子句后给出想要的别名.1234&gt;&gt;&gt; import math as foobar&gt;&gt;&gt; foobar.sqrt(4)2.0&gt;&gt;&gt; 或者为函数提供别名 1234&gt;&gt;&gt; from math import sqrt as foobar&gt;&gt;&gt; foobar(4)2.0&gt;&gt;&gt; 2. 赋值魔法2.1 序列解包多个赋值的操作可以同时进行 :1234&gt;&gt;&gt; x,y,z = 1,2,3&gt;&gt;&gt; print x,y,z1 2 3&gt;&gt;&gt; 交换两个(或多个)变量 :1234&gt;&gt;&gt; x,y = y,x&gt;&gt;&gt; print x,y,z2 1 3&gt;&gt;&gt; 还可以这样玩 :1234567&gt;&gt;&gt; values = 1,2,3&gt;&gt;&gt; values(1, 2, 3)&gt;&gt;&gt; x,y,z = values&gt;&gt;&gt; x1&gt;&gt;&gt; 2.2 链式赋值链式赋值(chained assignment) 是将同一个值赋给多个变量的捷径. x = y = somefunction() 2.3 增量赋值x = x + 1 等于 x+=1 3. 语句块 : 缩排的乐趣 注意使用tab字符也可以缩进语句块.Python将一个tab字符解释为到下一个tab字符位置的移动,而一个tab字符位置为8个空格,但是标准且推荐的方式是只用空格,尤其是在每个缩进需要4个空格的时候. 4. 条件和条件语句4.1 这就是布尔变量的作用下面的值作为布尔表达式的时候,会被解释器看做假(false)False None 0 &quot;&quot; () [] {} 注意尽管[]和””都是假值,但是它们本身不相等. 4.2 条件执行和if语句1234567What is your name?kevin&gt;&gt;&gt; if name.endswith('kevin'): print 'hello'+namehellokevin&gt;&gt;&gt; 4.3 else语句12345678What is your name?kevin&gt;&gt;&gt; if name.endswith('kevin') : print 'hello'+name else : print 'hello'hellokevin&gt;&gt;&gt; 4.4 elif子句elif是else if的简写 4.5 嵌套代码块12345678910name = raw_input("What is your name?")if name.endswith('Gumby'): if name.startswith('Mr.'): print 'Hello,Mr.Gumby' elif name.startswith('Mrs.'): print 'Hello,Mrs.Gumby' else: print 'Hello,Gumby'else: print 'hello,stranger' 4.6 更复杂的条件 表达式 描述 x is y x和y是同一个对象 x is not y x和y是不同的对象 x in y x是y容器(例如,序列)的成员 x not in y x不是y容器(例如,序列的)成员 相等运算符 ‘foo’ = ‘foo’ is : 同一性运算符is 运算符是判定同一性而不是相等性.变量x和变量y都被绑定到同一个列表上,而变量z被绑定在另外一个具有相同数值和顺序的列表上. 总结 : 使用 == 运算符来判定两个对象是否相等,使用is判定两者是否相同(同一个对象). 4.7 断言123456789The number is positive&gt;&gt;&gt; age = -1&gt;&gt;&gt; assert 0 &lt;age&lt;100Traceback (most recent call last): File "&lt;pyshell#32&gt;", line 1, in &lt;module&gt; assert 0 &lt;age&lt;100AssertionError 5. 循环 while 循环 : 1234x = 1while x&lt;=100: print x x+=1 for 循环 : 123456789101112131415161718&gt;&gt;&gt; words = ['this','is','an','ex']&gt;&gt;&gt; for word in words: print wordthisisanex# 或者:&gt;&gt;&gt; range(0,10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# 或者 : &gt;&gt;&gt; 循环遍历字典元素 123456789&gt;&gt;&gt; d = &#123;'x':1,'y':2,'z':3&#125;&gt;&gt;&gt; for key in d: print key,d[key]y 2x 1z 3&gt;&gt;&gt; 5.4 一些迭代工具 并行迭代 1234567&gt;&gt;&gt; names = ['kevin','leona']&gt;&gt;&gt; ages = [22,21]&gt;&gt;&gt; for i in range(len(names)): print names[i],ages[i],'years old'kevin 22 years oldleona 21 years old 5.5 跳出循环break : 结束本次循环continue : 跳过本次循环 6. 列表推导式 - 轻量级循环列表推导式(List comprehension) 是利用其他列表创建新列表. 12&gt;&gt;&gt; [x*x for x in range(10)][0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 7. 总结 函数 描述 chr(n) 当传入序号n时,返回n所代表的包含一个字符的字符串,(0&lt;=n&lt;256) eval(source[,globals[,locals]]) 将字符串作为表达式计算,并且返回值 enumerate(seq) 产生用于迭代(索引,值)对 ord(c) 返回单字符字符串的int值 range([start,]stop[,step]) 创建整数的列表 reversed(seq) 产生seq中值的反向版本,用于迭代 sorted(seq[,cmp][,key][,reverse]) 返回seq中值排序后的列表 xrange([start,]stop[,step]) 创建xrange对象用于迭代 zip(seq1,seq2) 创建用于并行迭代的新序列]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第4章 字典:当索引不好用时]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC4%E7%AB%A0-%E5%AD%97%E5%85%B8-%E5%BD%93%E7%B4%A2%E5%BC%95%E4%B8%8D%E5%A5%BD%E7%94%A8%E6%97%B6%2F</url>
      <content type="text"><![CDATA[字典是Python中唯一内建的映射类型.字典中的值并没有特殊的顺序,但是都存储在一个特定的键(Key)下.键可以是数字/字符串甚至是元组. 1. 字典的使用 表示一个游戏棋盘的状态,每个键都是由坐标值组成的元组; 存储文件修改时间,用文件名作为键. 数字电话/地址簿. 2. 创建和使用字典 字典可以通过下面的方式创建 :phonebook = {&#39;Kevin&#39;:&#39;520&#39;,&#39;Leona&#39;:&#39;1314&#39;} 字典由多个键及其对应的值构成的键-值对组成,在上面的例子中,名字是键,数字则是值.每个键和它的值之间用冒号(:)隔开,项之间用逗号(,)隔开,而整个字典都是由一对大括号括起来.空字典(不包括任何项)由两个大括号组成,像这样 : {}. 2.1 dict函数dict函数,通过其它映射(比如其他字典)或者(键,值)对的序列建立字典. 12345&gt;&gt;&gt; items = [('name','kevin'),('age',21)]&gt;&gt;&gt; d = dict(items)&gt;&gt;&gt; d['name']'kevin'&gt;&gt;&gt; dict函数也可以通过关键字参数来创建字典 :1234&gt;&gt;&gt; d = dict(name="Kevin",age=42)&gt;&gt;&gt; d&#123;'age': 42, 'name': 'Kevin'&#125;&gt;&gt;&gt; 2.2 基本字典操作字典的基本行为在很多方面与序列(sequence)类型 : len(d)返回d中项(键-值对)的数量; d[k]返回关联到键k上的值; d[k] = v 将值v关联到见k上; del d[k] 删除键为k的项 k in d 检查d中是否有含有键为k的项. 键类型 : 字典的键不一定为整数类型,键可以是任意的不可变类型,比如浮点型(实型),字符串或者元组. 自动添加 : 即使键起初在字典中并不存在,也可以为它赋值,这样字典就会建立新的项. 成员资格 : 表达式 k in d(d为字典)查找的键,而不是值.表达式v in l(l为列表)则用来查找值,而不是索引. 键可以是任意不可变类型 :12345&gt;&gt;&gt; x = &#123;&#125;&gt;&gt;&gt; x[12] = 'kevin'&gt;&gt;&gt; x&#123;12: 'kevin'&#125;&gt;&gt;&gt; 2.3 字典的格式化字符串123&gt;&gt;&gt; "Cecil's phone number is %(Cecil)s."%phonebook"Cecil's phone number is 3258."&gt;&gt;&gt; 2.4 字典方法 clearclear方法清除字典中所有的项.这个是原地操作,所以无返回值. 12345678&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d['name'] = 'kevin'&gt;&gt;&gt; d&#123;'name': 'kevin'&#125;&gt;&gt;&gt; d.clear()&gt;&gt;&gt; d&#123;&#125;&gt;&gt;&gt; copycopy方法返回一个具有相同键-值对的新字典.(这个方法实现的浅复制,因为值本身就是相同的,而不是副本.) 12345 &gt;&gt;&gt; x = &#123;'username':'admin','pasword':123456&#125;&gt;&gt;&gt; y = x.copy()&gt;&gt;&gt; y&#123;'username': 'admin', 'pasword': 123456&#125;&gt;&gt;&gt; 但是,如果修改了某个值(原地修改,而不是替换),原始的值也会改变,因为同样的值存储在原字典中.模块的deepcopy函数来完成操作. 123456789&gt;&gt;&gt; from copy import deepcopy&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d['names'] = ['Kevin','Leona']&gt;&gt;&gt; c = d.copy()&gt;&gt;&gt; dc = deepcopy(d)&gt;&gt;&gt; d['names'].append('Clive')&gt;&gt;&gt; c&#123;'names': ['Kevin', 'Leona', 'Clive']&#125;&gt;&gt;&gt; fromkeysfromkeys方法使用给定的键建立新的字典,每个键都对应一个默认的的值None. 123&gt;&gt;&gt; &#123;&#125;.fromkeys(['name','age'])&#123;'age': None, 'name': None&#125;&gt;&gt;&gt; getget方法是个更宽松的字典项的方法,当使用get访问一个不存在的键时,没有任何异常,而得到了None值.还可以自定义”默认值”,替换None. 12&gt;&gt;&gt; d.get('name','N/A')'N/A' has_keyhas_key方法可以检查字典中是否有特定的键.表达式d.has_key(k)相当于表达式k in d. 123456&gt;&gt;&gt; d = &#123;'name':'kevin'&#125;&gt;&gt;&gt; d.has_key('name')True&gt;&gt;&gt; d.has_key("password")False&gt;&gt;&gt; items和iteritemsitems方法将所有字典的项以列表方式返回,列表中的每一项都表示为(键,值)对的形式.但是项在返回时并没有遵循特定的次序. keys和iterkeyskeys方法将字典中的键以列表形式返回,而iterkeys则返回针对键的迭代器. poppop方法用来获得对应给定键的值,然后将这个键-值对从字典中移除. 123456&gt;&gt;&gt; d = &#123;'x':1,'y':2&#125;&gt;&gt;&gt; d.pop('x')1&gt;&gt;&gt; d&#123;'y': 2&#125;&gt;&gt;&gt; popitempopitem方法类似于list.pop,后者会弹出列表的最后一个元素. setdefaultsetdefault方法在某种程度上类型于get方法,能够获得与给定键相关联的值,除此之外,setdefault还能在字典中不包含有给定键的情况下设定相应的键值. 12345&gt;&gt;&gt; d.setdefault('name','N/A')'N/A'&gt;&gt;&gt; d['name'] = 'kevin'&gt;&gt;&gt; d.setdefault('name','N/A')'kevin' 可以看到,当键不存在的时,setdefault返回默认值并且相应地更新字典.如果键存在,那么就返回与其对应的值,但不改变字典.默认值是可选的,这点和get一样. updateupdate方法可以利用一个字典项更新另外一个字典 : 123456&gt;&gt;&gt; d = &#123;'title':'python Web Site','url':'http://www.python.org'&#125;&gt;&gt;&gt; x = &#123;'title':'python language website'&#125;&gt;&gt;&gt; d.update(x)&gt;&gt;&gt; d&#123;'url': 'http://www.python.org', 'title': 'python language website'&#125;&gt;&gt;&gt; values和itervaluesvalues方法以列表的形式返回字典中的值(itervalues返回值的迭代器).与返回键的列表不同的是,返回值的列表中可以包含重复的元素. 123456&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d[1] = 1&gt;&gt;&gt; d[2] = 2&gt;&gt;&gt; d.values()[1, 2]&gt;&gt;&gt; 3. 小结 映射 : 映射可以使用任意不可变对象标识元素,最常用的类型是字符串和元组. 利用字典格式化字符串 : 可以通过在格式化说明中包括名称(键)来对字典应用字符串格式化操作.当在字符格式化中使用元组时,还需要对元组中每一个元素都设定”格式化说明符”.在使用字典时,所有的说明符可以比在字典中用到的项少. 字典的方法 : 字典很多方法,调用的方式和调用列表以及字符串方法的方式相同.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第3章 使用字符串]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC3%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[1. 基本字符串操作字符串是不可变的,如下所示的项或分片赋值都是不合法的. 2. 字符串格式化 : 精简版字符串格式化使用字符串格式化操作符即百分号%来实现的. 注意%也可以用来做模运算(求余)操作符. 在%的左侧位置放置一个字符串(格式化字符串),而右侧则放置希望被格式化的值.可以使用一个值,如一个字符串或者数字,也可以使用多个值的元组或者字典. 格式化字符串的%s部分被称为转换说明符,它们标记了需要插入转换值的位置.s表示植会被格式化为字符串-&gt;如果不是字符串,则会用str将其转换为字符串. 3. 字符串方法字符串从string模块中”继承”了很多方法. 3.1 findfind方法可以在一个较长的字符串中查找子串.它返回子串所在位置的最左端索引.如果没有找到返回-1. 123456&gt;&gt;&gt; 'hello,my name is kevin'.find('kevin')17&gt;&gt;&gt; title = "I love China."&gt;&gt;&gt; title.find(love)&gt;&gt;&gt; title.find('love')2 这个方法还可以接收可选的起始点和结束点参数. 123456&gt;&gt;&gt; subject = '$$$ Get rich now!!! $$$'&gt;&gt;&gt; subject.find('$$$',1)20&gt;&gt;&gt; subject.find('!!',0,16) #操作起始点和终止点-1&gt;&gt;&gt; 3.2 joinjoin方法是split方法的逆方法,用来连接序列中的元素 :12345&gt;&gt;&gt; seq=['1','2','3']&gt;&gt;&gt; sep = '+'&gt;&gt;&gt; sep.join(seq)'1+2+3'&gt;&gt;&gt; 3.3 lowerlower方法返回字符串的小写字母版本,这个方法会忽略字母的小写状态.123&gt;&gt;&gt; 'HELLO'.lower()'hello'&gt;&gt;&gt; 如果想要在列表中查找一个用户名是否存在 : 列表包含字符串”kevin”,而用户输入的是”Kevin”,就能找到了.解决方法就是在存储和搜索时把所有名字都转换为小写. 123456&gt;&gt;&gt; name = "Kevin"&gt;&gt;&gt; names = ['kevin','leona']&gt;&gt;&gt; if name.lower() in names: print 'Found it!'Found it!&gt;&gt;&gt; 标题转换和lower方法相关的是title方法,它会将字符串转换为标题(也就是所有的单词的首字母大写,而其他字母小写.) 3.4 replacereplace方法返回某字符串的所有匹配项均被替换之后的字符串,应用于文档的查找和替换. 123&gt;&gt;&gt; 'This is a apple'.replace('is a apple','are some apples')'This are some apples'&gt;&gt;&gt; 3.5 split它是join的逆方法,用来将字符串分割成序列. 12345&gt;&gt;&gt; '1+2+3+4+5+6'.split('+')['1', '2', '3', '4', '5', '6']&gt;&gt;&gt; 'hello hello'.split()['hello', 'hello']&gt;&gt;&gt; 3.6 stripstrip方法返回除两侧(不包括内部)的空格字符串 : 123&gt;&gt;&gt; ' I say!'.strip()'I say!'&gt;&gt;&gt; 它和lower方法一起使用可以很方便的对比输入和存储的值. 3.7 translatetranslate方法和replace方法一样,可以替换字符串中的某些部分,但是translate方法只处理单个字符.它的优势在于可以同时进行多个替换,有时候比replace效率高很多. 在使用translate转换之前,需要一张转换表,因为这个表太大.我们使用string模板里面的maketrans函数就可. 4. 小结 字符串格式 : 求模操作符(%)可以用来将其他值转换为包含转换标志的字符串,例如%s.它还能用来对值进行不同方式的格式化,包括左右对齐,设定字段宽度以及精度值.增加符号(正负号)或者左填充数字0等.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第2章 列表和元素]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC2%E7%AB%A0-%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[数据结构是通过某种方式(例如对元素进行编号) 数据结构,在Python中,最基本的数据结构是序列(sequence).序列中的每个元素分配一个序号-&gt;元素的位置,也称为索引.第一个索引是0,第二个则是1. 注意 :序列中的最后一个元素标记为-1,倒数第二个原始为-2,以此类推. 1. 序列概览列表和元组的主要区别在于 : 列表可以修改,元组则不能.如 : 使用元组作为字典的键,在这种情况下,因为键不能修改,所以不能用列表. 在需要操作一组数值的时候,序列很好用.可以用序列表示数据库中的一个人信息 : 第1个元素是姓名,第2个元素是年龄.根据上述内容编写一个列表(列表的各个元素通过逗号分隔,写在方括号内),如 : 1edward = ['kevin',20] 同时,序列也可以包含其他的序列,因此,构建如下的一个人员信息的列表也是可以的,这个列表就是你的数据库 : 12husband = ['kevin',20]wife =['leona',20] 注意 :Python之中还有一种名为容器(container)的数据结构,容器基本上是包含其他对象的任意对象.序列(例如列表和元组)和映射(例如字典)是两类主要的容器.序列中的每个元素都有自己的编号,而映射中的每个元素则有一个名字(键).既不是序列也不是映射的容器类型,集合(set)就是一个例子. 2. 通用序列操作所有序列类型都可以进行某些特定的操作,这些操作包括 : 索引(indexing) / 分片(slicing) / 加(adding) / 乘(multiplying) 以及检查某个元素是否属于序列的成员(成员资格). 迭代(ineration) : 依次对序列中的每个元素重复执行某些操作. 2.1 索引序列中的所有元素都是有编号的(从0开始递增).这些元素是可以通过编号来访问的. 123456&gt;&gt;&gt; greeting = 'hello'&gt;&gt;&gt; greeting[0]'h'&gt;&gt;&gt; greeting[-1]'o'&gt;&gt;&gt; 注意 :字符串就是一个由字符组成的序列.索引0指向第1个元素. 我们可以通过索引获取元素,所有序列都可以通过这种方式进行索引.使用负数索引时,Python会从右边,也就是最后一个元素开始计数.最后1个元素的位置编号是-1. 还有一种办法是用&#39;hello[1]&#39;,结果为e,效果是一样的. 12345678910111213141516171819202122232425262728293031323334# Print out a date, given year, month, and day as numbersmonths = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']# A list with one ending for each number from 1 to 31endings = ['st', 'nd', 'rd'] + 17 * ['th'] \ + ['st', 'nd', 'rd'] + 7 * ['th'] \ + ['st']year = raw_input('Year: ')month = raw_input('Month (1-12): ')day = raw_input('Day (1-31): ')month_number = int(month)day_number = int(day)# Remember to subtract 1 from month and day to get a correct indexmonth_name = months[month_number-1]ordinal = day + endings[day_number-1]print month_name + ' ' + ordinal + ', ' + year 2.2 分片可以使用分片操作来访问一定范围内的元素,分片通过冒号隔开的两个索引来实现 : 12345&gt;&gt;&gt; tag = '&lt;a href="http://www.python.com"&gt;Python Web site&lt;/a&gt;'&gt;&gt;&gt; tag[9:30]'http://www.python.com'&gt;&gt;&gt; tag[32:-4]'Python Web site' 简而言之,分片操作的实现需要提供两个索引作为边界,第1个索引的元素是包含在分片内的,而第2个则不包含在分片内. 12345678&gt;&gt;&gt; numbers = [1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; numbers[3:6][4, 5, 6]&gt;&gt;&gt; numbers[0:1][1]&gt;&gt;&gt; numbers[7:10][8, 9, 10]&gt;&gt;&gt; 优雅的捷径 : 假设需要访问最后的3个元素,那么可以显示的操作:numbers[7:10],现在,索引10指向的是11个元素,但是这个元素是不存在的,却是在最后的一个元素之后.这种做法是可行的.如果需要从列表的结尾开始计数.12&gt;&gt;&gt; numbers[-3:-1][8, 9] 实际上,只要分片中最左边的索引比它右边的晚出现在序列中,结果就是一个空序列.不过,可以使用一个捷径 : 如果分片所得部分包括序列结尾的元素,只需置空最后一个索引即可!12&gt;&gt;&gt; numbers[-3:][8, 9, 10] 可以复制整个序列,可以将两个索引置空12&gt;&gt;&gt; numbers[:][1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 123456# Split up a URL of the form http://www.something.comurl = raw_input('Please enter the URL: ')domain = url[11:-4]print "Domain name: " + domain 更大的步长 : 123456789101112131415161718&gt;&gt;&gt; numbers = [1,2,3,4,5,6,7,8,9,10]# 分片操作就是按照这个步长逐个便利序列的元素,然后返回开始和结束之间的代码.&gt;&gt;&gt; numbers[0:10:1][1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; numbers[0:10:2][1, 3, 5, 7, 9]# 从索引3到6,取第3个&gt;&gt;&gt; numbers[3:6:3][4]# 将每4个元素的第1个提取出来&gt;&gt;&gt; numbers[::4][1, 5, 9]# 步长可以是负数,此时分片从右到左提取元素 : &gt;&gt;&gt; numbers[8:3:-1][9, 8, 7, 6, 5] 当使用一个负数作为步长时,必须让开始点大于结束点.在没有明确指定开始点和结束点的时候,正负数的使用可能会带来些混迹.在python明确规定 : 对于正数步长,python会从序列的头部开始向右提取元素;直到最后一个元素;而对于负数步长,则是从序列的尾部开始向左提取元素,直到最后一个元素. 2.3 序列相加123456789&gt;&gt;&gt; [1,2,3]+[4,5,6][1, 2, 3, 4, 5, 6]&gt;&gt;&gt; 'hello;+;world!''hello;+;world!'&gt;&gt;&gt; [1,2,3]+'world'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: can only concatenate list (not "str") to list&gt;&gt;&gt; 两种相同的类型的序列才能连接操作. 2.4 乘法12345&gt;&gt;&gt; 'python'*5'pythonpythonpythonpythonpython'&gt;&gt;&gt; [42]*10[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]&gt;&gt;&gt; 如果想要初始化一个长度为10的空值,可以使用None,None是Python的一个内建值. 1234&gt;&gt;&gt; sum = [None]*10&gt;&gt;&gt; sum[None, None, None, None, None, None, None, None, None, None]&gt;&gt;&gt; 2.5 成员资格为了检查一个值是否在序列中,可以使用in运算符,这个运算符检查某个条件是否为真,然后返回相应的值.条件为真True,条件为假返回False. 123456789&gt;&gt;&gt; permissions = 'kevin'&gt;&gt;&gt; 'e'in permissionsTrue&gt;&gt;&gt; users = ['mlh','foo','bar']&gt;&gt;&gt; kevin = raw_input("请输入")请输入f&gt;&gt;&gt; print kevin in usersFalse&gt;&gt;&gt; 12345database = ['kevin','1234']username = raw_input("请输入用户名")pin = raw_input("请输入密码")if(username,pin)in database: print '登录成功!' 2.6 长度,最小值和最大值.len函数返回列表中所包含元素的数量,min函数和max函数则分别返回序列中最大和最小的元素. 12345678910&gt;&gt;&gt; numbers = [100,56,89]&gt;&gt;&gt; len(numbers)3&gt;&gt;&gt; max(numbers)100&gt;&gt;&gt; min(numbers)56&gt;&gt;&gt; max(7,9)9&gt;&gt;&gt; 3. 列表列表是可变的 : 可以改变列表的内容,并且列表有很多有用的,专门的方法. 3.1 list函数12&gt;&gt;&gt; list('hello')['h', 'e', 'l', 'l', 'o'] 3.2 基本的列表操作 改变列表 : 元素赋值1234&gt;&gt;&gt; num = [1,2,3,4,5]&gt;&gt;&gt; num[2]=22&gt;&gt;&gt; num[1, 2, 22, 4, 5] 注意不能为一个位置不存在的元素进行赋值. 删除元素从列表中删除元素用del语句来实现 : 1234&gt;&gt;&gt; names = ["kevin","shy_kevin","yujiewong"]&gt;&gt;&gt; del names[1]&gt;&gt;&gt; names['kevin', 'yujiewong'] 分片赋值 123456&gt;&gt;&gt; name = list('Kevin')&gt;&gt;&gt; name['K', 'e', 'v', 'i', 'n']&gt;&gt;&gt; name[2:]=list('ar')&gt;&gt;&gt; name['K', 'e', 'a', 'r'] 3.3 列表方法方法是一个与某个对象有紧密联系的函数,对象可能是列表,数字,也可能是字符串或者其他的类型的对象.一般来说,方法可以这样进行调用 :对象.方法(参数) 列表提供了几个方法,用于检查或者修改其中的内容. appendappend方法用于在列表末尾追加新的对象 : 1234&gt;&gt;&gt; lst=[1,2,3]&gt;&gt;&gt; lst.append(4)&gt;&gt;&gt; lst[1, 2, 3, 4] countcount方法统计某个元素在列表中出现的次数 : 12345&gt;&gt;&gt; ['what','be','am','is','are'].count('is')1&gt;&gt;&gt; x=[[1,2],1,1,[2,1,[1,2]]]&gt;&gt;&gt; x.count(1)2 extendextend方法可以在列表的末尾一次性追加另一个序列中的多个值.换句话说,可以用新列表扩展原有列表. 12345&gt;&gt;&gt; a=[1,2,3,4,5,6]&gt;&gt;&gt; b = [1,2,3]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6, 1, 2, 3] 它与a+b的区别在于extend方法修改被扩展的序列,而原始的操作则不然,这是因为原始的操作创建了一个包含a和b的副本的新列表,那么连接操作的效率会比extend方法低. indexindex方法用于从列表中找出某个值第一个匹配项的索引位置 :123&gt;&gt;&gt; names = ['kevin','shy_kevin']&gt;&gt;&gt; names.index('kevin')0 要注意的是 : 如果搜索到的字符串不存在,会抛出异常. insertinsert方法用于将对象插入到列表中 : 12&gt;&gt;&gt; numbers=[1,2,3,4,5,6,7]&gt;&gt;&gt; numbers,insert(3,'kevin') 与extend方法一样,insert方法的操作也可以用分片赋值来实现.12345&gt;&gt;&gt; numbers[1, 2, 3, 'kevin', 4, 5, 6, 7]&gt;&gt;&gt; numbers[3:3] = ['four']&gt;&gt;&gt; numbers[1, 2, 3, 'four', 'kevin', 4, 5, 6, 7] poppop方法会移除列表中的一个元素(默认是最后一个),并且返回该元素的值 : 12345678&gt;&gt;&gt; x = [1,2,3]&gt;&gt;&gt; x.pop()3&gt;&gt;&gt; x.pop(0)1&gt;&gt;&gt; pop&gt;&gt;&gt; x[2] 注意pop方法是唯一一个既能修改列表又返回元素值(除了None)的列表方法. removeremove方法用于移除列表中的某个值的第一个匹配项 : 1234&gt;&gt;&gt; x = ['to','hello']&gt;&gt;&gt; x.remove('hello')&gt;&gt;&gt; x['to'] reversereverse方法将列表中的元素反向存放 1234&gt;&gt;&gt; k = [1,2,3]&gt;&gt;&gt; k.reverse()&gt;&gt;&gt; k[3, 2, 1] sortsort方法用于在原位置对列表进行排序.在”原位置排序”意味着改变原来的列表,从而其中的元素能按一定的顺序排列,而不是简单地返回一个已排序的列表副本. 12345&gt;&gt;&gt; k[3, 2, 1]&gt;&gt;&gt; k.sort()&gt;&gt;&gt; k[1, 2, 3] 高级排序可以通过compare(x,y)的形式自定义比较函数,compare(x,y)函数会在xy时返回正数,如果x=y则返回0(根据自定义),定义好该函数后,就可以提供给sort方法作为参数.内建函数cmp提供了比较函数的默认实现方式 : 12345678910&gt;&gt;&gt; cmp(42,32)1&gt;&gt;&gt; cmp(99,100)-1&gt;&gt;&gt; cmp(10,10)0&gt;&gt;&gt; numbers = [1,2,3,4,5,6]&gt;&gt;&gt; numbers.sort(cmp)&gt;&gt;&gt; numbers[1, 2, 3, 4, 5, 6] sort方法有另外两个可选的参数(key和reverse),如果要使用它们,那么就要通过名字来指定(这个叫关键字参数),参数key和参数cmp类型(必须提供一个在排序过程中使用的函数).然而,该函数并不是用来确定对象的大小,而是为每个元素创建一个键,然后所有元素根据键来排序.因此,如果要根据元素的长度进行排序,那么可以使用len作为键函数.1234&gt;&gt;&gt; x=['aa','ab','ac']&gt;&gt;&gt; x.sort(key=len)&gt;&gt;&gt; x['aa', 'ab', 'ac'] 另一个关键字reverse是简单的布尔值,用来指明列表是否要进行反向排序.12345&gt;&gt;&gt; x=[4,671,2,78,21]&gt;&gt;&gt; x.sort(reverse=True)&gt;&gt;&gt; x[671, 78, 21, 4, 2]&gt;&gt;&gt; 4. 元组 : 不可变序列如果你用逗号来分隔开一些值,那么你就会自动创建了元组. 12&gt;&gt;&gt; 1,2,3(1, 2, 3) 如果想要实现一个值得元组,必须加上逗号.如 : 42, 4.1 tuple函数以一个序列作为参数并把它转换为元组. 1234567&gt;&gt;&gt; tuple([1,2,3,4])(1, 2, 3, 4)&gt;&gt;&gt; tuple('abc')('a', 'b', 'c')&gt;&gt;&gt; tuple((1,2,3))(1, 2, 3)&gt;&gt;&gt; 4.2 元组的意义 元组可以在映射(和集合的成员)中当做键使用,而列表则不行. 元组作为很多内建函数和方法的返回值存在,也就是说你必须对元组进行处理.只要不尝试修改元组.那么,”处理”元组在绝大多数情况下就是把它们当做列表来进行操作. 5. 小结 函数 描述 cmp(x,y) 比较两个值 len(seq) 返回序列的长度 list(seq) 把序列转换成列表 max(args) 返回列表或者参数集合中最大值 min(args) 返回序列或者参数集合中的最小值 reversed(seq) 把序列进行反向迭代 sorted(seq) 返回已排序的包含seq所有元素的列表 tuple(seq) 把序列转换成元组]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第1章 快速改造 : 基础知识]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC1%E7%AB%A0-%E5%BF%AB%E9%80%9F%E6%94%B9%E9%80%A0-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[1. 交互式解析器当我们输入下面的指令 : print &quot;Hello,world!&quot;,当按下回车按键后,会得到下面的输出 : Hello,world!. 注意 :Python一行就是一行,不管多少. 2. 算法是什么对于如何做某事的一份详细描述. 3. 数字和表达式1/2 得到的结果为 0 ,因为一个整数被另外一个整数除,计算结果的小数部分被截除了,只剩下整数部分.所以结果为 0 . 实数在 Python 中被称为浮点数(Float),如果参与除法的两个数中有一个数为浮点数,则运算结果为浮点数. 1.0 / 2.0 = 0.5 Python提供了另外一个实现整除的操作符(双斜线).1 // 2 = 0 1.0 // 2.0 == 0.0 1 % 2 = 1这是取余运算符(x%y的结果为x除以y的余数) 幕(乘方)运算符 :123456789&gt;&gt;&gt; 2**38&gt;&gt;&gt; 2**38&gt;&gt;&gt; -3**2-9&gt;&gt;&gt; (-3)**29&gt;&gt;&gt; 注意 : 幕运算符比取反的优先级要高,所以-3**2等同于-(3**2),如果想计算(-3)**2,就需要显式说明. 3.1 长整数普通整数不能大于2147483647(也不能小于-2147483648),如果需要跟大的数,可以使用长整数.长整数的书写方法和普通整数一样,但要在结尾加L. 3.2 十六进制和八进制12345&gt;&gt;&gt; 0xaf175&gt;&gt;&gt; 0108&gt;&gt;&gt; 十六进制和八进制的首位数字都是0. 4. 变量如果希望用名字X代表3,只需要执行下面的语句 :123&gt;&gt;&gt; x=3&gt;&gt;&gt; x*26 这样的操作称为赋值(assignment),数值3被赋给了变量x.另外的一种说法是 : 将变量x绑定到了值(或者对象)3上面.在变量被赋值之后,就可以在表达式中使用变量. 注意 :变量名可以包括字母,数字和下划线(_).变量名不能以数字开头,所以Plan9是合法变量名,而9Plan不是. 5. 语句表达式就是某件事情,而语句是做某件事情.变量就像临时的存储器,它的强大之处在于操作变量的时候并不需要知道它们存储了什么值. 6. 获取用户输入1234&gt;&gt;&gt; input("The meaning of life:")The meaning of life:4242&gt;&gt;&gt; 接着下面的内容 :1234567&gt;&gt;&gt; x = input("x:")x:34&gt;&gt;&gt; y = input("y:")y:42&gt;&gt;&gt; print x*y1428&gt;&gt;&gt; 7. 函数可以用一个函数pow来代替幕运算符(**),来实现.我们通常会把pow等标准函数称为内建函数. 1234&gt;&gt;&gt; 2**38&gt;&gt;&gt; pow(2,3)8 上面的例子我们称之为调用函数,你可以给它提供参数,它会返回值给用户. 12&gt;&gt;&gt; 2 + pow(2,10)1026 还有很多内建函数,比如用abs函数可以得到数的绝对值,round函数则会把浮点数四舍五入为最接近的整数值 :12345&gt;&gt;&gt; abs(-10)10&gt;&gt;&gt; round(6.999)7.0&gt;&gt;&gt; 8. 模板模板可以想象为导入到python以增强其功能扩展.如 :123&gt;&gt;&gt; import math&gt;&gt;&gt; math.floor(32.9)32.0 用import导入模板,然后按照”魔板.函数”的格式使用这个模块的函数. 你确认自己不会导入多个同命函数(从不同模块导入)的情况下,那么可以使用import命令的另外一种方式 :123&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; sqrt(9)3.0 8.1 cmath和复数sqrt函数用于计算一个数的平方根. 123456&gt;&gt;&gt; sqrt(-2)Traceback (most recent call last): File "&lt;pyshell#28&gt;", line 1, in &lt;module&gt; sqrt(-2)ValueError: math domain error 因为负数的平方根是虚数又因为sprt只能处理浮点数,而虚数是完全不同的.因此,它们由另外一个叫做cmath(复数)的模板来处理. 123&gt;&gt;&gt; import cmath&gt;&gt;&gt; cmath.sqrt(-2)1.4142135623730951j 9. 保存并执行程序注释 : #打印圆的周长 : 10. 字符串 单引号字符串和转义引号 拼接字符串 : 建议使用+进行拼接 字符串表示,str和repr所有通过python打印的字符串还是被引号括起来,这是因为python打印值的时候会保持该值在python代码中的状态,而不是你希望用户所看到的状态.如果使用print语句,结果就不一样了 : 1234&gt;&gt;&gt; "Hello,world!"'Hello,world!'&gt;&gt;&gt; print "hello,world!"hello,world! 一种是通过str函数,它会把值转换为合理形式的字符串,另外一种是通过repr函数,它会创建一个字符串,以合法的python表达式的形式来表示值. 12345&gt;&gt;&gt; print repr(100000l)100000L&gt;&gt;&gt; print str(1000l)1000&gt;&gt;&gt; input和raw_input的比较 12345678&gt;&gt;&gt; name = input("what is your name?")what is your name?诸葛亮Traceback (most recent call last): File "&lt;pyshell#36&gt;", line 1, in &lt;module&gt; name = input("what is your name?") File "&lt;string&gt;", line 1 诸葛亮 出现错误的原因是用户必须输入的是合法的python表达式.所以我们必须要以字符串作为输入的名字. 12345&gt;&gt;&gt; name = input("what is your name?")what is your name?"诸葛亮"&gt;&gt;&gt; print "hello,"+namehello,诸葛亮&gt;&gt;&gt; 因此,要求用户带入引号是不好的体验,我们需要raw_input函数,它会把所有的输入当做原始数据(raw data),然后将其放入字符串中. 1234&gt;&gt;&gt; raw_input("hello!")hello!hi'hi'&gt;&gt;&gt; 长字符串,原始字符串和Unicode 长字符串 : 可以使用三个引号代替普通引号&#39;&#39;&#39;My name is 诸葛亮!&#39;&#39;&#39;. 也可以使用&quot;&quot;&quot;爽不爽!&quot;&quot;&quot; 原始字符串 : 它不会把反斜线当作特殊字符.在原字符串中输入的每个字符都会与书写的方式保存一致 : 12&gt;&gt;&gt; print r'c:\nowhere'c:\nowhere 可以看到,原始字符串以r开头.但不能以反斜线结尾! Unicode字符串 : 在python3.0中,所有的字符串都是Unicode字符串. 11. 小结 算法 : 算法是对如何完成一项任务的详尽描述,实际上,在篇写程序的时候,就是要使用计算机能够理解的语言来描述算法.这类对机器友好的描述就叫做程序. 表达式 : 表达式是计算机程序的组成部分,它用于表示值. 变量 : 变量是一个名字,它表示某个值. 语句 : 语句是告诉计算机做某些事情的指令. 函数 : Python中的函数就像数学中的函数,它们可以带有参数.并且具有返回值. 模块 : 模块是一些对python功能的扩展,它可以被导入到python中. 函数 描述 abs(number) 返回数字的绝对值 cmath.sqrt(number) 返回平方根,也可以用于负数 float(object) 将字符串和数字转换为浮点数 help() 提供交互式帮助 input(prompt) 获取用户输入 int(object) 将字符串和数字转换为整数 long(objet) 将字符串和数字转换为长整型数 math.ceil(number) 返回数的上入整数,返回值的类型为浮点数 math.floor(number) 返回数的下舍整数,返回值的类型为浮点数 math.sqrt(number) 返回平方根,不适用于负数 pow(x,y[,z]) 返回x的y次幂(所有结果对z取模) raw_input(prompt) 获取用户输入,结果被看做原始字符串 repr(object) 返回值的字符串表示形式 round(number[,ndigits]) 根据给定的精度对数字进行四舍五入 str(object) 将值转换为字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[1.PS基础及选框工具]]></title>
      <url>%2F2017%2F03%2F28%2F1-PS%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%80%89%E6%A1%86%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[1. 软件界面软件界面恢复到默认的标准状态 : 窗口——工作区——复位基本功能; 所有的控制面板都在窗口菜单中,可以对其进行隐藏和显示 : 按下TAB键可以隐藏或显示工具箱,属性栏,控制面板; / 按下SHIFT+TAB键,可以只进行控制面板的隐藏; 2. 新建 基于互联网设计 (屏幕显示) : 单位：像素,分辨率 : 72 , 颜色模式 : RGB基于印刷设计时 : 单位 : 毫米 MM,分辨率 : 300,颜色模式 : CMYK 3. 工具 矩形选框工具 (椭圆选框) M 按 SHIFT 键可以强制为正方形 (正圆) 按 ALT 键可以保持中心点不变 同时按下 SHIFT+ALT 键,可保持中心不变强制为正方形 (正圆) 前背景色 前景色填充 : ALT+DELETE(删除) 背景色填充 : CTRL+DELETE(删除) 按 D 键 : 恢复到默认的黑白色 按 X 键 : 前背景色的切换 移动工具 功能 : 移动对象 复制 : 按下 ALT 键用移动工具进行拖载 图层 新建图层 : CTRL+ALT+SHIFT+N 图层编组 : CTRL+G 图层复制 : CTRL+J 保存与打开 保存 : CTRL+S 可以把内容存储起来 另存为 : CTRL+SHIFT+S,把文件重新保存一份 默认的格式 : PSD(源文件格式) 打开的方式 : CTRL+O 把文档拖拽至软件中也可以打开 4. 移动选取与移动内容的区别 移动选区 : 绘制选区后,用矩形选框工具制在选区内,会出现白色箭头,可以移动选区. (属性栏中必须选中的新选区) 移动内容 : 绘制选区后,用移动工具指在选区内,会出现黑色箭头,可以移动选取内的内容. 5. 选区的修改 边界 : 会得到有一定宽度的环形区域，会有羽化效果 平滑 : 把直角选区变成圆角选区 扩展 : 均匀的扩大选区 收缩 : 均匀的缩小选区 6. 自由变换 CTRL+T 按下 SHIFT 键,保持比例不变 按下 ALT 键,保持中心不变 调整四个角点可以调整整体比例,调整四个边点可以调整宽度和高度 按下 SHIFT 加工具本身的快捷键,可以切换选中的工具 CTRL+K : 首选项 7. 羽化 SHIFT+F6 羽化 : 让边缘变得柔和,半透明 8. 常用快捷键 取消选区 : CTRL + D 第一步撤销 CTRL+Z / 第二步以上的撤销 CTRL+ALT+Z 默认撤销步数为 20 步. 放大 : CTRL+”+” 缩小 : CTRL+”-” 抓手工具 : 空格]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[1. 记忆单词的方法]]></title>
      <url>%2F2017%2F03%2F28%2F1-%E8%AE%B0%E5%BF%86%E5%8D%95%E8%AF%8D%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1. 如何记忆单词 阅读记忆 词根/词缀/词源/字母学规律 联想 2. 阅读记忆 www.economist.com www.times.com www.gardian.co.uk/ 生词圈出,反复研读句子.勾画词组,了解替代,熟词辟意. 3. 词根词缀 词根词缀记词法 prefix (a.肯定/否定 b.方向) suffix (词性) root (意义) regress v.后退/退步 | gress-&gt;to go 向前 | re-&gt;back 向后 ingress n.进入 | into+go improvise v.即兴创作 | vis-&gt;to see | im/in-&gt;to go 或 not 4. 词源 shelter n,v.避难者,保护 shield n.盾牌,保护 fetter n.束缚 | fet 脚 5. 词源的变化规则 元音之间可以互换 a,e,i,o,u 辅音之间 p\b, t\d, k\g\c\qu, f\v, s\z\x\th 可以互换 disburse v.支付/付款 | pay for reimburse v.报销/偿还 kindle v.点燃 candle | 蜡烛 sunder v.分开,裂开 | thunder 雷声 miscellaneous adj.混杂的,各种各样的 | mix 混杂 | cell 细胞 masquerade n.假面舞会 | mask 面具 | ade 集合 形近字母的互换, u/v/w, m/n 的互换 renovate v.翻新 | nov-&gt;new | re-&gt;再一次 lurk v.潜伏,埋伏 | lower-&gt;下降,降低 (才能潜伏) 字母 g/h 的脱落 (不发音) arduous a.辛苦费力的,困难的 | hard-&gt;困难的 hierarchy n.等级制度,阶级 | hie-&gt;higer | to rule 固定转换, s/t/d, p/b/f/v/ph assent v.同意 | sense consent v.同意 dissent v.不同意 amorphous adj.无形状的,不定型的 | morph-&gt;form 字母组合 (单音节) sp 表示发出,散开,产生 speak | spout 喷出 | spur n.刺激 scr,cr 多数和手上的动作有关 (注意: s 在造词的时候无意义,只起到加强语气的作用) scroll n.卷轴 6. 联想法记单词 单音节词汇 (形近词) fiend n.恶魔,恶人 多音节词汇要拆词 (要拆成认识的词根词缀,拼音等) chrysanthemum n.菊花 | mum 母亲 | the | cry morose a.郁闷的 | rose 没有玫瑰郁闷 precarious a.不安的,不稳固的 | pre car ious avalanche n.雪崩 | lan che 拦车 7. 复习 (短时多次) D1 | L1(3) D2 | L1 L2 D3 | L3 L2 D4 | L1 L3 L4 D5 | L5 L2 L4 D6 | L6 L5 L3 D7 | L1 L4 L6 L7 D8 | L2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第11章 持有对象]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC11%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[如果一个程序只包含固定数量的且其生命期都是已知的对象,那么这是一个非常简单的程序. 其中基本的类型如Set Queue 和Map,这些称为集合类. 1. 泛型和类型安全的容器1234567891011121314151617181920212223242526//: holding/ApplesAndOrangesWithoutGenerics.java// Simple container example (produces compiler warnings).// &#123;ThrowsException&#125;import java.util.*;class Apple &#123; private static long counter; private final long id = counter++; public long id() &#123; return id; &#125;&#125;class Orange &#123;&#125;public class ApplesAndOrangesWithoutGenerics &#123; @SuppressWarnings("unchecked") public static void main(String[] args) &#123; ArrayList apples = new ArrayList(); for(int i = 0; i &lt; 3; i++) apples.add(new Apple()); // Not prevented from adding an Orange to apples: apples.add(new Orange()); for(int i = 0; i &lt; apples.size(); i++) ((Apple)apples.get(i)).id(); // Orange is detected only at run time &#125;&#125; /* (Execute to see output) *///:~ 当在使用Apple的对象时,得到的只是Object引用,必须将其转型为Apple.因此,在调用Apple的id()方法之前,强制执行转型. 通过使用泛型,可以在编译器防止将错误类型的对象放置到容器中. 123456789101112131415161718192021222324//: holding/ApplesAndOrangesWithGenerics.javaimport java.util.*;public class ApplesAndOrangesWithGenerics &#123; public static void main(String[] args) &#123; ArrayList&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); for(int i = 0; i &lt; 3; i++) apples.add(new Apple()); // Compile-time error: // apples.add(new Orange()); for(int i = 0; i &lt; apples.size(); i++) System.out.println(apples.get(i).id()); // Using foreach: for(Apple c : apples) System.out.println(c.id()); &#125;&#125; /* Output:012012*///:~ 2. 基本概念 Java容器类类库的用途是”保存对象”. Collection. 一个独立元素的序列,这些元素都服从一条或多条规则.List必须按照插入的顺序保存元素,而set不能有重复元素.Queue按照排队规则来确定对象产生的顺序. Map.一组成对的”键值对”对象,允许你使用键来查找值.ArrayList允许你使用数字来查找值,从某种意义说,它将数字与对象关联在一起.映射表允许我们使用另一个对象来查找某个对象,它也被称为”关联数组”,因此它将某些对象与另外一些对象关联在一起;或者被称为”字典”,因此你可以使用键对象来查找值对象,就像在字典中使用单词来定义一样. 1List&lt;apple&gt; apples = new ArrayList&lt;Apple&gt;(); ArrayList已经被向上转型为List. 1234567891011121314//: holding/SimpleCollection.javaimport java.util.*;public class SimpleCollection &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; c = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; 10; i++) c.add(i); // Autoboxing for(Integer i : c) System.out.print(i + ", "); &#125;&#125; /* Output:0, 1, 2, 3, 4, 5, 6, 7, 8, 9,*///:~ 只使用了Collection方法,因为任何继承自Collection的类的对象都可以正常工作. add()方法的名称就表明它是要将一个新的元素防止到Collection中.注的是要确保Collection包含指定的元素.这是因为考虑到Set的含义,因为在Set中只有元素不存在的情况下才会添加. 3. 添加一组元素123456789101112131415161718192021//: holding/AddingGroups.java// Adding groups of elements to Collection objects.import java.util.*;public class AddingGroups &#123; public static void main(String[] args) &#123; Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5)); Integer[] moreInts = &#123; 6, 7, 8, 9, 10 &#125;; collection.addAll(Arrays.asList(moreInts)); // Runs significantly faster, but you can't // construct a Collection this way: Collections.addAll(collection, 11, 12, 13, 14, 15); Collections.addAll(collection, moreInts); // Produces a list "backed by" an array: List&lt;Integer&gt; list = Arrays.asList(16, 17, 18, 19, 20); list.set(1, 99); // OK -- modify an element // list.add(21); // Runtime error because the // underlying array cannot be resized. &#125;&#125; ///:~ 4. 容器的打印12345678910111213141516171819202122232425262728293031323334353637383940//: holding/PrintingContainers.java// Containers print themselves automatically.import java.util.*;import static net.mindview.util.Print.*;public class PrintingContainers &#123; static Collection fill(Collection&lt;String&gt; collection) &#123; collection.add("rat"); collection.add("cat"); collection.add("dog"); collection.add("dog"); return collection; &#125; static Map fill(Map&lt;String,String&gt; map) &#123; map.put("rat", "Fuzzy"); map.put("cat", "Rags"); map.put("dog", "Bosco"); map.put("dog", "Spot"); return map; &#125; public static void main(String[] args) &#123; print(fill(new ArrayList&lt;String&gt;())); print(fill(new LinkedList&lt;String&gt;())); print(fill(new HashSet&lt;String&gt;())); print(fill(new TreeSet&lt;String&gt;())); print(fill(new LinkedHashSet&lt;String&gt;())); print(fill(new HashMap&lt;String,String&gt;())); print(fill(new TreeMap&lt;String,String&gt;())); print(fill(new LinkedHashMap&lt;String,String&gt;())); &#125;&#125; /* Output:[rat, cat, dog, dog][rat, cat, dog, dog][dog, cat, rat][cat, dog, rat][rat, cat, dog]&#123;dog=Spot, cat=Rags, rat=Fuzzy&#125;&#123;cat=Rags, dog=Spot, rat=Fuzzy&#125;&#123;rat=Fuzzy, cat=Rags, dog=Spot&#125;*///:~ 目前只需要知道HashMap是最快的存储方式. 5. List 有两种类型的List : 基本的ArrayList,它长于随机访问元素,但是在List的中间插入和移除元素时较慢. LinkedList,它通过代价较低的在List中间进行的插入和删除操作,提供了优化的顺序访问.LinkedList在随机访问方面比较慢,但是它的特性集较ArrayList更大. 6. 迭代器 Java的Iteratir只能单向移动,这个Iterator只能用来 : 使用方法iterator()要求容器返回一个Iterator.Iterator将准备好返回序列的第一个元素. 使用next()获得序列中下一个元素. 使用hasNext()检查序列中是否还有元素. 使用remove()将迭代器新近返回的元素删除. 123456789101112131415161718192021222324252627282930//: holding/SimpleIteration.javaimport typeinfo.pets.*;import java.util.*;public class SimpleIteration &#123; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.arrayList(12); Iterator&lt;Pet&gt; it = pets.iterator(); while(it.hasNext()) &#123; Pet p = it.next(); System.out.print(p.id() + ":" + p + " "); &#125; System.out.println(); // A simpler approach, when possible: for(Pet p : pets) System.out.print(p.id() + ":" + p + " "); System.out.println(); // An Iterator can also remove elements: it = pets.iterator(); for(int i = 0; i &lt; 6; i++) &#123; it.next(); it.remove(); &#125; System.out.println(pets); &#125;&#125; /* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]*///:~ Iterator还可以移除由next()产生的最后一个元素,这意味着在调用remove()之前必须先调用next(). 6.1 ListIteratorListIterator是一个更加强大的Iterator的子类型,它只能用于各种List类的访问.尽管Iterator只能想前移动,但是ListIterator可以双向移动.它还可以产生相对于迭代器在列表中指向的当前位子的前一个和后一个元素的索引,并且可以使用set()方法替换它访问过的最后一个元素.可以通过调用ListIterator()方法产生一个指向List开始处的ListIterator,并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator. 123456789101112131415161718192021222324252627282930//: holding/ListIteration.javaimport typeinfo.pets.*;import java.util.*;public class ListIteration &#123; public static void main(String[] args) &#123; List&lt;Pet&gt; pets = Pets.arrayList(8); ListIterator&lt;Pet&gt; it = pets.listIterator(); while(it.hasNext()) System.out.print(it.next() + ", " + it.nextIndex() + ", " + it.previousIndex() + "; "); System.out.println(); // Backwards: while(it.hasPrevious()) System.out.print(it.previous().id() + " "); System.out.println(); System.out.println(pets); it = pets.listIterator(3); while(it.hasNext()) &#123; it.next(); it.set(Pets.randomPet()); &#125; System.out.println(pets); &#125;&#125; /* Output:Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;7 6 5 4 3 2 1 0[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx][Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]*///:~ 7. LinkedList12345678910111213141516171819202122232425262728293031323334353637383940414243444546//: holding/LinkedListFeatures.javaimport typeinfo.pets.*;import java.util.*;import static net.mindview.util.Print.*;public class LinkedListFeatures &#123; public static void main(String[] args) &#123; LinkedList&lt;Pet&gt; pets = new LinkedList&lt;Pet&gt;(Pets.arrayList(5)); print(pets); // Identical: print("pets.getFirst(): " + pets.getFirst()); print("pets.element(): " + pets.element()); // Only differs in empty-list behavior: print("pets.peek(): " + pets.peek()); // Identical; remove and return the first element: print("pets.remove(): " + pets.remove()); print("pets.removeFirst(): " + pets.removeFirst()); // Only differs in empty-list behavior: print("pets.poll(): " + pets.poll()); print(pets); pets.addFirst(new Rat()); print("After addFirst(): " + pets); pets.offer(Pets.randomPet()); print("After offer(): " + pets); pets.add(Pets.randomPet()); print("After add(): " + pets); pets.addLast(new Hamster()); print("After addLast(): " + pets); print("pets.removeLast(): " + pets.removeLast()); &#125;&#125; /* Output:[Rat, Manx, Cymric, Mutt, Pug]pets.getFirst(): Ratpets.element(): Ratpets.peek(): Ratpets.remove(): Ratpets.removeFirst(): Manxpets.poll(): Cymric[Mutt, Pug]After addFirst(): [Rat, Mutt, Pug]After offer(): [Rat, Mutt, Pug, Cymric]After add(): [Rat, Mutt, Pug, Cymric, Pug]After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]pets.removeLast(): Hamster*///:~ 8. Stack“栈”通常是制”后进先出(LIFO)”的容器,有时栈也被称为叠加栈,因为最后”压入”栈的元素,第一个”弹出”栈.经常用来类比栈的事物是装有弹簧的储放器中的自助餐托盘,最后装入的托盘总是最先拿出使用的. LinkedList具有能够直接实现栈的所有功能的方法,因此可以直接将LinkedList作为栈使用,不过,有时一个真正的”栈”更能把事情说清楚 : 12345678910111213//: net/mindview/util/Stack.java// Making a stack from a LinkedList.package net.mindview.util;import java.util.LinkedList;public class Stack&lt;T&gt; &#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v) &#123; storage.addFirst(v); &#125; public T peek() &#123; return storage.getFirst(); &#125; public T pop() &#123; return storage.removeFirst(); &#125; public boolean empty() &#123; return storage.isEmpty(); &#125; public String toString() &#123; return storage.toString(); &#125;&#125; ///:~ 通过使用泛型,引入了在栈的定义中最简单的可行示例.类名之后的告诉编译器这将是一个参数化类型,而其中的类型参数,即在类被使用时将会被实际类型替换的参数,就是T. SetSet不保存重复的元素,如果你试图将相同的对象的多个实例添加到Set中,那么它就会阻止这种重复现象.Set最常用被使用的是测试归数学,你可以很容易地询问某个对象是否在某个Set中.所以,查找就成为了Set中最重要的操作,因此可以选择一个Hashset的实现,它专门对快速查找进行了优化. Set是基于对象的值来确定归属性的 1234567891011121314//: holding/SetOfInteger.javaimport java.util.*;public class SetOfInteger &#123; public static void main(String[] args) &#123; Random rand = new Random(47); Set&lt;Integer&gt; intset = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; 10000; i++) intset.add(rand.nextInt(30)); System.out.println(intset); &#125;&#125; /* Output:[15, 8, 23, 16, 7, 22, 9, 21, 6, 1, 29, 14, 24, 4, 19, 26, 11, 18, 3, 12, 27, 17, 2, 13, 28, 20, 25, 10, 5, 0]*///:~ 输出的顺序没有任何规则可循,着是因为出于速度,HashSet使用了散列.HashSet所维护的顺序与TreeSet或LinkedHashSet都不同,因为它们的实现具有不同的元素存储方式.TreeSet将元素存储在红-黑树数据结构中,而HashSet使用的是散列函数. 如想对结果排序,可以使用TreeSet来代替HashSet. 1234567891011121314//: holding/SortedSetOfInteger.javaimport java.util.*;public class SortedSetOfInteger &#123; public static void main(String[] args) &#123; Random rand = new Random(47); SortedSet&lt;Integer&gt; intset = new TreeSet&lt;Integer&gt;(); for(int i = 0; i &lt; 10000; i++) intset.add(rand.nextInt(30)); System.out.println(intset); &#125;&#125; /* Output:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]*///:~ 1234567891011121314151617181920212223242526272829303132//: holding/SetOperations.javaimport java.util.*;import static net.mindview.util.Print.*;public class SetOperations &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set1 = new HashSet&lt;String&gt;(); Collections.addAll(set1, "A B C D E F G H I J K L".split(" ")); set1.add("M"); print("H: " + set1.contains("H")); print("N: " + set1.contains("N")); Set&lt;String&gt; set2 = new HashSet&lt;String&gt;(); Collections.addAll(set2, "H I J K L".split(" ")); print("set2 in set1: " + set1.containsAll(set2)); set1.remove("H"); print("set1: " + set1); print("set2 in set1: " + set1.containsAll(set2)); set1.removeAll(set2); print("set2 removed from set1: " + set1); Collections.addAll(set1, "X Y Z".split(" ")); print("'X Y Z' added to set1: " + set1); &#125;&#125; /* Output:H: trueN: falseset2 in set1: trueset1: [D, K, C, B, L, G, I, M, A, F, J, E]set2 in set1: falseset2 removed from set1: [D, C, B, G, M, A, F, E]'X Y Z' added to set1: [Z, D, C, B, G, M, A, F, Y, X, E]*///:~ 10. Map考虑一个程序,它将用来检查Java的Random类的随机性.Random可以将产生理想的数字分部,在本例中,键是由Random产生的数字,而值是该数字出现的次数. 1234567891011121314151617181920//: holding/Statistics.java// Simple demonstration of HashMap.import java.util.*;public class Statistics &#123; public static void main(String[] args) &#123; Random rand = new Random(47); Map&lt;Integer,Integer&gt; m = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt; 10000; i++) &#123; // Produce a number between 0 and 20: int r = rand.nextInt(20); Integer freq = m.get(r); m.put(r, freq == null ? 1 : freq + 1); &#125; System.out.println(m); &#125;&#125; /* Output:&#123;15=497, 4=481, 19=464, 8=468, 11=531, 16=533, 18=478, 3=508, 7=471, 12=521, 17=509, 2=489, 13=506, 9=549, 6=519, 1=502, 14=477, 10=513, 5=503, 0=481&#125;*///:~ 在main()中,自动包装机将随机生成的int转换为HashMap可以使用Integer引用.如果键不在容器中,get()方法则返回null(这表示该数字第一次被找到).否则,get()方法将产生与该键相关联的Integer的值,然后这个值被递增(自动包装机制再次简化了表达式,但是确定发生了对Integer的包装和拆包). 11. Queue队列是一个典型的先进先出(FIFO)的容器.即从容器的一端放入事物,从另一端取出,并请求事物放入容器的顺序与取出的顺序是相同的.队列常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径.队列在并发编程中特别重要. LinkedList提供了方法以支持队列的行为,并且它实现了Queue接口,因此LinkedList可以用作Queue的一种实现.通过将LinkedList向上转型为Queue. 12345678910111213141516171819202122232425//: holding/QueueDemo.java// Upcasting to a Queue from a LinkedList.import java.util.*;public class QueueDemo &#123; public static void printQ(Queue queue) &#123; while(queue.peek() != null) System.out.print(queue.remove() + " "); System.out.println(); &#125; public static void main(String[] args) &#123; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); Random rand = new Random(47); for(int i = 0; i &lt; 10; i++) queue.offer(rand.nextInt(i + 10)); printQ(queue); Queue&lt;Character&gt; qc = new LinkedList&lt;Character&gt;(); for(char c : "Brontosaurus".toCharArray()) qc.offer(c); printQ(qc); &#125;&#125; /* Output:8 1 1 1 5 14 3 1 0 1B r o n t o s a u r u s*///:~ offer()方法是与Queue相关的方法之一,它在允许的的情况下,将一个元素插入到队尾,或者返回false.peek()和element()都将在不移除的情况下返回队头,但是peek()方法在队列为空时返回null,而element()会抛出NoSuchElementException异常.poll()和remove()方法将移除并返回队头,但是poll()在队列为空时返回null,而remove()会抛出NoSuchElementException异常. 自动包装机制会自动将nextInt()方法的int结果转换为queue所需的Integer对象.将char 出转换为qc所需的Character对象.Queue接口窄化了对LinkedList的方法的访问权限,以使得只有适当的方法才可以使用. 11.1 PrionrityQueue先进先出描述了最典型的队列规则.队列规则是指在给定一组队列中的元素的情况下,确定下一个弹出队列的元素的规则.先进先出声明的是下一个运算应该是等待时间最长的元素. 优先级队列声明下一个弹出元素是最需要的元素.如果构建了一个消息系统,某些信息比其他信息更重要,因而应该更快得到处理,那么它们何时得到处理就与它们何时到达无关. 当你在PriorityQueue上调用offer()方法来插入一个对象时,这个对象会在队列中被排序.默认的排序将使用对象在队列中的自然排序.但是你可以通过提供自己的Comparator来修改这个顺序.PriorityQueue可以确保当你调用peek(),poll()和remove()方法时,获取的元素将是队列中优先级别最高的元素. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//: holding/PriorityQueueDemo.javaimport java.util.*;public class PriorityQueueDemo &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;Integer&gt;(); Random rand = new Random(47); for(int i = 0; i &lt; 10; i++) priorityQueue.offer(rand.nextInt(i + 10)); QueueDemo.printQ(priorityQueue); List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20, 18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25); priorityQueue = new PriorityQueue&lt;Integer&gt;(ints); QueueDemo.printQ(priorityQueue); priorityQueue = new PriorityQueue&lt;Integer&gt;( ints.size(), Collections.reverseOrder()); priorityQueue.addAll(ints); QueueDemo.printQ(priorityQueue); String fact = "EDUCATION SHOULD ESCHEW OBFUSCATION"; List&lt;String&gt; strings = Arrays.asList(fact.split("")); PriorityQueue&lt;String&gt; stringPQ = new PriorityQueue&lt;String&gt;(strings); QueueDemo.printQ(stringPQ); stringPQ = new PriorityQueue&lt;String&gt;( strings.size(), Collections.reverseOrder()); stringPQ.addAll(strings); QueueDemo.printQ(stringPQ); Set&lt;Character&gt; charSet = new HashSet&lt;Character&gt;(); for(char c : fact.toCharArray()) charSet.add(c); // Autoboxing PriorityQueue&lt;Character&gt; characterPQ = new PriorityQueue&lt;Character&gt;(charSet); QueueDemo.printQ(characterPQ); &#125;&#125; /* Output:0 1 1 1 1 1 3 5 8 141 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 2525 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1 A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U WW U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A A B C D E F H I L N O S T U W*///:~ 12. Collection和IteratorCollection是描述所有序列容器的共性的根接口,它可能会被认为是一个”附属接口”,即因为要表示其他若干个接口的共性而出现的接口.另外,java.util.AbstractCollection类提供了Collection的默认实现,使得你可以创建AbstractCollection的子类型,而其中没有不必要的代码重复. 123456789101112131415161718192021222324252627282930313233343536373839404142434445//: holding/InterfaceVsIterator.javaimport typeinfo.pets.*;import java.util.*;public class InterfaceVsIterator &#123; public static void display(Iterator&lt;Pet&gt; it) &#123; while(it.hasNext()) &#123; Pet p = it.next(); System.out.print(p.id() + ":" + p + " "); &#125; System.out.println(); &#125; public static void display(Collection&lt;Pet&gt; pets) &#123; for(Pet p : pets) System.out.print(p.id() + ":" + p + " "); System.out.println(); &#125; public static void main(String[] args) &#123; List&lt;Pet&gt; petList = Pets.arrayList(8); Set&lt;Pet&gt; petSet = new HashSet&lt;Pet&gt;(petList); Map&lt;String,Pet&gt; petMap = new LinkedHashMap&lt;String,Pet&gt;(); String[] names = ("Ralph, Eric, Robin, Lacey, " + "Britney, Sam, Spot, Fluffy").split(", "); for(int i = 0; i &lt; names.length; i++) petMap.put(names[i], petList.get(i)); display(petList); display(petSet); display(petList.iterator()); display(petSet.iterator()); System.out.println(petMap); System.out.println(petMap.keySet()); display(petMap.values()); display(petMap.values().iterator()); &#125;&#125; /* Output:0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx4:Pug 6:Pug 3:Mutt 1:Manx 5:Cymric 7:Manx 2:Cymric 0:Rat&#123;Ralph=Rat, Eric=Manx, Robin=Cymric, Lacey=Mutt, Britney=Pug, Sam=Cymric, Spot=Pug, Fluffy=Manx&#125;[Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy]0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx*///:~ Foreach与迭代器 123456789101112131415//: holding/ForEachCollections.java// All collections work with foreach.import java.util.*;public class ForEachCollections &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; cs = new LinkedList&lt;String&gt;(); Collections.addAll(cs, "Take the long way home".split(" ")); for(String s : cs) System.out.print("'" + s + "' "); &#125;&#125; /* Output:'Take' 'the' 'long' 'way' 'home'*///:~ 下面的例子能显示所有操作系统的环境变量: 1234567891011//: holding/EnvironmentVariables.javaimport java.util.*;public class EnvironmentVariables &#123; public static void main(String[] args) &#123; for(Map.Entry entry: System.getenv().entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue()); &#125; &#125;&#125; /* (Execute to see output) *///:~ 13.1 适配器方法惯用法一种习惯用的方法是适配器方法的惯用法.”适配器”部分来自于设计模式,因为你必须提供特定接口以满足foreach语句.当你有一个接口并需要另外一个接口时,编写适配器就可以解决问题.这里,在默认的前向迭代器的基础上,添加产生反向迭代器的能力.而是添加一个能够产生Iterable对象的方法,该对象可以用于foreach语句. 12345678910111213141516171819202122232425262728293031323334353637383940//: holding/AdapterMethodIdiom.java// The "Adapter Method" idiom allows you to use foreach// with additional kinds of Iterables.import java.util.*;class ReversibleArrayList&lt;T&gt; extends ArrayList&lt;T&gt; &#123; public ReversibleArrayList(Collection&lt;T&gt; c) &#123; super(c); &#125; public Iterable&lt;T&gt; reversed() &#123; return new Iterable&lt;T&gt;() &#123; public Iterator&lt;T&gt; iterator() &#123; return new Iterator&lt;T&gt;() &#123; int current = size() - 1; public boolean hasNext() &#123; return current &gt; -1; &#125; public T next() &#123; return get(current--); &#125; public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125;&#125;public class AdapterMethodIdiom &#123; public static void main(String[] args) &#123; ReversibleArrayList&lt;String&gt; ral = new ReversibleArrayList&lt;String&gt;( Arrays.asList("To be or not to be".split(" "))); // Grabs the ordinary iterator via iterator(): for(String s : ral) System.out.print(s + " "); System.out.println(); // Hand it the Iterable of your choice for(String s : ral.reversed()) System.out.print(s + " "); &#125;&#125; /* Output:To be or not to bebe to not or be To*///:~ 如果直接将ral对象置于foreach语句中,将得到默认的前向迭代器.但是如果在该对象上调用reversed()方法,就会产生不同的行为. 总结 Java提供了大量持有对象的方式 : 数组将数字与对象联系起来.它保存类型明确的对象,查询对象时,不需要对结果做类型转换.它可以是多维的,可以保存基本类型的数据.但是,数组一旦生成,其容量就不可改变. Collection保存单一的元素,而Map保存相关联的键值对.有了Java的泛型,就可以指定容器中存放的对象类型,因此不会将错误的类型放入到泛型中.容器不能持有基本类型,但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换. 像数组一样,List也建立数字索引与对象的关联,因此,数组和List都是排好序的容器.List能够自动扩充容量. 如果要进行大量的随机访问,就使用ArrayList,如果要经常从表中插入和删除元素,则需要使用LinkedList. 各种Queue以及栈的行为,由LinkedList提供支持. Map是一种将对象与对象相关联的设计.HaspMap设计用来快速访问,而TreeMap保存”键”始终处于排序状态,所以没有HashMap快.LinkedHashMap保存元素插入的顺序,也是通过散列提供了快速访问的能力. Set不接受重复元素.HashSet提供最快的查询速度,而TreeSet保存元素处于排序的状态.LinkedHashSet以插入顺序保存元素.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第10章 内部类]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC10%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[可以将一个类的定义放在另一个类的定义内部,这就是内部类. 1. 创建内部类1234567891011121314151617181920212223242526272829//: innerclasses/Parcel1.java// Creating inner classes.public class Parcel1 &#123; class Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; Destination(String whereTo) &#123; label = whereTo; &#125; String readLabel() &#123; return label; &#125; &#125; // Using inner classes looks just like // using any other class, within Parcel1: public void ship(String dest) &#123; Contents c = new Contents(); Destination d = new Destination(dest); System.out.println(d.readLabel()); &#125; public static void main(String[] args) &#123; Parcel1 p = new Parcel1(); p.ship("Tasmania"); &#125;&#125; /* Output:Tasmania*///:~ 2. 链接到外部类当生成一个内部类对象时,此对象与制造它的外围对象(enclosing object)之间就有了一种联系,所以它能访问其外围对象的所有成员,而不需要任何特殊条件.此外,内部类还拥有其外围类的所有元素的访问权. 内部类自动拥有对其外围类所有成员的访问权?当某个外围类的对象创建了一个内部类对象时,此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用.然而,在你访问此外围类的成员时,就是用那个引用来选择外围类的成员.幸运的是 : 编译器会帮你处理所有的细节,但你现在可以看到 : 内部类的对象只能在与其外围类的对象相关联的情况下才会被创建.构建内部类对象时,需要一个指向其外围类对象的引用,如果编译器访问不到这个引用就会报错! 3. 使用.this和.new如果需要生成对外部类对象的引用,可以使用外部类的名字后面紧跟圆点和this.这样产生的引用自动地具有正确的类型. 有时你可能想要告知某些其他对象,去创建某个内部类的对象.要实现此目的,你必须用new表达式中提供对其他外部类对象的引用,这就需要使用.new语法. 123456789package itceo.net;public class DotNew &#123; public class Inner&#123;&#125; public static void main(String[] args) &#123; DotNew doNew = new DotNew(); DotNew.Inner inner = doNew.new Inner(); &#125;&#125; 在拥有外部类对象之前是不可能创建内部类对象的,这是因为内部类对象会暗暗连接到创建它的外部类对象上.但是,如果你创建的是嵌套类(静态内部类),那么它就不需要对外部类对象的引用. 4. 内部类向上转型当将内部类向上转型为基类,尤其是转型为一个接口的时候,内部类就有了用武之地.(从实现了某个接口的对象,得到对此接口的引用,与向上转型为这个对象的基类,实质上效果是一样的.) 5. 在方法和作用域的内部类第一个例子展示了在方法的作用域内(而不是在其他类的作用域内)创建一个完整的类.这被称为局部内部类. 12345678910111213141516171819//: innerclasses/Parcel5.java// Nesting a class within a method.public class Parcel5 &#123; public Destination destination(String s) &#123; class PDestination implements Destination &#123; private String label; private PDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; &#125; return new PDestination(s); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); Destination d = p.destination("Tasmania"); &#125;&#125; ///:~ 6. 匿名内部类123456789101112131415//: innerclasses/Parcel7.java// Returning an instance of an anonymous inner class.public class Parcel7 &#123; public Contents contents() &#123; return new Contents() &#123; // Insert a class definition private int i = 11; public int value() &#123; return i; &#125; &#125;; // Semicolon required in this case &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); Contents c = p.contents(); &#125;&#125; ///:~ contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起!这种奇怪的语法指的是 : 创建一个继承自Contents的匿名类的对象.通过 new 表达式返回的引用被自动向上转型为Contents的引用. 1234567891011121314//: innerclasses/Parcel7b.java// Expanded version of Parcel7.javapublic class Parcel7b &#123; class MyContents implements Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; public Contents contents() &#123; return new MyContents(); &#125; public static void main(String[] args) &#123; Parcel7b p = new Parcel7b(); Contents c = p.contents(); &#125;&#125; ///:~ 6.1 再访工厂方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//: innerclasses/Factories.javaimport static net.mindview.util.Print.*;interface Service &#123; void method1(); void method2();&#125;interface ServiceFactory &#123; Service getService();&#125;class Implementation1 implements Service &#123; private Implementation1() &#123;&#125; public void method1() &#123;print("Implementation1 method1");&#125; public void method2() &#123;print("Implementation1 method2");&#125; public static ServiceFactory factory = new ServiceFactory() &#123; public Service getService() &#123; return new Implementation1(); &#125; &#125;;&#125;class Implementation2 implements Service &#123; private Implementation2() &#123;&#125; public void method1() &#123;print("Implementation2 method1");&#125; public void method2() &#123;print("Implementation2 method2");&#125; public static ServiceFactory factory = new ServiceFactory() &#123; public Service getService() &#123; return new Implementation2(); &#125; &#125;;&#125;public class Factories &#123; public static void serviceConsumer(ServiceFactory fact) &#123; Service s = fact.getService(); s.method1(); s.method2(); &#125; public static void main(String[] args) &#123; serviceConsumer(Implementation1.factory); // Implementations are completely interchangeable: serviceConsumer(Implementation2.factory); &#125;&#125; /* Output:Implementation1 method1Implementation1 method2Implementation2 method1Implementation2 method2*///:~ 7. 嵌套类如果不需要内部类对象与外围类对象之间有联系,可以将内部类声明为static.这通常称为嵌套类.我们需要明白 : 普通的内部类对象隐私地保存了一个引用,指向创建它的外围类对象.然而,当内部类是static时,就不是这样了. 要创建嵌套类的对象,并不需要其外围类的对象. 不能从嵌套类的对象中访问非静态的外围类对象. 嵌套类与普通的内部类还有一个区别.普通内部类的字段与方法,只能放在类的外部层次上,所以普通的内部类不能有static数据和static字段,也不能包含嵌套类.但是嵌套类可以包含这些东西 : 12345678910111213141516171819202122232425262728293031323334//: innerclasses/Parcel11.java// Nested classes (static inner classes).public class Parcel11 &#123; private static class ParcelContents implements Contents &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; protected static class ParcelDestination implements Destination &#123; private String label; private ParcelDestination(String whereTo) &#123; label = whereTo; &#125; public String readLabel() &#123; return label; &#125; // Nested classes can contain other static elements: public static void f() &#123;&#125; static int x = 10; static class AnotherLevel &#123; public static void f() &#123;&#125; static int x = 10; &#125; &#125; public static Destination destination(String s) &#123; return new ParcelDestination(s); &#125; public static Contents contents() &#123; return new ParcelContents(); &#125; public static void main(String[] args) &#123; Contents c = contents(); Destination d = destination("Tasmania"); &#125;&#125; ///:~ 7.1 接口内部的类12345678910111213141516//: innerclasses/ClassInInterface.java// &#123;main: ClassInInterface$Test&#125;public interface ClassInInterface &#123; void howdy(); class Test implements ClassInInterface &#123; public void howdy() &#123; System.out.println("Howdy!"); &#125; public static void main(String[] args) &#123; new Test().howdy(); &#125; &#125;&#125; /* Output:Howdy!*///:~ 7.2 从外层嵌套类中访问外部类的成员一个内部类被嵌套多少层并不重要,它能透明地访问所有它所嵌入的外围类的所有成员. 12345678910111213141516171819202122232425//: innerclasses/MultiNestingAccess.java// Nested classes can access all members of all// levels of the classes they are nested within.class MNA &#123; private void f() &#123;&#125; class A &#123; private void g() &#123;&#125; public class B &#123; void h() &#123; g(); f(); &#125; &#125; &#125;&#125;public class MultiNestingAccess &#123; public static void main(String[] args) &#123; MNA mna = new MNA(); MNA.A mnaa = mna.new A(); MNA.A.B mnaab = mnaa.new B(); mnaab.h(); &#125;&#125; ///:~ 可以看到在MNA.A.B中,调用方法g()和f()不需要任何条件(即使它们被定义为private),这个例子同时展示了如何从不同的类里创建多层嵌套的内部类对象的基本语法..new语法能产生正确的作用域,所以不必在调用构造器时限定类名. 8. 为什么需要内部类一般来说,内部类继承自某个类或实现某个接口,内部类的代码操作创建它的外围类的对象.所以可以认为内部类提供了某种进入某外围类的窗口. 每个内部类都能独立地继承自一个(接口的)实现,所以无论外围类是否已经继承了某个(接口的)实现,对于内部类都没有影响. 单一类与内部类的比较 :12345678910111213141516171819202122232425262728//: innerclasses/MultiInterfaces.java// Two ways that a class can implement multiple interfaces.package innerclasses;interface A &#123;&#125;interface B &#123;&#125;class X implements A, B &#123;&#125;class Y implements A &#123; B makeB() &#123; // Anonymous inner class: return new B() &#123;&#125;; &#125;&#125;public class MultiInterfaces &#123; static void takesA(A a) &#123;&#125; static void takesB(B b) &#123;&#125; public static void main(String[] args) &#123; X x = new X(); Y y = new Y(); takesA(x); takesA(y); takesB(x); takesB(y.makeB()); &#125;&#125; ///:~ 12345678910111213141516171819202122//: innerclasses/MultiImplementation.java// With concrete or abstract classes, inner// classes are the only way to produce the effect// of "multiple implementation inheritance."package innerclasses;class D &#123;&#125;abstract class E &#123;&#125;class Z extends D &#123; E makeE() &#123; return new E() &#123;&#125;; &#125;&#125;public class MultiImplementation &#123; static void takesD(D d) &#123;&#125; static void takesE(E e) &#123;&#125; public static void main(String[] args) &#123; Z z = new Z(); takesD(z); takesE(z.makeE()); &#125;&#125; ///:~ 内部类可以有多个实例,每个实例都有自己的状态信息,并且与其外围类对象的信息相互独立. 在单个外围类中,可以让多个内部类以不同的方式实现同一个接口,或继承同一个类. 创建内部类对象的时刻并不依赖于外围类对象的创建. 内部类没有令人迷惑的”is-a”关系;它就是一个独立的实体. 8.1 闭包与回调闭包(closure)是一个可调用的对象,它记录了一些信息,这些信息来自于创建它的作用域.通过这个定义,可以看出内部类是面向对象的闭包,因为它不仅包含外围类对象(创建内部类的作用域)的信息,还自动拥有一个指向对其外围类对象的引用,在此作用域内,内部类有权操作所有的成员,包括private. 8.2 内部类与控制框架设计模式总是将变化的事物与保持不变的事物分离开,在这个模式中,模块方法是保持不变的事物,而可覆盖的方法就是变化的事物. 9. 内部类的继承1234567891011121314151617//: innerclasses/InheritInner.java// Inheriting an inner class.class WithInner &#123; class Inner &#123;&#125;&#125;public class InheritInner extends WithInner.Inner &#123; //! InheritInner() &#123;&#125; // Won't compile InheritInner(WithInner wi) &#123; wi.super(); &#125; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); &#125;&#125; ///:~ InheritInner只继承内部类,而不是外围类.但要生成一个构造器时,默认的构造器并不友好,而且不能只是传递一个指向外围类对象的引用.因此,必须在构造器内使用如下语法 : enclosingClassReference.super(),只有提供必要的引用,然后程序才能编译通过. 10. 内部类可以被覆盖吗1234567891011121314151617181920212223242526272829303132//: innerclasses/BigEgg2.java// Proper inheritance of an inner class.import static net.mindview.util.Print.*;class Egg2 &#123; protected class Yolk &#123; public Yolk() &#123; print("Egg2.Yolk()"); &#125; public void f() &#123; print("Egg2.Yolk.f()");&#125; &#125; private Yolk y = new Yolk(); public Egg2() &#123; print("New Egg2()"); &#125; public void insertYolk(Yolk yy) &#123; y = yy; &#125; public void g() &#123; y.f(); &#125;&#125;public class BigEgg2 extends Egg2 &#123; public class Yolk extends Egg2.Yolk &#123; public Yolk() &#123; print("BigEgg2.Yolk()"); &#125; public void f() &#123; print("BigEgg2.Yolk.f()"); &#125; &#125; public BigEgg2() &#123; insertYolk(new Yolk()); &#125; public static void main(String[] args) &#123; Egg2 e2 = new BigEgg2(); e2.g(); &#125;&#125; /* Output:Egg2.Yolk()New Egg2()Egg2.Yolk()BigEgg2.Yolk()BigEgg2.Yolk.f()*///:~ 11. 局部内部类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//: innerclasses/LocalInnerClass.java// Holds a sequence of Objects.import static net.mindview.util.Print.*;interface Counter &#123; int next();&#125;public class LocalInnerClass &#123; private int count = 0; Counter getCounter(final String name) &#123; // A local inner class: class LocalCounter implements Counter &#123; public LocalCounter() &#123; // Local inner class can have a constructor print("LocalCounter()"); &#125; public int next() &#123; printnb(name); // Access local final return count++; &#125; &#125; return new LocalCounter(); &#125; // The same thing with an anonymous inner class: Counter getCounter2(final String name) &#123; return new Counter() &#123; // Anonymous inner class cannot have a named // constructor, only an instance initializer: &#123; print("Counter()"); &#125; public int next() &#123; printnb(name); // Access local final return count++; &#125; &#125;; &#125; public static void main(String[] args) &#123; LocalInnerClass lic = new LocalInnerClass(); Counter c1 = lic.getCounter("Local inner "), c2 = lic.getCounter2("Anonymous inner "); for(int i = 0; i &lt; 5; i++) print(c1.next()); for(int i = 0; i &lt; 5; i++) print(c2.next()); &#125;&#125; /* Output:LocalCounter()Counter()Local inner 0Local inner 1Local inner 2Local inner 3Local inner 4Anonymous inner 5Anonymous inner 6Anonymous inner 7Anonymous inner 8Anonymous inner 9*///:~ 12. 内部类标识符外围类的名字,加上$,再加上内部类的名字.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第9章 接口]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC9%E7%AB%A0-%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法. 1. 抽象类和抽象方法Java提供了一个叫做”抽象方法”的机制,这种方法是不完整的,仅有声明而没有方法体.下面是抽象方法声明所采用的语法 :1abstract void f(); 包括抽象方法的类叫做抽象类,如果一个类包含了一个或多个抽象方法,该类必须被限定为抽象的. 如果从一个抽象类继承,并想创建该新类的对象,那么就必须为基类中的所有抽象方法提供方法定义,如果不这样做,那么导出类也是抽象类,且编译器将会强制我们用abstract关键字来限定这个类. 既然使某个类成为抽象类并不需要所有的方法都是抽象的,所有仅需将某些方法声明为抽象的即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//: interfaces/music4/Music4.java// Abstract classes and methods.package interfaces.music4;import polymorphism.music.Note;import static net.mindview.util.Print.*;abstract class Instrument &#123; private int i; // Storage allocated for each public abstract void play(Note n); public String what() &#123; return "Instrument"; &#125; public abstract void adjust();&#125;class Wind extends Instrument &#123; public void play(Note n) &#123; print("Wind.play() " + n); &#125; public String what() &#123; return "Wind"; &#125; public void adjust() &#123;&#125;&#125;class Percussion extends Instrument &#123; public void play(Note n) &#123; print("Percussion.play() " + n); &#125; public String what() &#123; return "Percussion"; &#125; public void adjust() &#123;&#125;&#125;class Stringed extends Instrument &#123; public void play(Note n) &#123; print("Stringed.play() " + n); &#125; public String what() &#123; return "Stringed"; &#125; public void adjust() &#123;&#125;&#125;class Brass extends Wind &#123; public void play(Note n) &#123; print("Brass.play() " + n); &#125; public void adjust() &#123; print("Brass.adjust()"); &#125;&#125;class Woodwind extends Wind &#123; public void play(Note n) &#123; print("Woodwind.play() " + n); &#125; public String what() &#123; return "Woodwind"; &#125;&#125;public class Music4 &#123; // Doesn't care about type, so new types // added to the system still work right: static void tune(Instrument i) &#123; // ... i.play(Note.MIDDLE_C); &#125; static void tuneAll(Instrument[] e) &#123; for(Instrument i : e) tune(i); &#125; public static void main(String[] args) &#123; // Upcasting during addition to the array: Instrument[] orchestra = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() &#125;; tuneAll(orchestra); &#125;&#125; /* Output:Wind.play() MIDDLE_CPercussion.play() MIDDLE_CStringed.play() MIDDLE_CBrass.play() MIDDLE_CWoodwind.play() MIDDLE_C*///:~ 创建抽象类和抽象方法非常有用,因为它们可以使类的抽象性明确起来,并告诉用户和编译器计划怎么来使用它. 2. 接口interface关键字使抽象的概念更接近了一步,abstract关键字允许人们在类中创建一个或多个没有任何定义的方法(提供了接口的方法),但是没有提供任何相应的具体实现,这些实现是由此类的继承者创建.interface这个关键字产生一个完全抽象的类,它根本就没有提供任何具体实现.它允许创建者确定方法名,参数列表和返回类型,但是没有任何方法体,接口只提供了形式,而未提供任何具体实现. 一个接口表示 : 所有实现了该特定接口的类看起来都像这样.因此,任何使用某特定接口的代码都知道可以调用该接口的那些方法,而且仅需知道这些.因此,接口被用来建立类与类之间的协议. 但是,interface不仅仅是一个极度抽象的类,因为它允许人们通过创建一个能够被向上转型为多种基类的类型,来实现某种类似多重继承变种的特性. 想要创建一个接口,需要用interface关键字来替代class关键字.就像类一样,可以在interface关键字前面加public关键字,如果不添加public关键字,则它只具有包访问权限,这样它就只能在同一个包内可用.接口也可以包含域,但是这些域隐式地是static和final的. 要让类遵循某个特定接口,需要使用implements关键字,它表示 : interface只是它的外貌,但是现在我要声明它是如何工作的.除此之外,它看起来比较像继承. 可以从Woodwind和Brass类中看到,一旦实现了某些接口,其实现就变成了一个普通的类,就可以按常规方法扩展它. 3. 完全解耦只有一个方法操作的是类而非接口,那么你就只能使用这个类及其子类.如果你想要将这个方法应用于不在此继承结构中的某个类,那么就不行了.接口可以在很大程度上放宽这种限制. 例如,假设有一个Processor类,它由一个name()方法;另外还有一个Process()方法,该方法接受输入参数,修改它的值,然后产生输出.这个类作为基类而被扩展,用来创建各种不同类型的Processor. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//: interfaces/classprocessor/Apply.javapackage interfaces.classprocessor;import java.util.*;import static net.mindview.util.Print.*;class Processor &#123; public String name() &#123; return getClass().getSimpleName(); &#125; Object process(Object input) &#123; return input; &#125;&#125;class Upcase extends Processor &#123; String process(Object input) &#123; // Covariant return return ((String)input).toUpperCase(); &#125;&#125;class Downcase extends Processor &#123; String process(Object input) &#123; return ((String)input).toLowerCase(); &#125;&#125;class Splitter extends Processor &#123; String process(Object input) &#123; // The split() argument divides a String into pieces: return Arrays.toString(((String)input).split(" ")); &#125;&#125;public class Apply &#123; public static void process(Processor p, Object s) &#123; print("Using Processor " + p.name()); print(p.process(s)); &#125; public static String s = "Disagreement with beliefs is by definition incorrect"; public static void main(String[] args) &#123; process(new Upcase(), s); process(new Downcase(), s); process(new Splitter(), s); &#125;&#125; /* Output:Using Processor UpcaseDISAGREEMENT WITH BELIEFS IS BY DEFINITION INCORRECTUsing Processor Downcasedisagreement with beliefs is by definition incorrectUsing Processor Splitter[Disagreement, with, beliefs, is, by, definition, incorrect]*///:~ Apply.process()方法可以接受任何类型的processor,并将其应用到一个Object对象上,然后打印结果.像本例这样,创建一个能够根据所传递参数对象的不同而具有不同行为的方法,被称为策略设计模式.这类方法包含所要执行的算法中固定不变的部分,而”策略”包含变化的部分.策略就是传递进去的参数对象,它包含要执行的代码.这里,Processor对象就是一个策略,在main()中可以看到有三种不同类型的策略应用到了String类型的s对象上. split()方法是Stirng类的一部分,它接受String类型的对象,并以传递进来的参数作为边界,并将String对象分割开,然后返回一个数组String[],它在这里被用来当作创建String数组的快捷方式. 4. Java中的多重继承接口不仅仅只是一种更纯粹形式的抽象类,因为接口是根本没有任何具体实现的,也就是说,没有任何与接口相关的存储;在C++中,组合多个类的接口被称作为多重继承.但在java中,你可以执行相同的行为,但是只有一个类可以有具体实现,因此,通过组合多个接口. 在导出类中,不强制要求必须有一个是抽象的或”具体的”基类.如果要从一个非接口的类继承,那么只能有一个类去继承.其余的基元素都必须是接口.需要将所有的接口名都置于implements关键字之后,用逗号将它们一一分割开.可以继承任意多个接口,并可以向上转型为每个接口.因为每一个接口都是一个独立的类型. 5. 通过继承来扩展接口通过继承,可以很容易地在接口中添加新的方法声明,还可以通过继承在新接口中组合数个接口. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//: interfaces/HorrorShow.java// Extending an interface with inheritance.interface Monster &#123; void menace();&#125;interface DangerousMonster extends Monster &#123; void destroy();&#125;interface Lethal &#123; void kill();&#125;class DragonZilla implements DangerousMonster &#123; public void menace() &#123;&#125; public void destroy() &#123;&#125;&#125;interface Vampire extends DangerousMonster, Lethal &#123; void drinkBlood();&#125;class VeryBadVampire implements Vampire &#123; public void menace() &#123;&#125; public void destroy() &#123;&#125; public void kill() &#123;&#125; public void drinkBlood() &#123;&#125;&#125;public class HorrorShow &#123; static void u(Monster b) &#123; b.menace(); &#125; static void v(DangerousMonster d) &#123; d.menace(); d.destroy(); &#125; static void w(Lethal l) &#123; l.kill(); &#125; public static void main(String[] args) &#123; DangerousMonster barney = new DragonZilla(); u(barney); v(barney); Vampire vlad = new VeryBadVampire(); u(vlad); v(vlad); w(vlad); &#125;&#125; ///:~ DangerousMonster 是Monster的直接扩展,它产生了一个新接口.DragonZilla中实现了这个接口. 在Vampire中使用的语法仅适用于接口继承.一般情况下,只可以将extends用于单一类,但是可以引用多个基类接口.只需要用逗号将接口名一一分割开即可. 5.1 组合接口时的名字冲突在打算组合的不同接口中使用相同的方法名通常会造成代码可读性的混乱,请尽量避免这种情况. 6. 适配接口接口的一种常见用法就是策略设计模式,此时你编写一个执行某些操作的方法,而该方法将接受一个同样是你指定的接口.你主要的声明就是 : 你可以用任何你想要的对象来调用我的方法,只要你的对象遵循我的接口. 7. 接口中的域因为我们放入接口中的任何域都自动是static和final的,所以接口就成为一种很便捷的用来创建常量组的工具. 7.1 初始化接口中的域在接口中定义的域不能为”空final”,但是可以被非常量表达式初始化,如 :123456789101112//: interfaces/RandVals.java// Initializing interface fields with// non-constant initializers.import java.util.*;public interface RandVals &#123; Random RAND = new Random(47); int RANDOM_INT = RAND.nextInt(10); long RANDOM_LONG = RAND.nextLong() * 10; float RANDOM_FLOAT = RAND.nextLong() * 10; double RANDOM_DOUBLE = RAND.nextDouble() * 10;&#125; ///:~ 既然域是static的,它们就可以在类第一次被加载时初始化,这发生在任何域首次被访问时.这就给了一个简单的测试 : 以下的例子证明了接口中的域隐式地是static和final 12345678910111213141516//: interfaces/TestRandVals.javaimport static net.mindview.util.Print.*;public class TestRandVals &#123; public static void main(String[] args) &#123; print(RandVals.RANDOM_INT); print(RandVals.RANDOM_LONG); print(RandVals.RANDOM_FLOAT); print(RandVals.RANDOM_DOUBLE); &#125;&#125; /* Output:8-32032247016559954-8.5939291E185.779976127815049*///:~ 当然,这些域不是接口的一部分,它们的值被存储在该接口的静态存储区域内. 8. 嵌套接口接口可以嵌套在类或其他接口中. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//: interfaces/nesting/NestingInterfaces.javapackage interfaces.nesting;class A &#123; interface B &#123; void f(); &#125; public class BImp implements B &#123; public void f() &#123;&#125; &#125; private class BImp2 implements B &#123; public void f() &#123;&#125; &#125; public interface C &#123; void f(); &#125; class CImp implements C &#123; public void f() &#123;&#125; &#125; private class CImp2 implements C &#123; public void f() &#123;&#125; &#125; private interface D &#123; void f(); &#125; private class DImp implements D &#123; public void f() &#123;&#125; &#125; public class DImp2 implements D &#123; public void f() &#123;&#125; &#125; public D getD() &#123; return new DImp2(); &#125; private D dRef; public void receiveD(D d) &#123; dRef = d; dRef.f(); &#125;&#125;interface E &#123; interface G &#123; void f(); &#125; // Redundant "public": public interface H &#123; void f(); &#125; void g(); // Cannot be private within an interface: //! private interface I &#123;&#125;&#125;public class NestingInterfaces &#123; public class BImp implements A.B &#123; public void f() &#123;&#125; &#125; class CImp implements A.C &#123; public void f() &#123;&#125; &#125; // Cannot implement a private interface except // within that interface's defining class: //! class DImp implements A.D &#123; //! public void f() &#123;&#125; //! &#125; class EImp implements E &#123; public void g() &#123;&#125; &#125; class EGImp implements E.G &#123; public void f() &#123;&#125; &#125; class EImp2 implements E &#123; public void g() &#123;&#125; class EG implements E.G &#123; public void f() &#123;&#125; &#125; &#125; public static void main(String[] args) &#123; A a = new A(); // Can't access A.D: //! A.D ad = a.getD(); // Doesn't return anything but A.D: //! A.DImp2 di2 = a.getD(); // Cannot access a member of the interface: //! a.getD().f(); // Only another A can do anything with getD(): A a2 = new A(); a2.receiveD(a.getD()); &#125;&#125; ///:~ 特别注意的是,当实现某个接口时,并不需要实现嵌套在其内部的任何接口.而且,private接口不能在定义它的类之外被实现. 9. 接口与工厂接口是实现多重继承的途径,而生成遵循某个接口的对象的典型方式就是工厂方法设计模式. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//: interfaces/Factories.javaimport static net.mindview.util.Print.*;interface Service &#123; void method1(); void method2();&#125;interface ServiceFactory &#123; Service getService();&#125;class Implementation1 implements Service &#123; Implementation1() &#123;&#125; // Package access public void method1() &#123;print("Implementation1 method1");&#125; public void method2() &#123;print("Implementation1 method2");&#125;&#125;class Implementation1Factory implements ServiceFactory &#123; public Service getService() &#123; return new Implementation1(); &#125;&#125;class Implementation2 implements Service &#123; Implementation2() &#123;&#125; // Package access public void method1() &#123;print("Implementation2 method1");&#125; public void method2() &#123;print("Implementation2 method2");&#125;&#125;class Implementation2Factory implements ServiceFactory &#123; public Service getService() &#123; return new Implementation2(); &#125;&#125;public class Factories &#123; public static void serviceConsumer(ServiceFactory fact) &#123; Service s = fact.getService(); s.method1(); s.method2(); &#125; public static void main(String[] args) &#123; serviceConsumer(new Implementation1Factory()); // Implementations are completely interchangeable: serviceConsumer(new Implementation2Factory()); &#125;&#125; /* Output:Implementation1 method1Implementation1 method2Implementation2 method1Implementation2 method2*///:~ 如果不用工厂方法,代码就必须在某处指定将要创建的Service的确切类型,以便调用合适的构造器. 10. 总结“确定接口是理想选择,因而应该总是选择接口而不是具体的类”.这其实是一种引诱.当然,对于创建类,几乎在任何时刻,都可以替代为创建一个接口和工厂. 适当的原则应该是优先选择类而不是接口,从类开始,如果接口的必须性变得非常明确,那么就进行重构.接口是一种重要的工具,但是它非常容易被滥用.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第8章 多态]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC8%E7%AB%A0-%E5%A4%9A%E6%80%81%2F</url>
      <content type="text"><![CDATA[在面向对象的程序设计语言中,多态是继数据抽象和继承之后的第三种基本特征. 1. 再论向上转型对象既可以作为它自己本身的类型使用,也可以作为它的基类使用.而这种把对某个对象的引用视为对其基类的引用的做法被称为”向上转型” – 因为在继承书的画法中,基类是放置在上方的. 首先,既然几个例子都要演奏乐符 (Note) ,我们就应该在包中单独创建一个Note类. 1234567//: polymorphism/music/Note.java// Notes to play on musical instruments.package polymorphism.music;public enum Note &#123; MIDDLE_C, C_SHARP, B_FLAT; // Etc.&#125; ///:~ 在这里,Wind是一种Instrument,因此可以从Instrument类继承. 12345678910//: polymorphism/music/Instrument.javapackage polymorphism.music;import static net.mindview.util.Print.*;class Instrument &#123; public void play(Note n) &#123; print("Instrument.play()"); &#125;&#125; ///:~ 1234567891011//: polymorphism/music/Wind.javapackage polymorphism.music;// Wind objects are instruments// because they have the same interface:public class Wind extends Instrument &#123; // Redefine interface method: public void play(Note n) &#123; System.out.println("Wind.play() " + n); &#125;&#125; ///:~ 12345678910111213141516//: polymorphism/music/Music.java// Inheritance &amp; upcasting.package polymorphism.music;public class Music &#123; public static void tune(Instrument i) &#123; // ... i.play(Note.MIDDLE_C); &#125; public static void main(String[] args) &#123; Wind flute = new Wind(); tune(flute); // Upcasting &#125;&#125; /* Output:Wind.play() MIDDLE_C*///:~ Music.tune()方法接受一个Instrument引用,同时也接受任何导出自Instrument 的类.在main()方法中,当一个Wind引用传递到tune()方法时,就会出现这种情况,而不需要任何类型转换.因为Wind到Instrument继承而来,所以Instrument的接口必定存在于Wind中.从Wind向上转型到Instrument可能会缩小接口,但不会比Instrument的全部接口更窄. 1.1 忘记对象类型如果我们不管导出类的存在,编写的代码只是与基类打交道,会不会更好呢? 2. 转机2.1 方法调用绑定将一个方法调用同一个方法主体关联起来被称作绑定.若在程序执行前进行绑定(如果有的话,由编译器和连接程序实现),叫做前期绑定. 后期绑定的含义就是在运行时根据对象的类型进行绑定.后期绑定也叫做动态绑定或运行时绑定.如果一种语言想实现后期绑定,就必须具有某种机制,以便在运行时能判断对象的类型,从而调用恰当的方法.也就说说,编译器一直不知道对象的类型,但是方法调用机制能找到正确的方法体,并加以调用. Java中除了static方法和final方法(private方法属于final方法)之外,其他所有的方法都是后期绑定. 对某个方法声明final,它可以防止其他人覆盖该方法.但更重要的一点是告诉编译器不需要对其进行动态绑定.这样,编译器就可以为final方法调用生成更有效的代码. 2.2 产生正确的行为发送消息给某个对象时,让该对象去判定应该做什么事. 向上转型可以像下面这条语句那么简单: Shape s = new Circle(); 这里,创建了一个Circle对象,并把得到的引用立即赋值给Shape,因为通过继承.Circle就是一种Shape. 假设你调用一个基类方法(它已在导出类中被覆盖) s.draw(); 由于后期绑定(多态),所以调用的是Circle.draw()方法. 1234567//: polymorphism/shape/Shape.javapackage polymorphism.shape;public class Shape &#123; public void draw() &#123;&#125; public void erase() &#123;&#125;&#125; ///:~ 12345678//: polymorphism/shape/Circle.javapackage polymorphism.shape;import static net.mindview.util.Print.*;public class Circle extends Shape &#123; public void draw() &#123; print("Circle.draw()"); &#125; public void erase() &#123; print("Circle.erase()"); &#125;&#125; ///:~ 12345678//: polymorphism/shape/Square.javapackage polymorphism.shape;import static net.mindview.util.Print.*;public class Square extends Shape &#123; public void draw() &#123; print("Square.draw()"); &#125; public void erase() &#123; print("Square.erase()"); &#125;&#125; ///:~ 12345678//: polymorphism/shape/Triangle.javapackage polymorphism.shape;import static net.mindview.util.Print.*;public class Triangle extends Shape &#123; public void draw() &#123; print("Triangle.draw()"); &#125; public void erase() &#123; print("Triangle.erase()"); &#125;&#125; ///:~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445//: polymorphism/shape/RandomShapeGenerator.java// A "factory" that randomly creates shapes.package polymorphism.shape;import java.util.*;public class RandomShapeGenerator &#123; private Random rand = new Random(47); public Shape next() &#123; switch(rand.nextInt(3)) &#123; default: case 0: return new Circle(); case 1: return new Square(); case 2: return new Triangle(); &#125; &#125;&#125; ///:~```java//: polymorphism/Shapes.java// Polymorphism in Java.import polymorphism.shape.*;public class Shapes &#123; private static RandomShapeGenerator gen = new RandomShapeGenerator(); public static void main(String[] args) &#123; Shape[] s = new Shape[9]; // Fill up the array with shapes: for(int i = 0; i &lt; s.length; i++) s[i] = gen.next(); // Make polymorphic method calls: for(Shape shp : s) shp.draw(); &#125;&#125; /* Output:Triangle.draw()Triangle.draw()Square.draw()Triangle.draw()Square.draw()Triangle.draw()Square.draw()Triangle.draw()Circle.draw()*///:~ Shape基类为自它哪里继承而来的所有导出类建立了一个公用接口,所有形状都可以描绘和擦除.导出类通过覆盖这些定义,来为每种特殊类型的几何形状提供单独的行为. RandomShapeGenerator是一种”工厂”,在我们每次调用next()方法时,它可以随机选择Shape对象产生一个引用.向上转型是在return语句里产生的.每个return语句取得一个指向某个Cricle,Square或者Triangle的引用,并将其以Shape类型从next()方法中发送出去.所以无论我们在什么时候调用next()方法,都不会知道具体类型到底是什么,因为我们总是只能获得一个通用的Shape引用. 2.3 可扩展性因为可以从通用的基类继承出新的数据类型,从而新添加一些功能.那些操纵基类接口的方法不需要任何改动就可以应用于新类. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//: polymorphism/music3/Music3.java// An extensible program.package polymorphism.music3;import polymorphism.music.Note;import static net.mindview.util.Print.*;class Instrument &#123; void play(Note n) &#123; print("Instrument.play() " + n); &#125; String what() &#123; return "Instrument"; &#125; void adjust() &#123; print("Adjusting Instrument"); &#125;&#125;class Wind extends Instrument &#123; void play(Note n) &#123; print("Wind.play() " + n); &#125; String what() &#123; return "Wind"; &#125; void adjust() &#123; print("Adjusting Wind"); &#125;&#125;class Percussion extends Instrument &#123; void play(Note n) &#123; print("Percussion.play() " + n); &#125; String what() &#123; return "Percussion"; &#125; void adjust() &#123; print("Adjusting Percussion"); &#125;&#125;class Stringed extends Instrument &#123; void play(Note n) &#123; print("Stringed.play() " + n); &#125; String what() &#123; return "Stringed"; &#125; void adjust() &#123; print("Adjusting Stringed"); &#125;&#125;class Brass extends Wind &#123; void play(Note n) &#123; print("Brass.play() " + n); &#125; void adjust() &#123; print("Adjusting Brass"); &#125;&#125;class Woodwind extends Wind &#123; void play(Note n) &#123; print("Woodwind.play() " + n); &#125; String what() &#123; return "Woodwind"; &#125;&#125;public class Music3 &#123; // Doesn't care about type, so new types // added to the system still work right: public static void tune(Instrument i) &#123; // ... i.play(Note.MIDDLE_C); &#125; public static void tuneAll(Instrument[] e) &#123; for(Instrument i : e) tune(i); &#125; public static void main(String[] args) &#123; // Upcasting during addition to the array: Instrument[] orchestra = &#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new Woodwind() &#125;; tuneAll(orchestra); &#125;&#125; /* Output:Wind.play() MIDDLE_CPercussion.play() MIDDLE_CStringed.play() MIDDLE_CBrass.play() MIDDLE_CWoodwind.play() MIDDLE_C*///:~ 新添加的方法what()返回一个带有类型描述的string引用;另一个新添加的方法adjust()则提供每种乐其的调用方法. 在main()中,当我们将某种引用置入orchestra 数组中,就会自动向上转型到Instrument. 多态是一项让程序员”将改变的事物与未知的事物分离开来”的重要技术. 2.4 缺陷 : “覆盖”私有方法123456789101112131415161718//: polymorphism/PrivateOverride.java// Trying to override a private method.package polymorphism;import static net.mindview.util.Print.*;public class PrivateOverride &#123; private void f() &#123; print("private f()"); &#125; public static void main(String[] args) &#123; PrivateOverride po = new Derived(); po.f(); &#125;&#125;class Derived extends PrivateOverride &#123; public void f() &#123; print("public f()"); &#125;&#125; /* Output:private f()*///:~ 我们所期待的是输出public f(),但由于private方法被自动认为是final方法,而且对导出类是屏蔽的.因此,在这种情况下,Derived类中的f()方法就是一个全新的方法;既然基类的f()方法在子类中不可见,因此也不能被重载. 确切地说,在导出类中,对于基类的private方法,最好采用不同的名字. 2.5 缺陷 : 域与静态方法如果你直接访问某个域,这个访问就将会在编译器进行解析. 123456789101112131415161718192021222324252627282930//: polymorphism/FieldAccess.java// Direct field access is determined at compile time.class Super &#123; public int field = 0; public int getField() &#123; return field; &#125;&#125;class Sub extends Super &#123; public int field = 1; public int getField() &#123; return field; &#125; public int getSuperField() &#123; return super.field; &#125;&#125;public class FieldAccess &#123; public static void main(String[] args) &#123; Super sup = new Sub(); // Upcast System.out.println("sup.field = " + sup.field + ", sup.getField() = " + sup.getField()); Sub sub = new Sub(); System.out.println("sub.field = " + sub.field + ", sub.getField() = " + sub.getField() + ", sub.getSuperField() = " + sub.getSuperField()); &#125;&#125; /* Output:sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0*///:~ 当Sub对象转型为Super引用时,任何域访问都将由编译器解析,因此不是多态.在本例中,为Super.field和Sub.field分配了不同的存储空间.这样,Sub实际上包含两个称为field的域:它自己的和它从Super处得到的.然而,在引用Sub中的field时所产生的默认域并非Super版本的field域.因此,为了得到Super.field,必须显式地指明super.field. 如果某个方法是静态的,它的行为就不具有多态性,静态方法是与类,而并非与单个的对象相关联. 3. 构造器和多态构造器并不具有多态性(它们实际上是static方法,只不过static声明是隐式的). 3.1 构造器的调用顺序基类的构造器总是在导出类的构造过程中被调用,而且按照继承层次逐渐向上链接,已使每个基类的构造器都能得到调用.因为构造器具有一项特殊的任务:检查对象是否被正确地构造.导出类只能访问它自己的成员,不能访问基类中的成员(基类的成员通常是private类型).只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化.因此,必须令所有构造器都得到调用.这正是编译器为什么要强制每个导出类部分都必须调用构造器的原因.在导出类的构造器主体中,如果没有明确指定调用某个基类构造器,它就会默默地调用默认构造器.如果没有明确构造器,编译器就会报错! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//: polymorphism/Sandwich.java// Order of constructor calls.package polymorphism;import static net.mindview.util.Print.*;class Meal &#123; Meal() &#123; print("Meal()"); &#125;&#125;class Bread &#123; Bread() &#123; print("Bread()"); &#125;&#125;class Cheese &#123; Cheese() &#123; print("Cheese()"); &#125;&#125;class Lettuce &#123; Lettuce() &#123; print("Lettuce()"); &#125;&#125;class Lunch extends Meal &#123; Lunch() &#123; print("Lunch()"); &#125;&#125;class PortableLunch extends Lunch &#123; PortableLunch() &#123; print("PortableLunch()");&#125;&#125;public class Sandwich extends PortableLunch &#123; private Bread b = new Bread(); private Cheese c = new Cheese(); private Lettuce l = new Lettuce(); public Sandwich() &#123; print("Sandwich()"); &#125; public static void main(String[] args) &#123; new Sandwich(); &#125;&#125; /* Output:Meal()Lunch()PortableLunch()Bread()Cheese()Lettuce()Sandwich()*///:~ 用其他类创建了一个复杂的类,并且每个类都有一个声明它自己的构造器,其中最重要的类时Sandwich,它反映了三层继承(若将自Object的隐含继承地也算在内,就是四层)以及三个成员对象,当在main()里创建一个Sandwich对象后,就可以看到输出的结果. 调用基类构造器.这个步骤还不断地反复递归下去,首先是构造这种层次结构的根,然后是下一层导出类,等等,直到最底层的导出类. 按声明顺序调用成员的初始化方法. 调用导出类构造器的主体. 3.2 继承和清理通过组合和继承方法来创建新类时,永远不必担心对象的清理问题.子对象通过都会留给垃圾回收器进行处理.如果确实遇到清理的问题,那么必须用心为新类创建dispose()方法.并且由于继承的缘故,如果我们有其他作为垃圾回收器一部分的特殊清理功能,就必须在导出类中覆盖dispose()方法.当覆盖被继承的dispose()方法适,务必记住调用基类版本dispose()方法;否则,基类的清理动作就不会发生. 3.3 构造器内部的多态方法的行为1234567891011121314151617181920212223242526272829303132333435//: polymorphism/PolyConstructors.java// Constructors and polymorphism// don't produce what you might expect.import static net.mindview.util.Print.*;class Glyph &#123; void draw() &#123; print("Glyph.draw()"); &#125; Glyph() &#123; print("Glyph() before draw()"); draw(); print("Glyph() after draw()"); &#125;&#125;class RoundGlyph extends Glyph &#123; private int radius = 1; RoundGlyph(int r) &#123; radius = r; print("RoundGlyph.RoundGlyph(), radius = " + radius); &#125; void draw() &#123; print("RoundGlyph.draw(), radius = " + radius); &#125;&#125;public class PolyConstructors &#123; public static void main(String[] args) &#123; new RoundGlyph(5); &#125;&#125; /* Output:Glyph() before draw()RoundGlyph.draw(), radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(), radius = 5*///:~ 在其他任何事物发生之前,将分配给对象的存储空间初始化成二进制的零. 如前所述那有调用基类构造器.此时,调用被覆盖后的draw()方法(要在调用RoundGlyph构造器之前调用),由于步骤1的缘故,我们此时会发现radius的值为0. 按照声明的顺序调用成员的初始化方法. 调用导出类的构造器主体. 因此,在编写构造器时有一条有效的准则:用尽可能简单的方法使对象进入正常的状态,如果也可以的情况,避免调用其它方法. 4. 协变返回类型它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型: 5. 用继承进行设计用继承表达行为间的差异,并用子弹表达状态上的变化. 5.1 纯继承与扩展 这种被称作为纯粹的”is-a”关系,因为一个类的接口已经确定了它应该是什么,继承可以确保所有的导出类具有基类的接口,且绝对不会少. 5.2 向下转型与运行时类型识别由于向上转型(在继承层中向上移动)会丢失具体的类型信息.所以,我们通过向下转型(也就是在继承层次中向下移动),然而,我们知道向上转型是安全的,因为基类不会具有大于导出类的接口.因此,我们通过基类接口发送的信息保证都能被接受.但是对于向下转型,例如:我们无法知道一个”几何形状”它确实是一个”圆”还是”别的三角形”. 在java中,所有的转型都会被检查,以便确保它的确是我们希望的那种类型.如果不是.则返回ClassCastException(类转型异常) 6. 总结多态意味着”不同的形式”,在面向对象的程序设计中,我们持有从基类继承而来的相同接口,以及使用该接口的不同形式:不同版本的动态绑定方法.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第7章 复用类]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC7%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[复用代码是Java众多因人注目的功能之一.但要想成为极具革命性的语言,仅仅能够复制代码并对之加以改变是不够的.它还必须能够做更多的事情. 1. 组合语法假设你需要某个对象,它要具有多个String对象/几个基本类型数据,以及另一个类的对象.对于非基本类型的对象,必须将其引用置于新的类中,但可以直接定义基本类型数据: 1234567891011121314151617181920212223242526272829303132333435//: reusing/SprinklerSystem.java// Composition for code reuse.class WaterSource &#123; private String s; WaterSource() &#123; System.out.println("WaterSource()"); s = "Constructed"; &#125; public String toString() &#123; return s; &#125;&#125;public class SprinklerSystem &#123; private String valve1, valve2, valve3, valve4; private WaterSource source = new WaterSource(); private int i; private float f; public String toString() &#123; return "valve1 = " + valve1 + " " + "valve2 = " + valve2 + " " + "valve3 = " + valve3 + " " + "valve4 = " + valve4 + "\n" + "i = " + i + " " + "f = " + f + " " + "source = " + source; &#125; public static void main(String[] args) &#123; SprinklerSystem sprinklers = new SprinklerSystem(); System.out.println(sprinklers); &#125;&#125; /* Output:WaterSource()valve1 = null valve2 = null valve3 = null valve4 = nulli = 0 f = 0.0 source = Constructed*///:~ toString():每一个非基本类型的对象都有一个toString()方法,而且当编译器需要一个String而你却只有一个对象时,该方法便会被调用.所以在SprinklerSystem.toString()的表达式中:&quot;source = &quot; + source; 编译器会得知你将要一个String对象同WaterSource相加.由于只能将一个String对象和另一个String对象相加,因此编译器会告诉你:我将调用toString(),把source转换为一个String!所以,每当想要所创建对象的类具备这样的行为时,仅需要编写一个toString()方法即可. 编译器并不是简单地为每一个引用都创建默认对象.如果想初始化这些引用,可以在代码中的下列位置进行: 在定义对象的地方.这意味着它们总是能够在构造器被调用之前被初始化. 在类的构造器中. 就在正要使用这些对象之前,这种方式称为惰性初始化.在生成对象不值得及不必每次都生成对象的情况下. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//: reusing/Bath.java// Constructor initialization with composition.import static net.mindview.util.Print.*;class Soap &#123; private String s; Soap() &#123; print("Soap()"); s = "Constructed"; &#125; public String toString() &#123; return s; &#125;&#125;public class Bath &#123; private String // Initializing at point of definition: s1 = "Happy", s2 = "Happy", s3, s4; private Soap castille; private int i; private float toy; public Bath() &#123; print("Inside Bath()"); s3 = "Joy"; toy = 3.14f; castille = new Soap(); &#125; // Instance initialization: &#123; i = 47; &#125; public String toString() &#123; if(s4 == null) // Delayed initialization: s4 = "Joy"; return "s1 = " + s1 + "\n" + "s2 = " + s2 + "\n" + "s3 = " + s3 + "\n" + "s4 = " + s4 + "\n" + "i = " + i + "\n" + "toy = " + toy + "\n" + "castille = " + castille; &#125; public static void main(String[] args) &#123; Bath b = new Bath(); print(b); &#125;&#125; /* Output:Inside Bath()Soap()s1 = Happys2 = Happys3 = Joys4 = Joyi = 47toy = 3.14castille = Constructed*///:~ 2. 继承语法当创建一个类时,总是在继承,因此,除非已明确指出要从其它类中继承,否则就是在隐式地从Java的标准根类Object进行继承. 在继承的过程中,需要声明”新类与旧类相似”.需要用extends实现. 123456789101112131415161718192021222324252627282930313233343536373839404142//: reusing/Detergent.java// Inheritance syntax &amp; properties.import static net.mindview.util.Print.*;class Cleanser &#123; private String s = "Cleanser"; public void append(String a) &#123; s += a; &#125; public void dilute() &#123; append(" dilute()"); &#125; public void apply() &#123; append(" apply()"); &#125; public void scrub() &#123; append(" scrub()"); &#125; public String toString() &#123; return s; &#125; public static void main(String[] args) &#123; Cleanser x = new Cleanser(); x.dilute(); x.apply(); x.scrub(); print(x); &#125;&#125;public class Detergent extends Cleanser &#123; // Change a method: public void scrub() &#123; append(" Detergent.scrub()"); super.scrub(); // Call base-class version &#125; // Add methods to the interface: public void foam() &#123; append(" foam()"); &#125; // Test the new class: public static void main(String[] args) &#123; Detergent x = new Detergent(); x.dilute(); x.apply(); x.scrub(); x.foam(); print(x); print("Testing base class:"); Cleanser.main(args); &#125;&#125; /* Output:Cleanser dilute() apply() Detergent.scrub() scrub() foam()Testing base class:Cleanser dilute() apply() scrub()*///:~ Java中用super关键字表示超类的意思,当前类就是从超类继承来的.为此,表达式super.scrub()将调用基类版本的scrub()方法. 2.1 初始化基类12345678910111213141516171819202122//: reusing/Cartoon.java// Constructor calls during inheritance.import static net.mindview.util.Print.*;class Art &#123; Art() &#123; print("Art constructor"); &#125;&#125;class Drawing extends Art &#123; Drawing() &#123; print("Drawing constructor"); &#125;&#125;public class Cartoon extends Drawing &#123; public Cartoon() &#123; print("Cartoon constructor"); &#125; public static void main(String[] args) &#123; Cartoon x = new Cartoon(); &#125;&#125; /* Output:Art constructorDrawing constructorCartoon constructor*///:~ 在构建过程是从基类”向外”扩散的,所以基类在导出类构造器可以访问它之前,就已经完成了初始化.即使你不为Catroon()创建构造器,编译器也会为你合成一个默认构造器,该构造器将调用基类的构造器. 2.2 带参数的构造器如果没有默认的基类构造器,或者想调用一个带参数的基类构造器,就必须要用关键字super显式地编写调用基类构造器的语句,并且配以适当的参数列表. 123456789101112131415161718192021222324252627282930//: reusing/Chess.java// Inheritance, constructors and arguments.import static net.mindview.util.Print.*;class Game &#123; Game(int i) &#123; print("Game constructor"); &#125;&#125;class BoardGame extends Game &#123; BoardGame(int i) &#123; super(i); print("BoardGame constructor"); &#125;&#125;public class Chess extends BoardGame &#123; Chess() &#123; super(11); print("Chess constructor"); &#125; public static void main(String[] args) &#123; Chess x = new Chess(); &#125;&#125; /* Output:Game constructorBoardGame constructorChess constructor*///:~ 如果不在BoardGame()中调用基类构造器,编译器会无法找到符合Game()形式构造器.而且,调用基类构造器必须是你在导出类构造器中要做的第一件事.Implicit super constructor BoardGame() is undefined. Must explicitly invoke another constructor 3. 代理因为我们将一个成员对象置于所有构造的类中(就像组合),但与此同时我们在新类中暴露了该成员对象的所有方法(就像继承).例如,太空船需要一个控制模块: 1234567891011//: reusing/SpaceShipControls.javapublic class SpaceShipControls &#123; void up(int velocity) &#123;&#125; void down(int velocity) &#123;&#125; void left(int velocity) &#123;&#125; void right(int velocity) &#123;&#125; void forward(int velocity) &#123;&#125; void back(int velocity) &#123;&#125; void turboBoost() &#123;&#125;&#125; ///:~ 构造太空船的一种方式是使用继承:1234567891011//: reusing/SpaceShip.javapublic class SpaceShip extends SpaceShipControls &#123; private String name; public SpaceShip(String name) &#123; this.name = name; &#125; public String toString() &#123; return name; &#125; public static void main(String[] args) &#123; SpaceShip protector = new SpaceShip("NSEA Protector"); protector.forward(100); &#125;&#125; ///:~ 然而,SpaceShip并非真正的SpaceShipControls类型,即便你可以”告诉”SpaceShip向前运动forward().更精确地讲,Spaceship包含SpaceShipControls,与此同时,SpaceShipControls的所有方法在SpaceShip中都暴露了出来.代理解决了此难题: 12345678910111213141516171819202122232425262728293031323334353637//: reusing/SpaceShipDelegation.javapublic class SpaceShipDelegation &#123; private String name; private SpaceShipControls controls = new SpaceShipControls(); public SpaceShipDelegation(String name) &#123; this.name = name; &#125; // Delegated methods: public void back(int velocity) &#123; controls.back(velocity); &#125; public void down(int velocity) &#123; controls.down(velocity); &#125; public void forward(int velocity) &#123; controls.forward(velocity); &#125; public void left(int velocity) &#123; controls.left(velocity); &#125; public void right(int velocity) &#123; controls.right(velocity); &#125; public void turboBoost() &#123; controls.turboBoost(); &#125; public void up(int velocity) &#123; controls.up(velocity); &#125; public static void main(String[] args) &#123; SpaceShipDelegation protector = new SpaceShipDelegation("NSEA Protector"); protector.forward(100); &#125;&#125; ///:~ 我们使用代理时可以拥有更多的控制力,因为我们可以选择只提供在成员对象中的方法的某个子集. 4. 结合使用组合和继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//: reusing/PlaceSetting.java// Combining composition &amp; inheritance.import static net.mindview.util.Print.*;class Plate &#123; Plate(int i) &#123; print("Plate constructor"); &#125;&#125;class DinnerPlate extends Plate &#123; DinnerPlate(int i) &#123; super(i); print("DinnerPlate constructor"); &#125;&#125;class Utensil &#123; Utensil(int i) &#123; print("Utensil constructor"); &#125;&#125;class Spoon extends Utensil &#123; Spoon(int i) &#123; super(i); print("Spoon constructor"); &#125;&#125;class Fork extends Utensil &#123; Fork(int i) &#123; super(i); print("Fork constructor"); &#125;&#125;class Knife extends Utensil &#123; Knife(int i) &#123; super(i); print("Knife constructor"); &#125;&#125;// A cultural way of doing something:class Custom &#123; Custom(int i) &#123; print("Custom constructor"); &#125;&#125;public class PlaceSetting extends Custom &#123; private Spoon sp; private Fork frk; private Knife kn; private DinnerPlate pl; public PlaceSetting(int i) &#123; super(i + 1); sp = new Spoon(i + 2); frk = new Fork(i + 3); kn = new Knife(i + 4); pl = new DinnerPlate(i + 5); print("PlaceSetting constructor"); &#125; public static void main(String[] args) &#123; PlaceSetting x = new PlaceSetting(9); &#125;&#125; /* Output:Custom constructorUtensil constructorSpoon constructorUtensil constructorFork constructorUtensil constructorKnife constructorPlate constructorDinnerPlate constructorPlaceSetting constructor*///:~ 4.1 确保正确清理如果你想要某个类清理一些东西,就必须显式地编写一个特殊方法来做这件事,并要确认客户程序员知晓他们必须要调用这一方法. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//: reusing/CADSystem.java// Ensuring proper cleanup.package reusing;import static net.mindview.util.Print.*;class Shape &#123; Shape(int i) &#123; print("Shape constructor"); &#125; void dispose() &#123; print("Shape dispose"); &#125;&#125;class Circle extends Shape &#123; Circle(int i) &#123; super(i); print("Drawing Circle"); &#125; void dispose() &#123; print("Erasing Circle"); super.dispose(); &#125;&#125;class Triangle extends Shape &#123; Triangle(int i) &#123; super(i); print("Drawing Triangle"); &#125; void dispose() &#123; print("Erasing Triangle"); super.dispose(); &#125;&#125;class Line extends Shape &#123; private int start, end; Line(int start, int end) &#123; super(start); this.start = start; this.end = end; print("Drawing Line: " + start + ", " + end); &#125; void dispose() &#123; print("Erasing Line: " + start + ", " + end); super.dispose(); &#125;&#125;public class CADSystem extends Shape &#123; private Circle c; private Triangle t; private Line[] lines = new Line[3]; public CADSystem(int i) &#123; super(i + 1); for(int j = 0; j &lt; lines.length; j++) lines[j] = new Line(j, j*j); c = new Circle(1); t = new Triangle(1); print("Combined constructor"); &#125; public void dispose() &#123; print("CADSystem.dispose()"); // The order of cleanup is the reverse // of the order of initialization: t.dispose(); c.dispose(); for(int i = lines.length - 1; i &gt;= 0; i--) lines[i].dispose(); super.dispose(); &#125; public static void main(String[] args) &#123; CADSystem x = new CADSystem(47); try &#123; // Code and exception handling... &#125; finally &#123; x.dispose(); &#125; &#125;&#125; /* Output:Shape constructorShape constructorDrawing Line: 0, 0Shape constructorDrawing Line: 1, 1Shape constructorDrawing Line: 2, 4Shape constructorDrawing CircleShape constructorDrawing TriangleCombined constructorCADSystem.dispose()Erasing TriangleShape disposeErasing CircleShape disposeErasing Line: 2, 4Shape disposeErasing Line: 1, 1Shape disposeErasing Line: 0, 0Shape disposeShape dispose*///:~ 关键字try表示,下面的块是保护区,其中一项特殊处理就是无论try块是怎样退出的,保护区后面的finally子句中的代码总是要被执行! 4.2 名称屏蔽 1234567891011121314151617181920212223242526272829303132333435363738//: reusing/Hide.java// Overloading a base-class method name in a derived// class does not hide the base-class versions.import static net.mindview.util.Print.*;class Homer &#123; char doh(char c) &#123; print("doh(char)"); return 'd'; &#125; float doh(float f) &#123; print("doh(float)"); return 1.0f; &#125;&#125;class Milhouse &#123;&#125;class Bart extends Homer &#123; void doh(Milhouse m) &#123; print("doh(Milhouse)"); &#125;&#125;public class Hide &#123; public static void main(String[] args) &#123; Bart b = new Bart(); b.doh(1); b.doh('x'); b.doh(1.0f); b.doh(new Milhouse()); &#125;&#125; /* Output:doh(float)doh(char)doh(float)doh(Milhouse)*///:~ Java SE5新增加了@Override注解,当想要覆盖某个方法适,可以选择添加这个注解,在你不留心重载并非覆写了该方法时,编辑器会生成一条错误信息. 5. 在组合和继承之间选择组合技术通常用于想在新类中使用现有类的功能而非它的接口这种形式.在继承的时候,使用某个现有类,并开发一个它的特殊版本 6. protected 关键字在实际项目中,经常会想要将某些事物尽可能对这个世界隐藏起来,但仍然允许导出类的成员访问它们. 关键字protected指明白”就类用户而言,这是private的,但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说,它却是可以访问的.”(protected提供了包内访问权限) 123456789101112131415161718192021222324252627282930313233343536//: reusing/Orc.java// The protected keyword.import static net.mindview.util.Print.*;class Villain &#123; private String name; protected void set(String nm) &#123; name = nm; &#125; public Villain(String name) &#123; this.name = name; &#125; public String toString() &#123; return "I'm a Villain and my name is " + name; &#125;&#125;public class Orc extends Villain &#123; private int orcNumber; public Orc(String name, int orcNumber) &#123; super(name); this.orcNumber = orcNumber; &#125; public void change(String name, int orcNumber) &#123; set(name); // Available because it's protected this.orcNumber = orcNumber; &#125; public String toString() &#123; return "Orc " + orcNumber + ": " + super.toString(); &#125; public static void main(String[] args) &#123; Orc orc = new Orc("Limburger", 12); print(orc); orc.change("Bob", 19); print(orc); &#125;&#125; /* Output:Orc 12: I'm a Villain and my name is LimburgerOrc 19: I'm a Villain and my name is Bob*///:~ 7. 向上转型能够向基类发送的所有信息同样也可以向导出类发送.如果Instrument类具有一个play()方法,那么wind乐器也同样具备.我们可以准确地说wind对象也是一种类型的instrument. 12345678910111213141516171819//: reusing/Wind.java// Inheritance &amp; upcasting.class Instrument &#123; public void play() &#123;&#125; static void tune(Instrument i) &#123; // ... i.play(); &#125;&#125;// Wind objects are instruments// because they have the same interface:public class Wind extends Instrument &#123; public static void main(String[] args) &#123; Wind flute = new Wind(); Instrument.tune(flute); // Upcasting &#125;&#125; ///:~ 这种将Wind引用转换为Instrument引用的动作,我们称之为向上转型. 7.1 为什么称之为向上转型由导出类转换为基类,在继承图上是向上移动的,因此一般称为向上转型.由于向上转型是从一个较专业类型向通用类型转换,所以总是很安全.在向上转型的过程中,类接口中唯一可能发生的丢失方法,而不是获取它们. 7.2 再论组合与继承自己是否需要从新类向基类进行向上转型.如果必须向上转型,则继承是必要的;如果不需要,则应当好好考虑自己是否需要用到继承! 8. final 关键字这是无法改变的. 8.1 final 数据在Java中,这类常量必须是基本数据类型,并且以关键字final表示.在对这个常量进行定义的时候,必须对其进行赋值. 一个既是static又是final的域只占据一段不能改变的存储空间. 既是static又是final的域将用大写表示,并使用下划线分隔各个单词 定义为static则强调只有一份,定义为final则说明它是常量.并且static在装载的时候已经被初始化,并不是每次创建新对象时才初始化. 空白final 1234567891011121314151617181920212223242526//: reusing/BlankFinal.java// "Blank" final fields.class Poppet &#123; private int i; Poppet(int ii) &#123; i = ii; &#125;&#125;public class BlankFinal &#123; private final int i = 0; // Initialized final private final int j; // Blank final private final Poppet p; // Blank final reference // Blank finals MUST be initialized in the constructor: public BlankFinal() &#123; j = 1; // Initialize blank final p = new Poppet(1); // Initialize blank final reference &#125; public BlankFinal(int x) &#123; j = x; // Initialize blank final p = new Poppet(x); // Initialize blank final reference &#125; public static void main(String[] args) &#123; new BlankFinal(); new BlankFinal(47); &#125;&#125; ///:~ 必须在域的定义处或者每个构造器中用表达式对final进行赋值,这正是final域在使用前总是被初始化的原因. final参数 123456789101112131415161718192021222324//: reusing/FinalArguments.java// Using "final" with method arguments.class Gizmo &#123; public void spin() &#123;&#125;&#125;public class FinalArguments &#123; void with(final Gizmo g) &#123; //! g = new Gizmo(); // Illegal -- g is final &#125; void without(Gizmo g) &#123; g = new Gizmo(); // OK -- g not final g.spin(); &#125; // void f(final int i) &#123; i++; &#125; // Can't change // You can only read from a final primitive: int g(final int i) &#123; return i + 1; &#125; public static void main(String[] args) &#123; FinalArguments bf = new FinalArguments(); bf.without(null); bf.with(null); &#125;&#125; ///:~ 方法f()和g()展示了当前类型的参数指明为final时所出现的结果:你可以读参数,但却无法修改参数. 8.2 final方法使用final方法的原因有两个: 把方法锁定,以防任何继承类修改它的含义. 效率. final和private关键字类中所有的private方法都隐式地指定为final.由于无法取用private方法,所以也就无法覆盖它.可以对private方法添加final修饰词,但这不能给方法增加任何额外的意义. 1private final void v()&#123;&#125; 8.3 final类当将某个类的整体定义为final,就表明了你不打算继承该类,而且也不允许别人这样做.final是禁止继承的,所以final类中所有的方法都隐式指定为final的. 8.4 有关final的忠告如果将一个方法制定为final,可能会妨碍其他程序员在项目中通过继承来复用你的类,而这只是因为你没有想到它会以这种方式被运用. 9. 初始化及类的加载加载发生于创建类的第一个对象之时,但是当访问static域或static方法时,也会发生加载.构造器也是static方法. 9.1 继承与初始化12345678910111213141516171819202122232425262728293031323334353637383940//: reusing/Beetle.java// The full process of initialization.import static net.mindview.util.Print.*;class Insect &#123; private int i = 9; protected int j; Insect() &#123; print("i = " + i + ", j = " + j); j = 39; &#125; private static int x1 = printInit("static Insect.x1 initialized"); static int printInit(String s) &#123; print(s); return 47; &#125;&#125;public class Beetle extends Insect &#123; private int k = printInit("Beetle.k initialized"); public Beetle() &#123; print("k = " + k); print("j = " + j); &#125; private static int x2 = printInit("static Beetle.x2 initialized"); public static void main(String[] args) &#123; print("Beetle constructor"); Beetle b = new Beetle(); &#125;&#125; /* Output:static Insect.x1 initializedstatic Beetle.x2 initializedBeetle constructori = 9, j = 0Beetle.k initializedk = 47j = 39*///:~ 在Beetle上运行java时,所发生的第一件事情就是试图访问Bettle.main()(一个static方法),于是加载器开始启动并找出Bettle类的编译代码.在对它进行加载的过程中,编译器注意到它由一个基类(这是由关键字extends得知),于是它继续进行加载. 10. 总结继承和组合都能从现有的类型生成新的类型,组合一般是将现有的类型作为新类型底层实现的一部分来加以复用,而继承复用的是接口. 在使用继承时,由于导出类具有基类接口,因此它可以向上转型为基类.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第6章 访问权限控制]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC6%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[访问权限控制的等级,以最大权限到最小权限依次为:public,protected,包访问权限(没有关键字)和private. 1. 包 : 库单元如我们使用java.util中的一个叫做ArrayList的类.那么我们则要:12345public class FullQualificaction&#123; public static void main(String[] args)&#123; java.util.ArrayList list = new java.util.ArrayList(); &#125;&#125; 如果我们导入包import则不用.1import java.util.*; 1.1 代码组织package和import关键字允许你做的,是将单一的全局名字空间分割开,使得无论多少人使用Internet以及Java开始编写类,都不会出现名称冲突的问题. 1.2 创建独一无二的包名Java解释器的运行过程如下:首先,找出环境变量CLASSPATH,得到的路径会与CLASSPATH中的各个不同的项相连接,解释器就在这些目录中查找与你所有创建的类名称相关的.class文件. 1.3 定制工具库123456789101112class Print&#123; public static void print(Object object)&#123; System.out.println(object); &#125;&#125;public class PrintTest &#123; public static void main(String[] args) &#123; Print.print("hello"); &#125;&#125; 2. Java访问权限修饰词 使该成员成为public,无论谁,无论哪里,都可以访问该成员. 继承而来的类既可以访问public成员也可以访问protected成员(但访问不了private成员). 提供访问器(accessor)和变异器(mutaror)方法, 1234567891011121314151617181920212223package debug;public class SoupTest &#123; public static void main(String[] args) &#123; for(int i =1;i&lt;10;i++)&#123; System.out.println(Soup.newSoup()); &#125; &#125;&#125;class Soup&#123; private static Soup s = new Soup(); private Soup()&#123; &#125; public static Soup newSoup()&#123; return s; &#125; public void play()&#123; System.out.println("good!!!"); &#125;&#125; 3. 总结 为了使用户不用碰上那些不该碰到的部分,这些部分对于类内部的操作是必要的. 为了让类库设计者可以更改类的内部工作方式,而不必担心这样会对客户端程序员产生重大的影响.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第5章 初始化与清理]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC5%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86%2F</url>
      <content type="text"><![CDATA[随着计算机革命的发展,”不安全”的编程方式以逐渐成为编程代价的主因之一. 1. 用构造器确保初始化Java中构造器与类相同的名称,在初始化期间要自动调用构造器. 123456789101112131415161718package new05;public class Rock &#123; public Rock() &#123; // TODO Auto-generated constructor stub &#125;&#125;package new05;public class SimpleConstructor &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Rock(); &#125; &#125;&#125; 在创建对象时,new Rock();将会为对象分配存储空间,并调用相应的构造器.因为构造器的名称必须与类名完全相同,所以”每个方法首字母小写”的编码风格并不适用于构造器.不接受任何参数的构造器叫做默认构造器,Java文档中通常使用术语无参构造器. 2. 方法重载为了让方法名相同而形式参数不同的构造器同时存在,必须用到方法重载.示例: 1234567891011121314151617181920212223242526272829303132package new05;class Tree&#123; int height; //默认构造器 public Tree() &#123; System.out.println("Planting a seedling"); height = 0; &#125; Tree(int initialHeight)&#123; height = initialHeight; System.out.println("Creating new Tree that is"+height+"ftte tall"); &#125; void info()&#123; System.out.println("Tree is"+height+"feet tall"); &#125; void info(String s)&#123; System.out.println(s+":Tres is"+height+"feet tall"); &#125;&#125;public class OverLoading &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; Tree t = new Tree(i); t.info(); t.info("overloaded method"); &#125; new Tree(); &#125;&#125; 创建Tree对象的时候,既可以不含参数,也可以用树的高度为参数.前者表示一颗树苗,后者表示有一定高度的树苗.要支持这种创建方式,得有一个默认构造器和一个采用现有高度作为参数的构造器. 3. 默认构造器如果你写的类中没有构造器,则编译器会自动帮你创建一个默认的构造器.但如果你创建了一个构造器,编译器就不会帮你自动创建默认构造器. 练习: 1234567891011121314151617181920212223Dog.javapackage new05;public class Dog &#123; String name; Dog(String name)&#123; this.name = name; &#125; public void bark()&#123; System.out.println(this.name+&quot;is barking!&quot;); &#125;&#125;DogTest.javapackage new05;public class DogTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; Dog dog = new Dog(&quot;小&quot;+i); dog.bark(); &#125; &#125;&#125; 4. this关键字this关键字只能在方法内部使用,表示对”调用方法的那个对象”的引用. 5. static的含义static方法就是没有this的方法,在static方法的内部不能调用非静态方法.而且可以在没有创建对象的前提下,仅仅通过类本身调用static方法. 6. 清理:终结处理和垃圾回收垃圾回收器只知道释放那些由new分配的内存,但是finalize()能解决. finalize()的用途? 垃圾回收只与内存有关 对象可能不被垃圾回收 垃圾回收并不等于”析构” JVM在没有面临内存耗尽的情形,它是不会浪费时间去执行垃圾回收以恢复内存的. 7. 成员初始化Java尽力保证:所有变量在使用前都能得到适当的初始化.对于方法的局部变量,Java以编译时错误的形式来贯彻这种保证.在类定义一个对象引用时,如果不将其初始化.此引用就会获得一个特殊值null. 8. 构造器初始化无论创建多少个对象,静态数据都只占用一份存储区域. 总结一下对象的创建过程,假设有个名为dog的类: 即是没有显式地使用static关键字,构造器实际上也是静态方法.所以,当首次创建为dog的对象时,或者Dog类的静态方法/静态域首次被访问时,Java解析器必须查找类路径,以定位Dog.class文件. 然后载入Dog.class,有关静态初始化的所有动作都会被执行.所以,静态初始化只在class对象首次加载的时候进行一次. 当用new dog()创建对象的时候,首先将在推上为dog对象分配足够的存储空间. 这块存储空间会被清零,这就自动地将Dog对象中的基本类型数据都设置成了默认值. 执行所有出现于字段定义处的初始化动作. 执行构造器.例子: 123456789101112131415161718192021222324252627package new05;class Cup&#123; Cup(int marker)&#123; System.out.println("Cup("+marker+")"); &#125; void f(int marker)&#123; System.out.println("f("+marker+")"); &#125;&#125;class Cups&#123; static Cup cup1; static Cup cup2; static&#123; cup1 = new Cup(1); cup2 = new Cup(2); &#125; Cups()&#123; System.out.println("Cups"); &#125;&#125;public class ExplicitStatic &#123; public static void main(String[] args) &#123; System.out.println("Inside main()"); Cups.cup1.f(99); &#125;&#125; 9. 数组初始化要定义一个数组,只需要在类型名后加上一对空方括号即可;编译器不允许指定数组的大小,只是对数组的一个引用. 1int[] a1; 例子:可变参数列表 123456789101112package new05;public class AutoboxingVarargs &#123; public static void f(Integer...args)&#123; for (Integer integer : args) &#123; System.out.println(integer); &#125; &#125; public static void main(String[] args) &#123; f(4,5,6,7,8); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第4章 控制执行流程]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC4%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[就像有知觉的生物一样,程序必须在执行过程中控制它的世界,并做出选择.在Java中,你要使用执行控制语句来做出选择. 1. return如果在返回void的方法中没有return语句,那么在该方法的结尾处会有一个隐式的return. 2. break和continuebreak用于强强行退出循环,不执行循环中剩余的语句.而continue则停止执行当前的迭代,然后退回循环起始处,开始下一次迭代.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第3章 操作符]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在最底层,Java中的数据是通过常用操作符操作的. 1. 优先级先乘除后加减,System.out.println()语句中包含”+”操作符.”+”意味着”字符串连接”,当编译器观察到一个String后面跟一个”+”,而这个”+”的后面又跟一个非String类型的元素时,就会尝试将这个非String类型的元素转换为String. 1.1 方法调用中的别名问题1234567891011121314151617181920212223package com.fkcat.new03;public class Letter &#123; char c;&#125;package com.fkcat.new03;public class PassObject &#123; static void f(Letter y)&#123; y.c = 'z'; &#125; public static void main(String[] args) &#123; Letter x = new Letter(); x.c = 'a'; System.out.println("1:x.c "+x.c); f(x); System.out.println("2:x.c "+x.c); &#125;&#125; 方法f()好像要在它的作用域内复制其参数Letter y 的一个副本;但实际上只是传递了一个引用.所以代码行实际改变的是f()之外的对象. 1y.c = 'z'; 2. 算术操作符如果要将X加4,并将结果赋回给X,可以这么写:X+=4; 3. 自动递增和递减++a 等价于 a = a + 1; 4. 类型转换操作符假设我们为某浮点变量赋以一个整数值,编译器会将int自动转换为float.类型转换运算允许我们显式地进行类型的转换,或者在不能自动进行转换的时候强制进行转换.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第2章 一切都是对象]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC2%E7%AB%A0-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[1. 用引用操纵对象一切都看作为对象,操纵的标识符实际上是对象的一个”引用”,如果想操纵一个词或句子,则可以创建一个String引用: 1String s; 创建了一个引用,并不是对象.此时向s发送一个信心,就会返回一个运行错误.着是因为S实际上没有与任何事物相关联.因此,一种安全的做法是:创建一个引用的同时便进行初始化. 1Stirng s = "asdf"; Java语言的一个特性:字符串可以用带引号的文本初始化.通常,必须对对象采用一种更通用的初始化方法. 2.必须由你创建所有对象1String s = new String("asdf"); 一旦创建了一个引用,就希望它能与一个新的对象相关联,通常用new操作符来实现这一目的.new关键字的意思是”给我一个新的对象.” 2.1 存储到什么地方有五个不同的地方可以存储数据: 寄存器:它位于处理器内部,但是寄存器的数量极其有限,所以寄存器根据需求进行分配. 堆栈:位于通用RAM(随机访问寄存器)中,Java系统必须知道存储在堆栈内所有项的确切生命周期,以便上下移动堆栈指针.尽管Java数据存储在堆栈中,但是Java对象并不存储于其中. 堆:一种通用的内存池(也位于RAM区),用于存放所有的Java对象,当需要一个对象时,只需要new写一行简单的代码,当执行这行代码时,会自动在堆里面进行存储分配. 常量存储:常量值通常直接存放在程序代码内部,这样很安全,因为不会被改变. 非RAM存储:数据完全存货在程序之外,最基本的例子是流对象和持久化对象.在流对象中,对象转换成字节流,通常被发送到另一台机器.在”持久化”对象中,对象被存放于硬盘上,即使程序终止,它们仍可以保持自己的状态. 2.2 特例:基本类型在程序设计中经常用到的一系列类型,它们需要特殊对待.它们称之为”基本”类型.是因为new将对象存储在”堆”里,故用new创建一个对象,往往不是特别有效.所有Java往往不用new来创建变量,而是创建一个并非是引用的”自动”变量.这个变量直接存储”值“,并置于堆栈中,因此更加有高效. 基本类型都具有包装器类,使得可以在堆中创建一个非基本对象,用来表示对应的基本类型. 12Char c = "x";Character ch = new Character(c); 也可以这样写: 1Character ch = new Character("x"); 高精度数字 BigInteger:支持任意精度的整数. BigDecimal:支持任意精度的定点数. 2.3 Java中的数组当创建了一个数组对象时,实际上就是创建了一个引用数组,并且每个引用都会自动被初始化为一个特定值,该值拥有自己的关键字null.一旦Java看到null,就知道这个引用还没有指向某个对象.在引用任何引用前,都必须为其指定一个对象,否则会报错. 2.3.1 作用域作用域决定了在其内定义的变量名的可见性和生命周期.如: 123456&#123; int x = 12; &#123; int q = 96; &#125;&#125; 这样的代码在Java上不允许这样写,编译器将会报告变量X已经被定义过.所以,在C和C++里将一个较大作用域的变量”隐藏”起来的做法,在Java中是不被允许的. 2.3.2 对象的作用域Java对象不具备基本类型的一样的生命周期,当用new创建一个Java对象时,它可以存活于作用域之外. 1234&#123; String s = new String("a String");&#125; 引用s在作用域中点就消失了.然而,s指向的String对象仍继续占据内存空间.在这一小段代码中,我们无法再这个作用域之后访问对象,因为对它唯一的引用已超出了作用域的范围. Java提供垃圾回收器,用来监视用new创建的所有对象,并辨别那些不会被引用的对象.随后,释放这些对象的内存空间,以便供其他新的对象使用. 2.4 创建新的数据类型:类1class AtypeName&#123;&#125; 引入了新的类型.然而,你可以用new来创建这种类型的对象: 1ATypeName a = new ATypeName(); 2.4.1 字段和方法字段我们有时被称为(数据成员)和方法我们有时被称为(成员函数).字段可以是任何类型的对象,可以通过引用与其进行通信,也能为基本类型的一种.字段如果是对某个对象的引用,必须将其初始化引用.如: 123456Class DataOnly&#123; int i; double d; boolean b;&#125;DataOnly data = new DataOnly();//在对象引用的名称之后接括号,在对象内部写成员名称; 123data.i = 47;data.d = 1.1;data.b = false; int i;Java会在编译时会返回一个错误,告诉你变量没有初始化. 2.5 方法、参数和返回值Java的方法决定了一个对象能够接收什么样的信息. 1234ReturnType methodName(int a )&#123;&#125; Java中的方法只能通过对象才能调用. 1int x = a.f(); 这种调用方法的行为通常被称为发送消息给对象. 2.5.1 参数列表如果参数被设为String类型,就必须传递一个String的对象;否则,编译器会抛出错误! return 表示它已经做完,离开此方法! 2.6 构建一个Java程序1import java.util.*;//通配符&quot;*&quot;来达到目的! 2.6.1 static关键字当生命一个事物是static时,就意味着某个域或方法不会与包含它的那个类的任何对象实例关联在一起.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二.帧动画Drawable Animation入门]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BA%8C-%E5%B8%A7%E5%8A%A8%E7%94%BBDrawable-Animation%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Drawable AnimationDrawable animation lets you load a series of Drawable resources one after another to create an animation. This is a traditional animation in the sense that it is created with a sequence of different images, played in order, like a roll of film. The AnimationDrawable class is the basis for Drawable animations. Drawable animation是一个一个的加载一些列的图片来创建动画的，他是一种传统的动画，事实上就是一个不同图片的序列AnimationDrawable是Drawable animations 的基类. While you can define the frames of an animation in your code, using the AnimationDrawableclass API, it‘s more simply accomplished with a single XML file that lists the frames that compose the animation. The XML file for this kind of animation belongs in the res/drawable/ directory of your Android project. In this case, the instructions are the order and duration for each frame of the animation. 虽然可以使用AnimationDrawable类在代码中定义帧动画，但最好是使用XML文件列出组成动画的所有帧。这个xml文件放在res/drawable/目录下，事实上，所有的指令就是每一个帧动画的顺序和持续时间. The XML file consists of an&lt;animation-list&gt; element as the root node and a series of child&lt;item&gt; nodes that each define a frame: a drawable resource for the frame and the frame duration. Here‘s an example XML file for a Drawable animation: xml文件由根元素 &lt;animation-list&gt;和一系列子元素&lt;item&gt;组成，其中&lt;item&gt;定义了每个帧对应的图片和持续时间，如下： 123456&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true"&gt; &lt;item android:drawable="@drawable/rocket_thrust1" android:duration="200" /&gt; &lt;item android:drawable="@drawable/rocket_thrust2" android:duration="200" /&gt; &lt;item android:drawable="@drawable/rocket_thrust3" android:duration="200" /&gt;&lt;/animation-list&gt; This animation runs for just three frames. By setting the android:oneshotattribute of the list to true, it will cycle just once then stop and hold on the last frame. If it is set false then the animation will loop. With this XML saved as rocket_thrust.xml in the res/drawable/directory of the project, it can be added as the background image to a View and then called to play. Here‘s an example Activity, in which the animation is added to an ImageView and then animated when the screen is touched: 上面的例子是一个3帧动画， 通过将android:oneshot设置为true，那他就只会循环一次，并停留在最后一个帧上，若为false的话，就会循环运行. 123456789101112131415161718AnimationDrawable rocketAnimation;public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image); rocketImage.setBackgroundResource(R.drawable.rocket_thrust); rocketAnimation = (AnimationDrawable) rocketImage.getBackground();&#125;public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; rocketAnimation.start(); return true; &#125; return super.onTouchEvent(event);&#125; It‘s important to note that the start() method called on the AnimationDrawable cannot be called during the onCreate()method of your Activity, because the AnimationDrawable is not yet fully attached to the window. If you want to play the animation immediately, without requiring interaction, then you might want to call it from theonWindowFocusChanged()) method in your Activity, which will get called when Android brings your window into focus. 注意：start()方法不能在你的Activity的onCreate()方法中调用，因为那时候AnimationDrawable尚未完全附着于窗口。如果你必须立刻调用动画，切没有交互的话，可以在onWindowFocusChanged())中调用。因为这个方法是窗口获得焦点时调用的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一.最常用和最难用的控件(ListView)]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%B8%80-%E6%9C%80%E5%B8%B8%E7%94%A8%E5%92%8C%E6%9C%80%E9%9A%BE%E7%94%A8%E7%9A%84%E6%8E%A7%E4%BB%B6-ListView%2F</url>
      <content type="text"><![CDATA[ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内,同时屏幕上原有的数据则会滚动出屏幕. 1. ListView的简单用法首先新建一个ListViewTest项目,然后修改activity_main.xml代码.12345678&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_height="match_parent" android:layout_width="match_parent"&gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/ListView&gt;&lt;/LinearLayout&gt; 为ListView指定一个id,然后将宽度和高度都修改为match_parent,这样ListView就占据了整个布局的空间. 接下来修改MainActivity中的代码.1234567891011121314151617public class MainActivity extends Activity &#123; private String[] data = &#123;"Apple","Banana","Orange","Watermelon", "Pear","Grape","Pineapple","Strawberry","Cherry","Mango"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //先创建适配器,并且把内容放入去. ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt; (MainActivity.this, android.R.layout.simple_list_item_1,data); ListView listView = (ListView) findViewById(R.id.list_view); //调用ListView的对象把适配器传进去. listView.setAdapter(adapter); &#125;&#125; 数组中的数据是无法直接传递给ListView的,我们需要借助适配器来完成,其中最好用的是ArrayAdapter它可以通过泛型来指定要添加的数据类型,然后在构造函数中把要适配的数据传入即可.注意我们使用了android.R.layout.simple_list_item_1作为ListView的子项布局的id,以及要适配的数据. 最后,我们要调用ListView的SetAdapter()方法,将构造好的适配器对象传递进去,这样ListView和数据之间的关联就建立完成了. 2. 定制ListView的界面接着定义一个实体类,作为ListView适配器的适配类型,新建类Fruit,需要准备一组图片. 123456789101112131415161718192021public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; Fruit类中只有两个字段,name表示水果的名字,imageId表示水果对应图片的资源id. 然后需要为ListView的子项指定一个我们自定义的布局,在layout目录下新建fruit_item.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dip" /&gt;&lt;/LinearLayout&gt; 在这个布局里,我们定义了一个ImageView用于显示水果的图片,又定义了一个TextView用于显示水果的名称. 接下来需要创建一个自定义的适配器,这个适配器继承自ArrayAdapter,并将泛型指定为Fruit类.新建类FruitAdapter,代码如下: 1234567891011121314151617181920212223public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view = LayoutInflater.from(getContext()).inflate(resourceId, null); ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125;&#125; FruitAdapter重写了父类的一组构造函数,用于将上下文,ListView子项布局的id和数据都传递进来.另外又重写了getView()方法,首先通过getItem()方法得到当前项的Fruit的实例,然后使用LayoutInflater来为这个子项加载我们传入的布局,接着调用View的fndViewById()方法分别获取到ImageView和TextView的实例,并分别调用它们的setImageResource和setText方法来设置显示的图片和文字,最好将布局返回. 下面修改MainActivity中的代码,如下所示: 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends Activity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void initFruits() &#123; Fruit apple = new Fruit("Apple", R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit("Banana", R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit("Orange", R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit("Pear", R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit("Grape", R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit("Mango", R.drawable.mango_pic); fruitList.add(mango); &#125;&#125; 可以看到,这里添加了一个initFruits()方法,用于初始化所有水果的数据,在Fruit类构造函数将水果的名字和对应图片id传入,然后把创建好的对象添加到水果列表中,接着我们再onCreate()方法中创建了FruitAdapter对象,并将FruitAdapter作为适配器传递给ListView. 3. 提升ListView的运行效率因为在FruitAdapter的getView()方法中每次都将布局重新加载了一次,当ListView快速滚动的时候就会成为性能的阻碍.12345678910111213141516171819202122232425262728public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); // 获取当前项的Fruit实例 View view; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); &#125; else &#123; view = convertView; &#125; ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; &#125;&#125; 所以,我们再getView()方法中进行了判断,如果convertView为空,则使用LayoutInflater去加载布局,如果不为空则直接对convertView进行重用. 每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例,我们还可以借助一个ViewHolder来对这部分性能进行优化,修改FruitAdapter`中的代码,如下所示: 123456789101112131415161718192021222324252627282930313233343536373839public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; &#123; private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceId, null); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image); viewHolder.fruitName = (TextView) view.findViewById(R.id.fruit_name); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; &#125; class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125;&#125; 我们新建了一个内部类ViewHolder,用于对控件的实例进行缓存.当convertView为空的时候,创建一个ViewHolder对象,并将控件的实例都存放在ViewHolder里,然后调用View的SetTag()方法,将ViewHolder对象存储在View中.当convertView不为空的时候则调用View的getTag()方法,把ViewHolder重新取出.这样所有控件的实例都缓存在ViewHolder里,就没有必要每次都通过findViewById()方法来获取控件实例了. 4. ListView的点击事件123456789listView.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); &#125;&#125;); 5. 总结 先在布局中加入ListView控件 然后自定义适配器,这个适配器继承自ArrayAdapter 初始化数据,把数据传入自定义适配器 然后将适配器传递给ListView.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五.Css基础(3)]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BA%94-Css%E5%9F%BA%E7%A1%80-3%2F</url>
      <content type="text"><![CDATA[1. 复习回顾1.1 行高(Line-height) 行高浏览器的默认字体大小为16px 浏览器默认文字行高为18px行高 = 上间距 + 文字大小 + 下间距![详解行高使文字垂直居中]五-Css基础-3/1.png “详解行高使文字垂直居中”) 行高单位问题 单独给一个标签设置行高 结果 如果行高单位是px 行高与文字大小无关 如果行高单位是em 行高=文字大小*行高值 如果行高单位是 % 行高=文字大小*行高值 如果行高没有单位 行高=文字大小*行高值 给父元素设置行高 子元素行高结果 行高单位是px 行高=父元素行高 行高单位是em 行高=父元素文字大小*行高值（与子元素文字大小无关） 行高单位是% 同上 行高单位无 行高=子元素文字大小*行高值 1.2 盒模型所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子,也就是一个盛装内容的容器.每个矩形都由元素的内容,内边距(padding),边框(border)和外边距(margin)组成.![盒子模型]五-Css基础-3/2.png “盒子模型”) ![Paste_Image]五-Css基础-3/3.png “Paste_Image”) css中盒子模型由三部分组成 : 1.边框(border) 2.内边距(padding) 3.外边距(margin) 1.2.1 盒模型之边框(broder) 语法 :border : border-width || border-style || border-color 属性名称 介绍 border-width 设置边框宽度单位以px为主例如:12px border-style 设置边框样式 border-color 设置边框颜色 border-top 设置上边框样式 border-bottom 设置下边框样式 border-left 设置左边框样式 border-right 设置右边框样式 热身 : 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style type="text/css"&gt; div&#123; width:100px; height:100px; border-width:1px; border-style:dotted; border-color:green; &#125; p&#123; width:100px; height:100px; border-width:1px; border-style:solid; border-color:red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1.2.2 盒模型之内边距(padding) 属性名称 介绍 padding:10px 上,下,左,右距离分别是10px padding:10px 40px 上下10px 左右40px padding:10px 40px 20px 上10px 左右40px 下20px padding:10px 20px 30px 40px 上10 右20px 下30px 左40px padding-top 上内边距 padding-right 右内边距 padding-bottom 下内边距 padding-left 左内边距 padding影响盒子大小问题盒子宽度=盒子宽度+左右内边距+边框宽度 1.2.3 盒子模型之外边距(margin) 属性名称 介绍 margin:10px 距离上下左右边距10px margin:10px 20px 距离上下10px 左右20px margin:10px 20px 30px 距离上10px 左右 20px margin:10px 20px 30px 40px 距离上10px 右20px 下 3左40px margin-left: 距离左边 margin-right 距离右边 margin-top 距离上边 margin-bottom 距离下边 margin:0 auto auto 设置为相对边的值 Margin之边框合并外边距合并(叠加)是一个相当简单的概念.简单地说,外边距合并指的是,当两个垂直外边距相遇时,它们将形成一个外边距.合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者.当一个元素出现在另一个元素上面时,第一个元素的下外边距与第二个元素的上外边距会发生合并. 行内元素不要给上下的margin 和padding注意 :上下margin和padding会被忽略,左右margin和padding会起作用. 热身 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style type="text/css"&gt; *&#123; margin: 0; padding:0; &#125; .box&#123; height:382px; width:208px; border: 1px solid #CECECE; margin: 20px auto; &#125; .title&#123; height:25px; background: #ECEDEE; &#125; h4&#123; height:25px; line-height: 25px; font-size:14px; padding-left: 10px; &#125; .photo&#123; width: 180px; height: 180px; border:1px solid #CCCCCC; margin:10px auto; &#125; .weibo&#123; text-align: center; border-bottom: 1px dotted #D1D1D1; padding-bottom:15px; &#125; .weibo input&#123; width: 70px; height: 21px; background: url("vb.jpg") no-repeat; &#125; .friend&#123; text-align: center; margin-top: 5px; &#125; .friend input&#123; width: 69px; height: 23px; margin-bottom:5px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="title"&gt; &lt;h4&gt;个人资料&lt;/h4&gt; &lt;/div&gt; &lt;div class="photo"&gt; ![](1.jpg) &lt;/div&gt; &lt;div class="weibo"&gt; &lt;span&gt;V闪闪&lt;/span&gt; ![](v.jpg) &lt;br&gt; &lt;br&gt; &lt;input type="button" value="微博"&gt; &lt;/div&gt; &lt;div class="friend"&gt; &lt;input type="button" value="加好友"&gt; &lt;input type="button" value="加好友"&gt; &lt;input type="button" value="加好友"&gt; &lt;input type="button" value="加好友"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2. 新知识2.1 标准流normal flow(文档流)标准流 : 块级元素纵向有序排列,行内块(行内)元素横向有序排列 2.2 浮动 (float) 语法 : float:left | right 特点 : 设置了浮动的元素不占原来的位置（脱标） 可以让块级元素在一行上显示 浮动可以行内元素转化为行内块元素模式转换的过程中，能用display就用display 作用 : 浮动用来解决文字图片环绕问题 制作导航栏 网页布局 热身 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="Generator" content="EditPlus®"&gt; &lt;meta name="Author" content=""&gt; &lt;meta name="Keywords" content=""&gt; &lt;meta name="Description" content=""&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; div&#123; width:300px; height:400px; border:1px solid red; &#125; div img&#123; float:left; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; ![](1.jpg) &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 热身 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="Generator" content="EditPlus®"&gt; &lt;meta name="Author" content=""&gt; &lt;meta name="Keywords" content=""&gt; &lt;meta name="Description" content=""&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin:0; padding:0; &#125; .nav&#123; height:55px; background: url("head_bg.jpg"); &#125; .nav li&#123; list-style:none; float:left; line-height:55px; background: url("li_bg.png") no-repeat right; &#125; ul&#123; margin-left: 390px; &#125; a&#123; height:55px; display:inline-block; padding:0 10px; text-decoration:none; color:black; &#125; a:hover&#123; background-color:yellowgreen; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="nav"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="#"&gt;智能手机&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;智能手机&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;智能手机&lt;/a&gt; &lt;/li&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.3 清除浮动当父容器没有设置高度,里面的盒子没有设置浮动的情况下会将父容器的高度撑开.一旦父容器中的盒子设置浮动,脱离标准文档流,父容器立马没有高度,下面的盒子会跑到浮动的盒子下面.出现这种情况,我们需要清除浮动. 2.3.1 清除浮动的方式 使用 :clear:left| right | both在要清除的浮动的元素后面添加一个标签 给父容器设置高度 通过设置clear:left | right | both 给父容器设置 overflow:hidden 通过伪元素 : 12345678910clearfix:after&#123; content:""; height:0; line-height:0; visibily:hidden; clear:both; display:block;&#125;.clearfix&#123; zoom:1 为了兼容IE浏览器&#125; 2.4 overflow介绍overflow 属性规定当内容溢出元素框时发生的事情. 属性名称 介绍 overflow:visible 默认值.内容不会被修剪,会呈现在元素框之外. overflow:hidden 内容会被修剪,并且其余内容是不可见的. overflow:scroll 内容会被修剪,但是浏览器会显示滚动条以便查看其余的内容. overflow:auto 如果内容被修剪,则浏览器会显示滚动条以便查看其余的内容. 热身 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;style type="text/css"&gt;div&#123;width: 300px;height: 300px;border: 1px solid green;overflow: scroll; /* 添加滚动条 */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;asdfasdfasdf&lt;/p&gt;&lt;p&gt;asdfasdfasdf&lt;/p&gt;&lt;p&gt;asdfasdfasdf&lt;/p&gt;&lt;p&gt;asdfasdfasdf&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3. 定位 (position) 语法 介绍 position:static 静态定位 position:absolute 绝对定位 position:relative 相对定位 position:fixed 固定定位 3.1 静态定位 静态定位 : 就是按照标准流的方式显示 用法 :position : static; 3.2 绝对定位(absloute)看脸型 绝对定位以浏览器左上角为基准设置位置 当一个盒子包含在另一个盒子中,父盒子未设置定位,盒子以浏览器左上角为基准设置位置; 当父盒子设置定位,子盒子以父盒子左上角为基准设置位置 绝对定位绝对不占空间位置(与浮动一样) 绝对定位可是实现模式转换 3.3 相对定位(relative)自恋型 相对定位以元素自身的位置为基准设置位置 相对定位占位置 一般子元素设置相对定位,父元素设置绝对定位(子绝父相) 4. 案例与作业 导航练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;style&gt;*&#123;margin:0;padding:0;&#125;.box&#123;width:600px;height:150px;background-image:url("banner_bg.jpg");margin:0 auto;&#125;.nav&#123;background-image:url("nav_bg.jpg");height:32px;&#125;li&#123;list-style:none;float:left;&#125;li a&#123;height:32px;width:80px;display:inline-block;background-image:url("a_bg.jpg");line-height:32px;text-align:center;text-decoration:none;&#125;li a:hover&#123;background-image:url("button2.jpg");&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;![](banner1.jpg)&lt;div class="nav"&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#"&gt;首页导航&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;首页导航&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;首页导航&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;首页导航&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;首页导航&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;首页导航&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 固定定位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;style&gt;*&#123;margin:0;padding:0;&#125;.box&#123;width:998px;height:1667px;margin:0 auto;margin-top:44px;&#125;.header&#123;position:fixed;top:0;left:0;&#125;.left,.right&#123;position:fixed;&#125;.left&#123;left:0;top:70px;&#125;.right&#123;right:0;top:70px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;![](box.png)&lt;div class="header"&gt;![](r1_c1.png)&lt;/div&gt;&lt;div class="left"&gt;![](r2_c1.png)&lt;/div&gt;&lt;div class="right"&gt;![](r2_c2.png)&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 小米导航 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt;.box&#123;width: 1226px;height: 460px;margin:0 auto;position: relative;&#125;.left&#123;width: 234px;height: 457px;position: absolute;top:1px;left:0px;&#125;.left_s&#123;position: absolute;left:244px;top: 214px;&#125;.right_s&#123;position: absolute;right:0px;top: 214px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;&lt;div class="img"&gt;![](1.jpg)&lt;/div&gt;&lt;div class="left"&gt;![](xiaom_left.png)&lt;/div&gt;&lt;div class="left_s"&gt;![](left.png)&lt;/div&gt;&lt;div class="right_s"&gt;![](right.png)&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5. 总结 : background: url(“li_bg.png”) no-repeat right; no-repeat : 含义为不平铺 display:inline-block; 在同一行显示 text-decoration:none; 文字修饰设置为无]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[四.Css基础(2)]]></title>
      <url>%2F2017%2F03%2F28%2F%E5%9B%9B-Css%E5%9F%BA%E7%A1%80-2%2F</url>
      <content type="text"><![CDATA[1. 复习回顾概念 : 层叠样式表或者叫级联样式表 内嵌式 : 基本实现css代码与html代码分离.当前样式只能控制当前页面 123&lt;head&gt;&lt;style type=”text/css”&gt;&lt;/style&gt;&lt;/head&gt; 语法 : 选择器{属性:值; } 属性 赋值 描述 color color:red; 文字颜色 font-size font-size:20px; 文字大小 font-family ont-family:宋体; 文字字体 font-weight font-weight:bold(700) / normal 文字加粗 font-style font-style:italic / normal 文字斜体(italic) background-color background-color:red; 背景颜色 width height / width: 12px; 宽度和高度 text-align text-align:center; 文字居中 text-indent text-indent:2em; 首行缩进 margin margin: 0 auto; 盒子居中显示 1.1 基础选择器 标签选择器P{属性:值;} 类选择器定义 :.fontcolor{color: red;}调用 :&lt;p class=”fontcolor”&gt;文字&lt;/p&gt;特点 :谁调用谁改变一个标签可以同时调用多个类样式多个标签可以同时调用一个类样式命名 :不推荐使用汉字定义类名不推荐使用标签名或者属性名定义类名不能使用纯数字或者特殊字符 (“_”除外)定义类名 id 选择器定义 :#自定义名称{属性:值;}注意 :页面中的表 id 名称不能重复同一个标签不能调用多个 id 样式 通配符选择器*{属性:值;} 1.2 复合选择器 标签指定式选择器P.类选择器{属性:值;}既…又… 后代选择器选择器 选择器{属性:值;}标签之间的关系属于嵌套关系 并集选择器选择器,选择器,选择器{属性:值;} 2. Css书写位置 内嵌式 : 基本实现css代码与html代码分离.当前样式只能控制当前页面 外链式 : 完全实现css代码与html代码分离,当前样式可以作用到整个网站 行内式 : 完全没有实现css代码与html代码相分离,写法简答.维护成本高 3. Html标签的分类3.1 块级元素 特点 :元素自己独占一行显示（与宽度无关）可以设置宽度和高度当嵌套一个块级元素,子元素如果不设置宽度,那么该子元素的宽度为父元素的宽度. 3.2 行内元素 特点 :元素在一行上显示不能直接设置宽度和高度 3.3 行内块元素 特点 :元素在一行上显示可以设置宽度和高度 3.4 元素之间的转换display : inline 将元素转化为行内元素display : inline-block 将元素转化行内块元素display : block 将元素转化为块元素 123div&#123; display : inline;&#125; 4. Css特性4.1 层叠性样式的覆盖. 样式的层叠性与样式的调用顺序没有关系,与样式的定义顺序有关.层叠性发生的前提 : 样式冲突 4.2 继承性继承性发生的前提是标签之间属于一种嵌套关系 文字颜色可以实现继承 文字大小可以实现继承 字体可以实现继承 行高可以实现继承 与文字有关的属性都可以,实现继承 特殊性 :&lt;a href=”#”&gt;&lt;/a&gt; 不能继承父元素中的文字颜色(层叠掉了)&lt;h1&gt;&lt;/h1&gt;标题标签不能继承父元素中的文字大小 4.3 优先级默认样式&lt;标签选择器&lt;类选择器&lt;id 选择器&lt;行内样式&lt;!important 5. 伪类介绍 :link : 伪类,适用于未被用户访问过的链接 :visited : 伪类,适用于已被用户访问过的链接 :hover : 伪类,光标指向一个元素,但此元素未被激活时的样式 :active : 伪类,适用于一个元素被激活时的样式 伪类常用属性 属性介绍 text-decoration:none / underline 设置文字是否有下横线 6. 背景(background) background-color 背景颜色 background-image 背景图片 注意 :设置背景图片时候一定要设置宽度和高度 12345div&#123; background-image:url("1.png"); width: 500px; height:500px; &#125; background-repeat(设置背景平铺)repeat （默认值）|no-repeat （不平铺）|repeat-x | （横向平铺）repeat-y （纵向平铺） background-position(设置背景位置)设置具体值 : left| right| top| bottom| cneter background-attachment(设置背景是否固定)Scroll(默认值)滚动| fixed(图片固定) 背景属性联写 :background: url(“1.png”) red no-repeat 30px 40px;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三.Css基础(1)]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%B8%89-Css%E5%9F%BA%E7%A1%80-1%2F</url>
      <content type="text"><![CDATA[1. Css概念CSS 指层叠样式表 (Cascading Style Sheets)级联样式表 1.1 Css与Html的关系 Css 以 html 为基础的. Css 主要设置的就是 html 标签中的属性样式,css 进行网页布局. 1.2 Css语法 选择器{属性:值; 属性:值;…. } 选择器 : 就是一个选择谁的过程. 参数说明 : 属性和属性值之间用冒号(:)隔开,定义多个属性时,属性之间用英文输入法下的分号;隔开. 属性 赋值 介绍 color color: red; 前景色（文字颜色） font-size font-size: 20px; 设置文字大小 width width: 30px; 设置宽度 width width: 30px; 设置宽度 Height height:30px; 设置高度 Background-color background-color:red; 设置背景颜色 Text-align text-align:center; left/right; 文字居中 Text-indent text-indent: 2em； 首行缩进 Px : 像素 注意 : Text-align:center; 在块级元素中可以让文字居中 1.3 Css 书写位置介绍 内嵌式写法123456789&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style type="text/css"&gt; p&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt; 1.4 选择器的分类 基础选择器 标签选择器 类选择器 id 选择器-通配符选择器 复合选择器 标签指定式选择器 后代选择器 并集选择器 1.5 标签选择器 标签 : 就是 html 中的标签 用法 :标签名{属性:值; 属性:值;} 颜色的显示方式 直接设置对应颜色的名称p{color:red;} 通过十六进制显示color:#2934DE; 通过 rgb 方式显示 R : 代表的是红色（red） 0-255G : 代表的是绿色（green） 0-255B : 代表的是蓝色（blue） 0-255 rgba a : 设置透明度 alpha 0-1 1.6 类选择器 用法 : .自定名称{属性:值;} 调用 : 标签通过 class 属性调用类样式.fontcolor{color:red;} 特点 : 谁调用谁改变,多个标签可以同时调用一个类样式. 一个标签可以调用多个类样式 1.7 类的命名规范 不能以纯数字或者以数字开头定义类名 不推荐使用汉字定义类名 不能以特殊符号或者以特殊符号开头（“_”除外）定义类名 不建议使用标签名或者属性名定义类名 1.8 Id选择器 用法 : #id名称{属性:值;} 调用 :&lt;p id =&quot;p_color&quot;&gt;hello,world!&lt;/p&gt; 特点 : 不建议多个标签使用同一 id 选择器的样式 一个标签只能调用一个 id 样式 1.9 通配符选择器 用法 : {属性:值; 属性:值;}`{color: red; font-size: 30px;}` 特点 : 将页面中所有的标签都选中,设置样式 进行页面样式的初始化 注意 : 在写样式的时候 (类选择器),如果有样式代码重复使用的时候,我们要提取公共类. 1.10 字体相关属性 Font-size : 设置文字大小 Font-family : 设置文字字体 Font-weight : 设置文字加粗 Font-style : 设置文字斜体 Line-height : 行高 1.11 Font-family 直接设置汉字p{font-family: 微软雅黑;} 设置对应字体的英文 可以设置 unicode 编码 Font-family 可以设置多个值;{font-family: &quot;Simsum&quot;,&quot;宋体&quot;} 1.12 Font-weight 取值方式 : 直接设置数字 100-900 bold (字体加粗) 效果与 700-900 normal (文字字体正常显示) 注意 : 文字加粗显示,推荐使用 font-weight:700; 1.13 Font-style(斜体) italic 文字斜体显示 normal 文字正常显示 1.14 Font 属性联写 用法 : 12font: font-style font-weight font-size/line-heightfont-family 注意 : font 属性联写必须有 font-size 和 font-family(其他属性可以不写) font-size 和 font-family 的顺序不能换 2. 标签指定选择器 用法 :标签名.选择器名{属性:值; 属性:值;} 3. 后代选择器 特点 : 标签之间必须属于嵌套关系. 用法 : 选择器 +空格+ 选择器{属性:值; 属性:值;…} 特点 : 选择器之间必须有空格 关系 : 父与子的关系 4. 并集选择器 用法 : 选择器,选择器,选择器{属性:值;} 作用 : 将样式集体声明,css 样式初始化. 特点 : 并集选择器之间必须用逗号隔开! margin: 0 auto; 让盒子居中显示。 5. 作业与一些总结 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; .newsTitle&#123;Text-align:center;&#125; .secondTitle&#123;Text-align:center;&#125; .time&#123; color: #AABBCC; font-size: 14px;&#125; .adTitle&#123;color: #990000;font-size: 14px;&#125; .show&#123;color: red;&#125; .search&#123; color: #008000; &#125; .essay&#123; text-indent:2em; &#125; .weibo&#123; color: #3399CC; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="newsTitle"&gt;中乙队赛前突然换帅仍胜毅腾 高原黑马欲阻击舜天&lt;/h1&gt; &lt;p class="secondTitle"&gt; &lt;font class="time"&gt;2014年07月16日20:11&lt;/font&gt; &lt;font class="adTitle"&gt;新浪体育 评论中大奖（11人参与）&lt;/font&gt; &lt;a href="http://www.w3school.com.cn"&gt;收藏本文&lt;/a&gt; &lt;input class="show" type="text" value="请输入查询条件"&gt; &lt;input class="search" type="button" value="搜索"&gt;&lt;hr /&gt;&lt;p class="essay"&gt; 新浪体育讯 7月16日是燕京啤酒&lt;a class="weibo" href="http://www.w3school.com.cn"&gt;[微博]&lt;/a&gt;2014中国足协杯第三轮比赛，丽江嘉云昊队主场迎战哈尔滨毅腾队的比赛日。然而就在比赛日中午，丽江嘉云昊队主帅李虎和另外两名成员悄然向俱乐部提出了辞呈，并且收拾行囊准备离开。在这样的情况下，丽江嘉云昊队不得不由此前的教练员杨贵东代理指挥了本场比赛。&lt;/p&gt;&lt;p class="essay"&gt;在昨日丽江嘉云昊队主帅李虎就缺席了赛前的新闻发布会，当时俱乐部给出的解释是李虎由于身体欠佳，去医院接受治疗。然而今日李虎出现在俱乐部时，向记者否认了这一说法，并且坦言已经向俱乐部提出了辞呈。&lt;/p&gt;&lt;p class="essay"&gt;据记者多方了解的情况，李虎&lt;a class="weibo" href="http://www.w3school.com.cn"&gt;[微博]&lt;/a&gt;极其教练组近来在执教成绩上承受了不小的压力，在联赛间歇期期间，教练组曾向俱乐部提出能够多引进有实力的球员补强球队，然而由于和俱乐部在投入以及成绩指标上的分歧，李虎最终和教练组一起在比赛日辞职。&lt;/p&gt;&lt;p class="essay"&gt;这样的情况并没有影响到丽江嘉云昊队&lt;a class="weibo" href="http://www.w3school.com.cn"&gt;[微博]&lt;/a&gt;的队员，在比赛中丽江队在主场拼的非常凶，在暴雨之中仍然发挥出了体能充沛的优势，最终凭借点球击败了中超球队哈尔滨毅腾，顺利晋级下一轮比赛。&lt;B&gt;根据中国足协杯的赛程，丽江嘉云昊队将在本月23日迎战江苏舜天队。&lt;/B&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二.HTML基础(2)]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BA%8C-HTML%E5%9F%BA%E7%A1%80-2%2F</url>
      <content type="text"><![CDATA[1. 复习与回顾#1.1 单标签 12345&lt;!-- 文本内容--&gt; 注释标签 Ctrl+/&lt;br&gt; 换行标签&lt;hr&gt; 横线标签 1.2 双标签1234567891011121314&lt;p&gt;&lt;/p&gt; 段落标签&lt;hn&gt;&lt;/hn&gt; n 的取值 1-6 标题标签&lt;font size=”10” color=”red”&gt;&lt;/font&gt;&lt;strong&gt;&lt;/strong&gt; &lt;b&gt;&lt;/b&gt; 文本加粗&lt;em&gt;&lt;/em&gt; i 文本斜体&lt;ins&gt;&lt;/ins&gt; u 文本下横线&lt;del&gt;&lt;/del&gt; s 删除线 1.3 img标签与属性src 属性: alt 属性 : 图片无法显示，对图片的描述 title 属性: 鼠标放到图片上显示的文字 width 属性 : 宽度 height 属性 : 高度 1.4 锚链接123&lt;p id="cat"&gt;猫&lt;/p&gt;&lt;a href="#cat"&gt;抓猫&lt;/a&gt; 1.5 列表 无序列表 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表 12345&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 自定义列表 123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 2. 标签介绍2.1 Meta标签介绍 (作用在head标签) Charset ：字符集 ASCII ANSI Unicode Gbk Gb2312 Big5 作用 : 对网站进行优化的作用SEO与网址的描述. 作用 : 网址重定向 2.2 Link标签介绍 (作用在head标签) 作用 : 给网页 titile 中放置小图标 作用 : 引入外部样式表 2.3 表格 (table)作用 : 显示数据 组成 : table 定义表格 tr 行 td 列 (单元格) 属性介绍 : border : 设置表格边框 width : 设置表格宽度 Height : 设置高度 cellspacing : 设置单元格之间的距离 cellpadding : 文字距离单元格边框的距离 bgcolor=”red” : 设置背景颜色 align=center left| right : 给 td 或者 tr 设置让文字居中 table 设置表格居中 设置表格标题，用法和 td 一样 设置表格表头&lt;caption&gt; &lt;h3&gt;课程表&lt;/h3&gt;&lt;/caption&gt; 单元格的合并 横向和合并 12345&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan="2"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 纵向合并 12345&lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan="2"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 3. 表单 (from)3.1 作用表单的作用用来收集信息 3.2 组成123&lt;form action=""&gt;&lt;/from&gt; 属性 : action | 处理用户数据信息 Method : get | post Get 数据提交 : 通过地址栏的方式进行数据提交,将用户输入的信息显出来. Post 提交 : 数据通过后台进行提交,不会将用户信息显示出来,安全性比较好. 3.3 表单控件表单文字输入12用户名 : &lt;input type="text" maxlength="6"&gt;密码 : &lt;input type="password"&gt; 属性 : maxlength : 设置文本输入框最多能输多少字符 readonly=”readonly” 设置文本输入框为只读（只能读不能编辑） disabled=”disabled” 控件属于非激活的状态 name=”username” 给输入框设置名称 Value=”” 设置或者显示输入的值 单选按钮12&lt;input type="radio" name="xb" checked="checked" value="nan"&gt;男&lt;input type="radio" name="xb" value="nv" &gt;女 属性 : checked=”checked” 设置默认选中项 下拉按钮 1234567&lt;select multiple="multiple"&gt; &lt;option&gt;山东&lt;/option&gt; &lt;option&gt;山西&lt;/option&gt; &lt;option&gt;河南&lt;/option&gt; &lt;option&gt;河北&lt;/option&gt; &lt;option selected="selected"&gt;北京&lt;/option&gt;&lt;/select&gt; 属性 :selected=”selected” 设置默认选中项multiple=”multiple” 可以实现多选效果 下拉列表分组显示 12345678910111213&lt;select id="name"&gt; &lt;optgroup label="北京市"&gt; &lt;option&gt; 西城区 &lt;/option&gt; &lt;option&gt;东城区&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="山东省"&gt; &lt;option&gt; 西城区 &lt;/option&gt; &lt;option&gt;东城区&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; 多选控件 123&lt;input type="checkbox" checked="checked"&gt;java&lt;input type="checkbox"&gt;android&lt;input type="checkbox"&gt;ios 多行文本输入框 123&lt;textarea&gt;&lt;/textarea&gt; 图片上传控件1&lt;input type="file"&gt; 按钮系列1234&lt;input type="submit" value="登录"&gt;&lt;input type="button" value="普通按钮" &gt;&lt;input type="reset" value="重置按钮"&gt;&lt;input type="image" src="图片按钮.jpg"&gt;` 表单分组控件 123&lt;fieldset&gt; &lt;legend&gt;用户注册&lt;/legend&gt;&lt;/fieldset&gt; 表单补充1234567891011121314151617&lt;!-- 网址判断 --&gt;&lt;input type="url"&gt;&lt;!-- 邮箱判断 --&gt; &lt;input type="email"&gt;&lt;!-- 日期控件 --&gt;&lt;input type="date"&gt;&lt;!-- 时间控件 --&gt;&lt;input type="time"&gt;&lt;!-- 只能输入数字的控件 --&gt;&lt;input type="number" step="5"&gt;&lt;!-- 进度条 --&gt;&lt;input type="range" max="100" step="5"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一.HTML基础(1)]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%B8%80-HTML%E5%9F%BA%E7%A1%80-1%2F</url>
      <content type="text"><![CDATA[1. 认识windows快捷键 2. 认识网页2.1 网页的组成文字,图片.按钮,输入框,视频等元素组成. 2.2 Web标准 结构标准 : HTML 表现标准 : CSS 行为标准 : JS 2.3 浏览器与服务器的关系 Http : 浏览器与服务器之间传输信息的一种规范 Https : 加密处理 Url地址 : scheme://host.domain:port/filename 3. 认识HTML3.1 概述html ( Hyper Text Markup Language ) 中文译为“超文本标记语言”,主要是通过html标记对网页中的文本,图片,声音等内容进行描述. 3.2 HTML结构1234567&lt;! Doctype html&gt;&lt;html&gt; 根标签&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; &lt;! Doctype html&gt; 文档类型 html 文档头部分 网页的标题 html 结构的主体部分 3.3 标签的分类 单标签：只有开始标签没有结束标签例如：&lt;! Doctype html&gt; 双标签：有开始标签和有结束标签`例如： 3.4 标签关系分类 并列关系（兄弟）&lt;head&gt;&lt;/head&gt; | &lt;body&gt;&lt;/body&gt; 嵌套关系（包含）&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; 4. sublime的常用快捷键 快捷键 说明书 Ctrl+shift+D 快速复制 Ctrl+L 快速选中 Ctrl+鼠标左键 集体输入 Ctrl+h 查找替换 Ctrl+f 标签查找 Ctrl+shift+↑(↓) 整体移动 5. Html 标签介绍5.1 单标签 文本注释标签&lt;!--hello, world!--&gt; 文本换行标签&lt;br&gt; 横线标签&lt;hr&gt; 5.2 双标签 段落标签&lt;p&gt;hello,world!&lt;/p&gt; 标题标签(数字只能取1~6)&lt;h1&gt;&lt;/h1&gt; 文本标签&lt;font&gt;&lt;/font&gt; 文本格式化标签 文字加粗显示&lt;strong&gt;&lt;strong&gt;&lt;b&gt;&lt;/b&gt; 文字斜体&lt;em&gt;&lt;/em&gt;&lt;i&gt;&lt;/i&gt; 文字删除线&lt;del&gt;&lt;/del&gt;&lt;s&gt;&lt;/s&gt; 文字下划线标签&lt;ins&gt;&lt;/ins&gt;&lt;u&gt;&lt;/u&gt; 5.3 图片标签&lt;img&gt; 属性 : Src: 设置显示图片（图片名称或者图片路径）Title：用来设置鼠标方到图片上显示的文字Alt：当图盘无法正常显示的时候，对图片的描述Width: 用来设置图片宽度Height: 用来设置图片高度 5.4 相对路径 当图片和文件（html）在同一文件夹中&lt;img src=&quot;1.jpg&quot;&gt; 当图片在文件（html）的下一级目录中`&lt;img src=&quot;1/1.jpg&quot;&gt; 当图片在文件（html）的上一级目录中&lt;img src=&quot;../图片所在文件夹名/1.jpg&quot;&gt; 5.5 绝对路径凡是带有磁盘路径的都是绝对路径或者带有网站地址的也是绝对路径 5.6 超链接&lt;a href=&quot;http://www.itceo.net&quot;&gt;我是程序员&lt;/a&gt;&lt;a href=&quot;itceo.html&quot;&gt;我是程序员&lt;/a&gt;属性 : Title: 当鼠标放到超链接上显示的文字target=”_self” 默认值网页在当前页面中打开target=”_blank” 网页在新窗口中打开 5.7 锚链接介绍 任何一个标签设置 id 属性,并取值&lt;p id=&quot;cat&quot;&gt;猫&lt;/p&gt; 给 a 标签设置 href 属性 “#id 名称”&lt;a href=&quot;#cat&quot;&gt;抓猫&lt;/a&gt; 5.8 简单的下载功能a 标签中通过给 href 属性设置一个压缩文件,即可实现下载功能. 5.9 超链接不跳转&lt;a href=&quot;#&quot;&gt;NULL&lt;/a&gt; 5.10 特殊字符 6. 列表6.1 无序列表（ul ）12345&lt;ul&gt;&lt;li&gt;&lt;/li&gt; 列表项&lt;li&gt;&lt;/li&gt;......&lt;/ul&gt; 属性介绍 : type=”square” 小方块显示type=”circle” 小圆圈 6.2 有序列表（ol ）1234&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 6.3 自定义列表（dl ）123456&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt; 小标题&lt;dd&gt;&lt;/dd&gt; 列表项&lt;dd&gt;&lt;/dd&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 7. 总结&lt;embed src=&quot;1.mp3&quot; hidden=&quot;true&quot;&gt;放置背景音乐&lt;marquee&gt;页面自动滚动效果&lt;/marquee&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第13章 运行时压缩]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC13%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9%2F</url>
      <content type="text"><![CDATA[1. 数据压缩经过压缩的文件若能100%恢复,就称该压缩为”无损压缩”(Lossless Data Compression) ;若不能恢复原状,称之为”有损压缩”(Loss Data Compression). 1.1 无损压缩它们最根本的压缩理念也是Run-Lenght, Lempel-Ziv, Huffman, 然后应有了一些各自特有的技术(压缩率,压缩/解压时间). 1.2 有损压缩有损压缩允许压缩文件(数据)时损失一定信息,以此换取高压缩率. 2. 运行时压缩器 项目 普通压缩 运行时压缩 对象文件 所有文件 PE文件(exe,dll,sys) 压缩结果 压缩文件(zip,rar) PE文件(exe,dll,sys) 解压缩方式 使用专门解压缩程序 内部含有解码程序 文件是否可执行 本身不可执行 本身可执行 优点 可以对所有文件以高压缩率压缩 无须专门解压缩程序便可直接运行 缺点 若无专门解压缩软件则无法使用压缩文件 每次运行均需要解码程序导致运行时间过长 把普通PE文件创建后运行时压缩文件的实用程序称为”压缩器(Packer)”.经反逆向(Anti-Reversing)技术特别处理的压缩器称为保护器(Protector). 2.1 压缩器PE压缩器是指可执行文件的压缩器,称为”运行时压缩器”,它是PE文件的专用压缩器. 实用目的压缩PE文件的大小,便于网络传输保存隐藏PE文件内部代码与资源压缩后的数据以难以辨认的二进制保存,从文件本身来看,还能有效隐藏内部代码与资源. 使用现状 现状的实用程序,”打补丁”文件,普通程序都广泛应用运行时压缩. 压缩器种类PE压缩器大致分两类 : 一类是单纯用于压缩普通PE文件的压缩器;另一类是对源文件进行较大变形,严重破坏PE头的压缩器. 2.2 保护器不但像普通压缩器一样仅对PE文件进行运行时压缩,而应用了多种防止代码逆向分析的技术. 使用目的防止破解,保护代码与资源. 使用现状安全保护程序为了防止恶意破解而使用各种保护器来保护自己,常见的恶性代码中也大量使用保护器来防止(或减少)杀毒软件的检测.有些保护器还提供”多变的代码”,每次都会生成不同形态(但功能相同)的代码,这给病毒诊断带来很大的困难. 保护器种类保护器种类多样,有公用程序,商业程序,还有专门提供而已代码使用的保护器. 3. 运行时压缩测试用压缩器UPX压缩notepad.exe,比较了下文件状态. 比较notepad.exe与notepad_upx.exe PE头的大小一样(0~400h) 节区名称改变(“.text-&gt;”upx0”,”.data”-&gt;”upx1”). 第一个节区的RawDataSize=0(文件中的大小为0). EP位于第二个节区(原notepad.exe的EP在第一个节区). 资源节区(.rsrc)大小几乎无变化. 我们用PEView查看第一个节区头,如图. 从VirtualSize值可以发现问题,第一个节区的VirtualSize值竟被设置为10000(而SizeOFRawData值为0).也就是说,经过UPX压缩后的PE文件在运行瞬间将(文件中)压缩的代码解压到(内存中的)第一个节区.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第12章 PE文件格式]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC12%E7%AB%A0-PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1. 介绍PE文件是Window操作系统下使用的可执行文件格式.PE文件是指32位的可执行文件,也称为PE32.64位的可执行文件称为PE+或PE32+,是PE(pe32)文件的一种扩展形式. 2. PE文件格式 种类 主扩展名 可执行系列 EXE / SCR 库系列 DLL / OCX / CPL / DRV 驱动程序系列 SYS / VXD 对象文件序列 OBJ OBJ(对象)文件之外的所有文件都是可执行文件,DLL / SYS 文件等虽然不能直接在Shell(Explorer.exe)中运行,但可以使用其它方法执行. 下面以打开notepad.exe为例,notepad.exe文件运行需要的所有信息都存储在PE头中,如果加载到内存,从何处开始运行,运行中需要什么DLL,有哪些堆栈内存等,大量信息以结构体形式存储在PE头中, 学习PE文件格式就是学习PE头中的结构体. 2.1 基本结构从 DOS 头(Dos header)到节区头(Section header)是PE头部分,其下的节区合称PE体.文件中使用偏移(offset),内存中使用VA(Virtual Address ,虚拟地址)来表示位置.文件加载到内存时,情况就会发生变化(节区的大小,位置等).文件的内容一般可分为代码(.text) / 数据(.data) / 资源(.rsrc)节,分别保存. 各节区头定义了各节区在文件或内存中的大小,位置,属性等. PE头与各节区的尾部存在一个区域,称为NULL填充(NULL padding).在计算机中,为了提高处理文件,内存,网络包的效率.文件 / 内存中各节区的起始位置应该在各个文件 / 内存 最小单位的倍数位置上,空白区域将用NULL填充. 2.2 VA &amp; RVAVA指的是进程虚拟内存的绝对地址,RVA(Relative Virtual Address,相对虚拟地址)指从某个基准位置(ImageBase)开始的相对地址.VA 与 RVA 满足下面的换算关系.RVA + ImageBase = VAPE头内部信息大多以RVA形式存在.原因在于,PE文件(主要是DLL)加载到进程虚拟内存的特定位置时,该位置可能已经加载了其他PE文件(DLL).此时必须通过重定位(Relocation)将其加载到其他空白的位置,若PE头信息使用的是VA,则无法正常访问,因此使用RVA来定位信息,即是发生了重定位,只要相对于基准位置的相对地址没有变化,就能正常访问到指定信息,不会出现任何问题. 3. PE头3.1 DOS 头在PE头的最前面添加了一个IMAGE_DOS_HEADER结构体,用来扩展已经有的DOS EXE头. 123456789101112131415161718192021typedef struct _IMAE_DOS_HEADER &#123; //DOS .EXE header 位置 WORD e_magic; //Magic number; 0x00 WORD e_cblp; //Bytes on last page of file 0x02 WORD e_cp; //Pages in file 0x04 WORD e_crlc; //Relocations 0x06 WORD e_cparhdr; //Size of header in paragraphs 0x08 WORD e_minalloc; //Minimum extra paragraphs needed 0x0A WORD e_maxalloc; //Maximum extra paragraphs needed 0x0C WORD e_ss; //Initial (relative) SS value 0x0E WORD e_sp; //Initial SP value 0x10 WORD e_csum; //Checksum 0x12 WORD e_ip; //Initial IP value 0x14 WORD e_cs; //Initial (relative) CS value 0x16 WORD e_lfarlc; //File address of relocation table 0x18 WORD e_ovno; //Overlay number 0x1A WORD e_res[4]; //Reserved words 0x1C WORD e_oemid; //OEM identifier (for e_oeminfo) 0x24 WORD e_oeminfo; //OEM information; e_oemid specific 0x26 WORD e_res2[10]; //Reserved words 0x28 LONG e_lfanew; //File address of new exe header 0x3C&#125; IMAGE_DOS-HEADER, *PIMAGE_DOS_HEADER; IMAGE_DOS_HEADER 结构体的大小为40个字节,从该结构体必须知道两个重要成员,第一个字段e_magic与最后一个字段e_lfanew. e_magic : DOS签名(signature, 4D5A=&gt;ASCII值”MZ”)e_lfanew : 指示NT头的偏移(根据不同文件拥有可变值). 所有PE文件在开始部分(e_magic)都有DOS签名(“MZ”).e_lfanew值指向NT头所在位置(NT头的名称在IMAGE_DOS_HEADERS). 使用 Hex Editor 打开 notepad.exe ,查看IMAGE_DOS_HEADERS结构体. 根据 PE 规范,文件开头的2个字节为4D5A,e_lfanew值为000000E0,假若修改了这些值,可以发现程序无法正常运行,因为根据PE的规范它已经不是PE文件了. 3.2 DOS 存根DOS存根(stub)在DOS头下方,是个可选项,且大小不固定(即使没有DOS存根,文件也能正常运行).DOS存根由代码与数据混合而成. 文件偏移40~4D区域为16位的汇编指令. 打开命令窗口,输入debug c:\windows\notepad.exe 3.3 NT 头123456typedef struct _IMAGE_DOS_HEADER&#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_ OPTIONAL_HEADER32 OptionalHeader;&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER32; IMAGE_DOS_HEADERS结构体由三个成员组成, 第一个成员的签名为(Signature)结构体,其值为50450000h(“PE”00).另外两个成员分别为文件头(File Header)与可选头(Optional Header)结构体. 3.4 NT头 : 文件头12345678910typedef struct _IMAGE_DOS_HEADER&#123; WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics;&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER32; IMAGE_DOS_HEADERS结构体中有以下四种重要成员(若设置不对,不能正常运行.) Machine每个CPU都拥有唯一的Machine码,兼容32位 Intel x86 芯片的Machine码为14C. NumberOfSectionsNumberOfSections用来指出文件中存在的节区数量.该值一定要大于0,且当定义的节区数量与实际节区不同时,将发生运行错误. SizeOfOptionalHeaderIMAGE_DOS_HEADERS结构体的最后一个成员为IMAGE_DOS_HEADER32结构体.SizeOfOptionalHeader成员用来指定出IMAGE_DOS_HEADER32结构体的长度.IMAGE_DOS_HEADER32结构体由C语言编写而成,故其大小已确认.但是Windows的PE装载器需要查看IMAGE_DOS_HEADER的SizeOfOptionalHeader值,从而识别出IMAGE_DOS_HEADER32结构体的大小. Characteristics 该字段用来标识文件的属性,文件是否可以运行状态,是否为DLL文件等信息.以 bit OR 形式组合起来. 3.5 NT头 : 可选头在IMAGE_DOS_HEADER32结构体中需要关注以下成员,这些值文件是必须运行的,设置错误将导致文件无法正常运行. Magic为IMAGE_DOS_HEADER32结构体时,Magic码为10B;为IMAGE_DOS_HEADER64结构体时,Magic码为20B; AddressOfEntryPointAddressOfEntryPoint持有EP的RVA值,该值指出程序最先执行的代码起始地址,相当重要. ImageBase进程虚拟内存的范围是 0~FFFFFFFF(32位系统).PE文件被加载到如此大的内存中时,ImageBase指出文件的优先载入地址. EXE,DLL文件被装载到用户内存的0~7FFFFFFF中,SYS文件被载入内核内存的80000000~FFFFFFFF中. SectionAlignment,FileAlignmentPE文件的Body部分划分为若干节区,这些节存储着不同类别的数据.FileAlignment指定了节区在磁盘文件中的最小单位,而SectionAlignment则指定了节区在内存中最小单位.磁盘文件或内存的节区大小必定为FileAlignment或SectionAlignment值的整数倍. SizeOfImage加载到PE文件到内存时,SizeOfImage指定了PE Image在虚拟内存中所占空间的大小. SizeOfHeaderSizeOfHeader用来指定整个PE头的大小,该值也必须是FileAlignment的整数倍. SubSystem 该SubSystem值用来区分系统驱动文件(.sys)与普通的可执行文件(.exe,*.dll).Subsystem成员可拥有的值如表. 值 含义 备注 1 Driver文件 系统驱动(如:ntfs.sys) 2 GUI文件 窗口应用程序(如:notepad.exe) 3 CUI文件 控制台应用程序(如:cmd.exe) NumberOfRvaAndSizeNumberOfRvaAndSize用来指定DataDirectory(IMAGE_OPTIONAL_HEADER32结构体的最后一个成员)数组的个数. DataDirectoryDataDirectory是由IMAGE_DATA_DIRECTORY结构体组成的数组,数组的每项都要被定义的值. IMAGE_OPTIONAL_HEADER HEX Editor 描述的是notepad.exe的IMAGE_OPTIONAL_HEADER结构体区域. 3.6 节区头把具有相拟属性的数据统一保存在一个被称为”节区”的地方,然后需要把各节区属性记录在节区头中. 需要为每个code/data/resource分别设置不用的特性,访问权限等.类别| 访问权限—|—code| 执行,读取权限data | 非执行,读取权限resource | 非执行,读取权限 IMAGE_SECTION_HEADER节区头是由IMAGE_SECTION_HEADER结构体组成的数组,每个结构体对应一个节区. 4. RVA TO RAWPE文件加载到内存时,每个节区都要能准确完成内存地址与文件偏移间的映射.这种映射一般称为 RVA to RAW. 查找RVA所在节区. 换算公式RAW - PointtoRawData = RVA - VirtualAddressRAW = RVA - VirtualAddress + PointtoRawData 5. IATIAT (Import Address Table,导入地址表).IAT保存的内容与Windows操作系统的核心进程,内存,DLL结构等有关.简单理解 : IAT是一种表格,用来记录程序正在使用那些库中的那些函数. 5.1 DLL 不要把库包含到程序中,单独组成DLL文件,需要时调用即可. 内存映射技术使加载后的DLL代码,资源在多个进程中实现共享. 更新库时只要替换相关DLL文件即可. 加载DLL文件时有两种方式 : 一种是”显式链接”(Explicit Linking),程序使用DLL时加载,使用完毕后释放内存;另一种是”隐式链接(Implicit Linking)”,程序开始时即一同加载DLL,程序终止时再释放占用的内存. 5.2 IMAGE_IMPORT_DESCRIPTORIMAGE_IMPORT_DESCRIPTOR结构体中记录着PE文件要导入那些库文件. 提示Import : 导入,向库提供服务(函数)Export : 导出,从库向其他PE文件提供服务(函数)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第11章 Tut.ReverseMe1]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC11%E7%AB%A0-Tut-ReverseMe1%2F</url>
      <content type="text"><![CDATA[1. 运行弹出消息对话框,显示2条信息. 删除所有烦人的Nags 查找registration code 2. 分析2.1 目标(1) : 去除消息框使用OllyDbg打开文件,从00401162地址处看到主函数ThunRTMain. 要去除消息框,只要操作调用消息框的函数部分.Visual Basic中调用消息框的函数为MSVBVM50.rtcMsgBox. 在OllyDbg中使用鼠标右键菜单的Search for-All intermodular calls命令,将会列出程序中调用的API目录. 根据函数名称排序,共有四处调用要找到的函数rtcMsgBox.选择鼠标右键菜单中的Set breakpoint on every call to rtcMsgBox菜单,在所有调用rtcMsgBox的代码处设置断点,如图. 然后在调试器中按F9键运行程序,程序运行到设有断点的地方停下来. 向上拉一下滚动条,可以看到消息框显示的字符串,该部分就是程序开始运行时用来显示消息框的代码部分. 2.2 打补丁(1) : 去除消息框第一次尝试先修改402CFE地址处的CALL命令,如下图示. 修改后,402CFE地址处的ADD,ESP,14命令的含义是,按照传递给rtcMsgBox()参数的大小(14)清理栈.并用NOP填充其余两个字节,以保证代码不会乱(原来CALL命令的大小为5个字节,ADD命令用3个字节,还余下2个字节). 但这样修改是错误的,原因是没有正确处理rtcMsgBox()函数的返回值(EAX寄存器). 第二次尝试 可以看到402C17地址处表示函数开始的栈帧prologue. 402CFE的rtcMsgBox函数调用代码也是属于其他函数内部的代码.所以如果上层函数无法调用,或直接返回.最终将不会调用rtcMsgBox函数.像下面这样修改401C17处的指令 注意要根据传递给函数的参数大小调整栈(RETN XX). 此时就成功去除消息框. 2.3 目标(2) : 查找注册码随便输入一个abcd1234,会弹出错误消息框. 在OllyDbg中检索消息字符串,查看402A69地址处的代码,双击鼠标得到. 看图中代码,402A2A地址处有`I&#39;mlena151字符串,其下方的402A2F地址处是vbaStrCmp()函数调用代码.vbaStrCmp()API是VB中比较字符串的函数,在本例中用于比较用户输入的字符串与I&#39;mlena151字符串作为比较,我们再向上拖动滚动条. 在4028BD处也存在I&#39;mlena151字符串,可以肯定该字符串就是正确的注册码.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第10章 函数调用约定]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC10%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%2F</url>
      <content type="text"><![CDATA[1. 函数调用约定Calling Convention ,它是对函数调用时如何传递参数的一种约定.调用函数前先要把参数压入栈然后再传递给函数.栈就是定义在进程中的一段内存空间,向下(低地址方向)扩展,且其大小被记录在PE头中.也就是说,进程运行时确定栈内存的大小(与malloc/new动态分配内存不同). 函数执行完毕后,栈中的参数如何处理?由于只是临时使用存储在栈中的值,即使不再使用,清除工作也会浪费CPU资源.下一次再向栈存入其他值时,原有值会被自然覆盖掉,并且栈内存是固定的,所以既不能也没必要释放内存. 函数执行完毕后,ESP值如何变化?ESP值要恢复到函数调用之前,这样可引用的栈大小才不会减缩.栈内存是固定的,ESP用来指定栈的当前位置,若ESP指向栈底,则无法再使用该栈.函数调用后如何处理ESP,这就是函数用来约定要解决的问题.主要的函数调用约定如下. cdecl stdcall fastcall 术语说明调用者 == 调用函数的一方.被调用者 == 被调用的函数.比如在 main()函数中调用printf()函数时,调用者为main(),被调用者为printf(). 1.1 cdeclcdecl是主要在C语言中使用的方式,调用者负责处理栈. 1234567891011#include "stdio.h"int add(int a, int b)&#123; return (a + b);&#125;int main(int argc, char* argv[])&#123; return add(1, 2);&#125; 用OllyDbg调试cdecl.exe文件,从图中可以看到401013~40101C地址间的代码可以发现,add()函数的参数1,2与逆序方式压入栈,调用add()函数(401000)后,使用 ADD ESP,8命令整理栈.调用者main()函数直接清理其压入栈的函数参数,这样的方式就是cdecl. 提示cdecl方式的好处在于,它可以像C语言中的printf()函数一样,向被调用函数传递长度可变的参数.这种长度可变的参数在其他调用约定中很难实现. 1.2 stdcallstdcall方式常用语Win 32 API,该方式由被调用者清理栈.因C语言中默认的函数调用方式为cdecl.若想使用stdcall方式编译源码,只能使用_stdcall关键字即可. 1234567891011#include "stdio.h"int _stdcall add(int a, int b)&#123; return (a + b);&#125;int main(int argc, char* argv[])&#123; return add(1, 2);&#125; 用OllyDbg调试stdcall.exe文件,从图中可以看到,在main()函数中调用add()函数后,省略了清理栈的代码(ADD ESP,8). 栈的清理工作由add()函数中最后(40100A)的 RETN 8 命令来执行. RETN 8 命令的含义是 RETN + POP8字节,即返回后使用ESP增加指定空间. stdcall方式的好处在于,被调用者函数内部存在着栈清理代码,与每次调用函数时都要用ADD ESP,XXX命令的cdecl命令相比,代码尺寸更小.虽然 Win32 API 是使用C语言编写的,但其采用的方式是stdcall方式. 1.3 fastcallfastcall方式与stdcall方式基本类似,但该方式通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数.若某函数有4个参数,则前两个参数分别使用ECX,EDX寄存器传递. fasgcall方式的优势在于可以实现对函数的快速调用(因为从CPU的立场看,访问寄存器的速度要远比内存快得多.)单从函数调用本身来看,fastcall方式非常快,但是有时需要额外的系统分销来管理ECX,EDX寄存器.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第9章 Process Explorer - 最优秀的进程管理工具]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC9%E7%AB%A0-Process-Explorer-%E6%9C%80%E4%BC%98%E7%A7%80%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[1. Process ExplorerProcess Explorer 是 Windows 操作系统下最优秀的进程管理工具. 2. 具体有哪些优点呢? Process / Child 进程树结构. 以不同颜色显示进程运行/终止. 进程终止 (kill) 功能 (支持Kill Process Tree) 功能. 检测 DLL/Handle (检索加载到进程中的DLL或进程占有的句柄).]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第8章 abex'crackme#2]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC8%E7%AB%A0-abex-crackme-2%2F</url>
      <content type="text"><![CDATA[1. 运行abex’crackme#2 输入合适的Name与Serial,按Check按钮,会弹出错误的消息框! 2. Visual Basic文件的特征2.1 VB专用引擎 举个VB引擎的例子,显示消息框时,VB代码中要调用MsgBox()函数.其实,VB编辑器真正调用到的MSVBVM60.dll里的rtcMsgBox()函数,在该函数内部通过调用user32.dll里的MessageBoxW()函数(Win32 API)来工作(也可以在VB代码中直接调用user32.dll里的MessageBoxM()). 2.2 本地代码和伪代码VB文件可以编译为本地代码 (N code) 与伪代码 (P code) .本地代码一般使用易于调试器解析的IA-32指令;而伪代码是一种解析器 (Interpreter) 语言,它使用由VB引擎实现虚拟机并自解析的指令 (字节码) .因此,若想准确解析VB的伪代码,就需要分析VB引擎并实现模拟器. 2.3 事件处理程序VB主要用来编写GUI程序,由于VB程序采用windows操作系统的事件驱动工作,所以在main()或winmain()中并不吃存在用户代码(希望调试的代码),用户代码存在于各个事件处理程序(event handler)之中. 就上述abex’crackme#2而言,用户代码在点击check按钮时触发的事件处理程序内. 2.4 未文档化的结构体 VB中使用的各种信息 (diglog,control,form,module,function等) 以结构体形式保存在文件内部.由于微软未作公开这种结构体信息,所以调试VB文件会难一些. 3. 开始调试运行OllyDbg,查看abex’crackme#2文件的反汇编代码 执行程序后,在EP代码中首先要做的是调用VB引擎的主函数 (ThunRTMain()). EP的地址为401238.401238地址处的PUSH 401E14命令用来把RT_MainStruct结构体的地址(401E14)压入栈.然后40123D地址处的CALL 00401232命令调用401232地址处的的JMP DOWRD PTR DS:[4010A0]指令.该JMP指令会跳转至VB引擎的主函数ThunRTMain()(前面压入栈的401E14的值作为ThunRTMain()的参数.) 3.1 间接调用40123地址处的CALL 401232命令用于调用ThunRTMain()函数,这里使用了较为特别的技法.不是直接转到MSVBVM60.dll里的ThunRTMain()函数,而是通过中间401232地址处的JMP指令跳转. 这就是VC++,VB编译器中常用的间接调用法 (Indirect Call). 4010A0地址是IAT (Import Address Table,导入地址表)区域,包含着MSVBVM60.ThunRTMain()函数的实际地址. 3.2 RT_MainStruct结构体要注意的是ThunRTMain()函数的参数RT_MainStruct结构体.这里,RT_MainStruct结构体存在于401E14地址处.VB引擎通过参数传递过来的RT_MainStruct结构体获取到程序运行需要的所有信息. 3.3 ThunRTMain()函数 4. 分析crackme目前找RT_MainSturct结构体非容易之事,我们借助思路查找错误消息框和字符串. 4.1 检索字符串 双击相应字符串,转到其他地址处. 消息框的标题(“Wrong serial!”),内容(“Nope,this serial is wrong!”),还有实际调用信息框函数的代码(4034A6)都显示出来了. 从编程的观点来看,使用某种算法生成序列号,通过比较用户输入的序列号与字符串,代码分为TRUE(序列号相同)与FALSE(序列号不同)两大部分.通俗点说,就是前后存在的字符串比较代码.且序列号正确时程序代码会调用消息框输出成功信息. 往上拖动滚动条,在前面看到了条件转移语句的代码. 调用403329地址的_vbaVarTstEq()函数,比较(Test命令)返回值(AX)后,由403332地址的条件转移指令(JE指令)决定执行”真”代码还是”假”代码. 上述代码使用的汇编指令说明 Test : 逻辑比较 (Logical Compare)与bit-wise logical”AND”一样(仅改变EFLAGS寄存器而不改变操作数的值)若两个操作数中一个为0,则AND运算结果被置为0-&gt;ZF=1. JE : 条件跳转指令 (Jump if equal), 若ZF=1,则跳转. 4.2 查找字符串地址403329地址处的_vbaVarTstEq()函数为字符串比较函数,起上方的2个PUSH指令为比较函数的参数,即比较字符串. 调试至403329 00403321地址处的SS:[EBP-44]表达的是 : SS是栈段,EBP是基址指针寄存器.换言之,SS:[EBP-44]指的是栈内地址,它恰好又是函数中声明的局部对象的地址(局部对象存储在栈内).在此状态下查看栈.(栈地址会随调试的环境不同而改变) EDX表示实际的地址,EAX表示用户输入的地址. 我们选择数据窗口,长型查看实际的字符串. 我们重新运行程序,输入Name=”kevin”,Serial=”CFC9DACD”并提示破解成功! 但是Name和Serial之间什么关系呢?为了测试我们输入Name的另外一个值,Serial保存不变.程序显示错误!这就证明了最初的判断 : “以name字符串为基础随时生成Serial”的算法. 4.3 生成Serial的算法查找函数开始部分 很显然条件转移代码属于某个函数,该函数可能就是Check按钮的事件来处理程序.原因在于选择Check按钮后,该函数会被调用执行.且含有用户代码来弹出成功/失败消息框. 我们向上查找函数开始部分,仔细查看00402ED0地址处的命令. 上述代码是栈帧代码,开始执行函数就会形成栈帧.由此得知该位置就是函数开始部分,即是Check按钮事件的处理程序. 汇编指令VB文件的函数之间存在着NOP指令.NOP指令表示不执行任何动作的指令. 为了准确分析代码,在402ED0位置处下断点后调试. 4.4 预测代码 若是Win32 API程序,则有如下特点. 读取Name字符串 (使用GetWindowText / GetDlgItemText 等API). 启动循环,对字符加密 (XOR / ADD / SUB等). 上述代码使用VB引擎函数编写而成,若预测正确,在事件处理程序开始代码开始调试.查找读取Name字符串的部分后,接着就是出现加密循环. 4.5 读取Name字符串的代码 查看00402F8E地址处的代码可以看到,函数的局部对象ss:[ebp-0x88]地址传递给(PUSH)函数的参数.查看该地址.先在00402FA0处下一个断点然后选中跟随数据 Name字符串(以字符串对象形式)存储到[EBP-88]地址处. 4.6 加密循环继续调试,遇到如下循环,即一系列循环语句. 简单的动作原理为 : 链表中使用next指针引用下一个元素,并且设置EBX,4 使其按指定的次数运转循环. 实际仅使用了接收的Name字符串中的4个字符.在代码内检查字符串的长度,若少于4个字符,就会弹出错误消息框. 4.7 加密方法 从该给定的Name字符串前端逐一读取字符(共4次). 将字符转换为数字(ASCII代码). 向变换后的数字加64. 再次将数字转换为字符. 连接变换后的字符. 5. 总结通过”Wrong serial”字符串作为目标,然后查找该字符串的代码.从查找的代码开始,向上拖动滑动条.找到生成栈帧(函数开始)的部分.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第7章 栈帧]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC7%E7%AB%A0-%E6%A0%88%E5%B8%A7%2F</url>
      <content type="text"><![CDATA[栈帧 (Stack Frame) ,在程序中用于声明局部变量/调用函数. 1. 栈帧栈帧就是利用EBP (栈帧指针) 寄存器访问栈内局部变量,参数,函数返回地址等的手段.ESP寄存器承担着栈顶指针的作用,而EBP寄存器则负责栈帧指针的职能.程序运行时,ESP寄存器的值随时变化,访问栈中函数的局部变量,参数时,若以ESP值为基准编写程序会十分困难,并且以很难使CPU引用到准确的地址.所以,调用某函数时,先要把用作基准点 (函数起始地址) 的ESP值保存到EBP,并维持在函数内部.这样,无论ESP的值如何变量,以EBP的为基准 (base) 能够安全访问到相关的函数的局部变量,参数,返回地址,这就是EBP寄存器作为栈帧指针的作用. 2. 调试示例: StackFrame.exe2.1 StackFrame.cpp1234567891011121314151617#include "stdio.h"long add(long a, long b)&#123; long x = a, y = b; return (x + y);&#125;int main(int argc, char* argv[])&#123; long a = 1, b = 2; printf("%d\n", add(a, b)); return 0;&#125; 使用OllyDbg调试工具打开StackFrame.exe文件,按CTRL+G快捷键 (Go to命令) 转到401000地址处. 2.2 开始执行 main() 函数&amp;生成栈帧 首先在StackFrame.cpp源程序的主函数分析,代码如下.int main(int argc, char* argv[]){ 函数main()是程序开始执行的地方,在main()函数的起始地址(401020)处,按F2键设置一个断点,然后按F9运行程序,程序运行到main()函数的断点处暂停. 当前ESP的初始值为0019FF3C,EBP的值为0019FF80.切记地址401250保存在ESP(0019FF3C)中,它是main()函数执行完毕后返回的地址. main()函数一开始运行就生成与其对应的函数栈帧. 00401020 push ebp ; # main() PUSH是一条压栈指令,上面这条PUSH语句的含义是”把EBP值压入栈”.main()函数中,EBP为栈帧指针,用来把EBP之前的值备份到栈中 (main()函数执行完毕,返回之前,该值会再次恢复). 00401021 mov ebp,esp MOV是一条数据传送命令,上面这条MOV语句的命令是”把esp值传送到ebp”.换原之,就是两值相等,并且直到main()函数执行完毕,EBP的值始终保持不变.也就是说,我们通过EBP可以安全访问到存储在栈中的函数参数与局部变量.执行完401020与401021地址处后的两条命令后,函数main()的栈帧就生成了. 进入OllyDbg的栈窗口,单击鼠标右键,在弹出的菜单中依次选择Address-Relative to EBP,把地址转换为相对于EBP的偏移后,能够直接观察到栈内情况. 如图,当前EBP值为0019FF38,与ESP的值一致,19FF80地址处保存着19FF80,它是main()函数开始执行时EBP持有的初始值. 2.3 设置局部变量 下面开始分析源文件StackFrame.cpp中的变量声明与赋值语句. long a = 1, b = 2; main()函数中,上述语句用于在栈中为局部变量(a,b)分配空间,并赋初始值. 00401023 sub esp,0x8 SUB是汇编语言中的一条减法指令,上面这条语句用来将ESP的值减去8个字节.执行该指令前ESP的值为:0019FF38,执行后变为:0019FF30.为什么要减去8个字节,其实质为函数的局部变量 (a与b)开辟空间,以便将它们保存在栈中.由于局部变量a与b都是long型,它们分别占据4个字节大小,所以需要在栈中开辟8个字节的空间来保存这2个变量. 使用SUB指令从ESP中减去8个字节,为2个函数变量开辟栈空间后,在main()内部,无论ESP的值如何变化,变量a与b的栈空间都不会受到损坏.由于EBP的值在main()函数内部是固定不变的,我们就能以它作为基准来访问函数的局部变量了. 1200401026 mov [EBP-4],1 ; [EBP-4] = local &apos;a&apos;0040102D mov [EBP-8],2 ; [EBP-8] = local &apos;b&apos; 分析上面的2条MOV命令,它们的含义是”把数据1与2分别保存到[local.1]与[local2]中”. 2.4 add()函数参数传递与调用 StackFrame.cpp源代码中使用如下语句调用add()函数,执行加法运算并输出函数返回值. printf(“%d\n”, add(a, b)); 请看上面5行汇编代码,它描述了调用add()函数的整个过程.地址40103C处为”CALL 401000”命令,该命令用于调用401000处的函数,而401000处的函数即为add()函数.函数add()接收a,b这2个长整型参数,所以调用add()之前先把2个参数压入栈, 地址401034~40103B之间的代码即用于此.参数入栈的顺序与C语言源码中的参数顺序刚好相反.换言之,变量b首先入栈,接着变量a再入栈.执行完地址401034~40103B之间的代码后,栈内变化情况所示. 接下来进入add()函数(401000)内部,分析整个函数调用过程. 返回地址执行CALL命令进入被调用的函数之前,CPU会先把函数的返回地址压入栈,用作函数执行完毕后的返回地址.在地址处调用了40103C处调用了add()函数,它的下 一条命令的地址为401041.函数add()执行完毕后,程序执行完返回到401041地址处,该地址即被称为add()函数的返回地址.执行完40103C地址处的CALL命令后进入函数,栈内情况如图: 2.5 开始执行add()函数&amp;生成栈帧 StackFrame.cpp源代码中,函数add()的前2行代码如下:long add(long a, long b){ 函数开始执行时,栈中会单独生成与其对应的栈帧. 120040100 push ebp 00401001 mov ebp,esp 上述2行代码与开始执行main()函数时的代码完全相同,先把EBP值保存到栈中,再把当前的ESP存储到EBP,这样函数add()的栈帧就生成了. 可以看到,main()函数使用的EBP值(19FF38)被备份到栈中,然后EBP的值被设置为一个新值19FF20. 2.6 设置add()函数的局部变量(X,Y) StackFrame.cpp源代码中. long x = a, y = b; 上面一行语句声明了2个长整型的局部变量(X,Y),并使用2个形式参数(a,b)分别为它们进行赋值初始. 00401003 sub esp,0x8 在栈内存中为局部变量X,Y开辟8个字节的空间. 123456700401006 mov eax,[arg.1] //a00401009 mov [local.2],eax //x0040100C mov ecx,[arg.2] //b0040100F mov [local.1],ecx //y 2.7 ADD 运算 StackFrame.cpp源代码中,下面这条语句用于返回2个局部变量之和. return (x + y); 12300401012 mov eax,[local.2] //语句执行完毕,变量X的值会被传送到EAX00401015 add eax,[local.1] //变量Y 上述这条语句中,变量Y与EAX的原值(X)相加,且运算结果被存储到EAX中,运算完后EAX的值为3. 2.8 删除函数add()的栈帧&amp;函数执行完毕(返回) “删除函数栈帧与函数执行完毕返回”对应于StackFrame.app文件中的如下代码. return (x + y);} 执行完加法运算后,要返回函数add(),在此之前要先删除函数add()的栈帧. 00401018 mov esp,ebp 上面这条命令将当前的EBP赋值给ESP,等价于将EBP中的值恢复到ESP中. 提示执行完上面的命令后,地址401003处的SUB ESP,8命令失效,即是函数里面的局部变量不再有效. 0040101A pop ebp 上面这条命令用于恢复函数add()开始执行时备份到栈中的EBP值,它与401000地址处的PUSH EBP 命令对应.EBP值恢复为0019FF38,它是main()函数的EBP值.到此,add()函数的栈帧就被删除了. 可以看到ESP的值为:0019FF24,该地址值位:401041,它是执行CALL 401000命令时CPU存储到栈中的返回地址. 0040101B retn 执行上述语句,存储在栈中的返回地址被返回. 2.9 从栈中删除函数add()的参数 (整理栈)00401041 add esp,0x8 函数add()执行完毕后,就不需要参数a与b了,所以要把esp加上8,将它们从栈中清理掉. 2.10 调用 printf() 函数 StackFrame.cpp源代码中用于打印运算结果的语句如下所示. printf(“%d\n”, add(a, b)); 调用printf()函数的汇编代码如下. 123456700401044 push eax00401045 push StackFra.0040B384 ; ASCII &quot;%d\n&quot;0040104A call StackFra.004010670040104F add esp,0x8 地址401044处的EAX寄存器中存储函数add()的返回值,它是执行加法运算后的结果3.地址40104A处的CALL 401067命令中调用的是401067地址处的函数.它是一个C标准函数printf(),由于上面的printf()函数有两个参数,大小为8个字节,所以在40104F地址处使用ADD命令,将ESP加上8个字节,把函数的参数从栈中删除,函数printf()执行完毕后通过ADD命令删除参数. 2.11 设置返回值 StackFrame.cpp中设置返回值的语句如下: return 0; main()函数使用该语句设置返回值 (0). 00401052 xor eax,eax XOR命令用来进行异或运算,起特点为 “2个相同的值进行XOR运算,结果为0”.XOR命令比MOV EAX ,0命令执行速度快,常用语寄存器的初始化操作. 2.12 删除栈帧%main()函数终止 StackFrame.cpp中对于代码如下: return 0;}最终主函数终止,同add()函数一样,其返回值要先从栈中删除与其对应的栈帧. 12300401054 mov esp,ebp00401056 pop ebp 执行完上面2条命令后,main()函数的栈帧即将被删除,其局部变量a,b也不再有效.执行完毕. 00401057 RETN 执行完上面命令后,主函数执行完毕之后,程序执行跳转到 (401250),该地址指向Visual C++的启动函数区域,随后执行进程终止代码. 3. 设置 OllyDbg的选项3.1 打开OllyDbg的Debugging options对话框 (快捷键Alt+O). 可以设置一些适合自己的选项. 4. 总结栈帧技术使用EBP寄存器(而非ESP寄存器)管理局部变量/参数/返回地址等.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第6章 分析abex'crackme#1]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC6%E7%AB%A0-%E5%88%86%E6%9E%90abex-crackme-1%2F</url>
      <content type="text"><![CDATA[Abex’crackme是一个简单的绝著名小程序,国内外都有许多网站都对它进行了详细的讲解与说明.将自己的破解方法与其他人作为比较,能够提供自己的计算水平. 1. abex’crackme #1调试前先运行程序,显示”Make me think your HD is a CD-ROM”消息. 消息的最后部分出现了”CD-Rom”这个词,由于我们没有太多的选择,只能继续点击消息窗口的”确定”按钮. 程序弹出ERROR消息窗口后就结束了运行. 1.1 开始调试首先运行OllyDbg软件载入小程序,代码窗口可以看到程序的汇编代码. EP代码非常短,是因为采用了汇编语言写出来的可执行文件,如果是使用了VC++/VC/Delphi等开发工具编写程序时,除了自己编写的代码外,还有一部分启动函数是由编译器添加的,经过反编译后,代码看上去就变得非常复杂.但是如果直接使用了汇编语言编写程序,汇编代码会直接变为反汇编代码.main()直接出现在EP中,简单直观. 1.2 分析代码重点看部分关于 Win32 API 调用的内容. 在消息窗口按”确定”后,程序会调用GetDriveTyppe() API,获取C驱动器的类型(大部分返回的是HDD类型),然后操作它,使之被识别为CD-ROM类型,再在消息窗口输出”OK,I really think that your HD is a CD-ROM !”.下面逐行分析crackme的代码. 若两值相等,则跳转到40103D,否则从401028继续执行! 提示 指令 说明 PUSH 入栈指令 CALL 调用指定的函数 INC 值加1 DEC 值减1 JMP 跳转到制定地址 CMP 比较给定的两个操作数与SUB命令类似,但操作数的值不会改变,仅改变EFLAGS寄存器. (若2个操作数的值一致,SUB结果为0,ZF设置为1) JE 条件跳转指令 (若ZF为1,则跳转) 2. 破解首先移动光标到401026地址处,按空格键,在打开的汇编窗口中将汇编指令JE SHORT 0040130D更改为JMP 0040103D,如图所示: 意思就是将条件分支语句(JE)替换为无条件跳转语句(JMP). 3. 将参数压入栈首先,请看地址00401000~0040100E之间的命令,可以发现调用MessageBoxA()函数之前使用了4个PUSH命令,把函数需要的参数逆序压入栈. 将上述汇编代码转换为C语言函数调用代码,如下所示. 1MessageBox(NULL,"Make me think your HD is a CD-Rom." ,"abex' 1st crackme",MB_OK|MB_APPLMODAL); 比较C语言代码与汇编代码可以看到,函数调用时的参数顺序(正序)与参数入栈时的顺序(逆序)相反.那么参数入栈时,为什么采用逆序的方式?我们可以从内存结构(FILO,Firts In Last Out)即可. 栈的结构是FILO (先进后出),所以把参数压入栈时,只有按照逆序的方式压入,MessageBoxA()函数才能以正确的顺序接收到该参数! 利用调试器执行到EIP=0040100E地址处,观察右下角的栈窗口. MessageBoxA()函数从栈中获取需要的参数时,存储在栈中的参数会按照先进后出的规则依次弹出.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第5章 栈]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC5%E7%AB%A0-%E6%A0%88%2F</url>
      <content type="text"><![CDATA[栈(Stack)的用途广泛,通常用于存储局部变量/传递函数参数/保存函数返回地址等. 1. 栈栈内存在进程中的作用如下: 暂时保存函数内的局部变量. 调用函数时传递参数. 保存函数返回后的地址. 1.1 栈的特征一个进程中,栈顶指针(ESP)初始状态指向栈底端.执行PUSH命令将数据压入栈时,栈顶指针就会上移到栈顶端.执行POP命令从栈中弹出数据时,若栈为空,则栈顶指针重新移动到栈底端.向栈中压数据就像一层层砌砖,每向上砌一层,砖墙就增高一点儿. 1.2 栈操作示例栈顶指针的值为19FF84,观察右下角的栈长裤,可以看到ESP指向的地址及其值. 在代码窗口中按F7键(Step Into),执行401000地址处的PUSH 100命令. 可以看到ESP值变为19FF80,比原来减少了4个字节,并且当前栈顶指针指向19FF80,该地址中保存着100这个值.换言之,执行PUSH命令时,数值100被压入栈,ESP随之向上移动,即ESP的值减少了4个字节.再次按F7(Step Into),执行401005地址处的POP EAX命令. 执行完POP EAX命令后,ESP值又增加了4个字节,变为19FF84,栈又变为初始状态.换言之,从栈中弹出数据后,ESP随之向下移动.向栈压入数据从栈中弹出数据时,栈顶指针的变化情形如下: 向栈压入数据时,栈顶指针减小,向低地址移动;从栈中弹出数据时,栈顶指针增高,向高地址移动.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第4章 IA-32寄存器基本讲解]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC4%E7%AB%A0-IA-32%E5%AF%84%E5%AD%98%E5%99%A8%E5%9F%BA%E6%9C%AC%E8%AE%B2%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[1. 什么是CPU寄存器寄存器(Register)是CPU内部用来存放数据的一些小型存储区域,因为其集成在CPU内部,拥有非常高的读写速度. 2. IA-32 寄存器IA-32 是英特尔推出的32位元架构,属于复制的指令集构架. 2.1 基本程序运行寄存器基本程序运行寄存器的组织结构,它由4类寄存器组成. 通用寄存器 ( General Purpose Resgisters, 32位,8个 ) 段寄存器 ( Segment Registers, 16位,6个 ) 程序状态与控制寄存器 ( Program Status and Control Registers , 32位, 1个 ) 指令指针寄存器 ( Instruction Pointer , 32位, 1个 ) 2.1.1 通用寄存器通用寄存器是一种通用型的寄存器,用于传送和暂存数据,也可以参与算术逻辑运算,并保持运算结果.IA-32中每个通用寄存器大小都是32位(4个字节),主要用来保存常量与地址等. 各寄存器的名称如下: EAX : ( 针对操作数和结构数据的 ) 累加器 EBX : ( DS段中的数据指针 ) 基址寄存器 ECX : ( 字符串和循环操作的 ) 计算器 EDX : ( I/O指针 ) 数据寄存器 以上4个寄存器主要用在算术运算( ADD,SUB,XOR,OR)等,常常用来保存变量与变量的值.某些汇编 指令( MUL,DIV,LODS等) 直接用来操作特定寄存器,执行这些命令后,仅改变特定寄存器中的值. 此外,ECX和EAX也可用特殊用途,循环命令( LOOP )中,ECX用来循环计数 ( loop count ),每执行一次循环,ECX都会减1.EAX一般用在函数返回值中,所有Win 32 API函数都会先把返回值保存在EAX再返回. EBP : ( SS段中栈内数据指针 )扩展基址指针寄存器 ESI : (字符串操作源指针) 源变址寄存器 EDI : (字符串操作目标指针) 目的变址寄存器 ESP : (SS段中栈指针) 栈指针寄存器 以上4个寄存器主要用来作保存内存地址的指针. ESP指示栈区域的栈顶地址,某些指令(PUSH,POP,CALL,RET)可以直接用来操作ESP. EBP表示栈区域的基地址,函数被调用时保存ESP的值,函数返回时再把值返回ESP,保证栈不会崩溃.ESI和EDI与特定指令(LODS,STOS,REP,MOVS等)一起使用,主要用来内存复制. 2.1.2 段寄存器段(Segment),IA-32的保护模式中,段是一种内存保护技术,它把内存划分为多个区段,并为每个区段赋予起始地址,范围,访问权限等,以保护内存.此外,它还同分页技术(Paging)一起用于将虚拟内存变更为实际物理内存.段内存记录在SDT(Segment Descriptor Table,段描述符表)中,而段寄存器就持有这些SDT的索引(index). 它描述了保护模式下的内存分段模型.段寄存器总共由6中寄存器组成,分别为CS,SS,DS,ES,FS,GS,每个寄存器的大小为16位,即2个字节.另外,每个段寄存器指向的段描述符(Segment Descriptor)与虚拟内存结合,形成一个线性地址(Linear Address),借助分页技术,线性地址最终被转换为实际的物理地址(Physical Address). 各段寄存器的名称如下: CS : Code Segment, 代码段寄存器 SS : Stack Segment, 栈段寄存器 DS : Data Segment, 数据段寄存器 ES : Extra ( Data ) Segment,附加(数据)段寄存器 FS : Data Segment, 数据段寄存器 GS : Data Segment, 数据段寄存器 CS寄存器用于存放应用程序代码所在段的段基址, SS寄存器用于存放栈段的段基址,DS寄存器用于存放数据段的段基址.ES,FS,GS寄存器用来存放程序使用的附加数据段的段基址. 2.1.3 EFLAGS:Flag Register,标志寄存器3个与程序调试相关的标志,分别为ZF (Zero Flag,零标志),OF(Overflow Flag,溢出标志),CF(Carry Flag,进位标志). ZF若运算结果为0,则其值为1(true),否则其值为0(False). OF有符号整数(signed integer)溢出时,OF值被置为1.此外,MSB( Most Sginificant Bit,最高有效位)改变时,其值也被设为1. CF 无符号整数(unsigned integer )溢出时,其值也被置为1. 2.1.4 指令指针寄存器 EIP : Instruction Pointer,指令指针寄存器 指令指针寄存器保存着CPU要执行的指令地址,其大小为32位(4个字节).当程序运行时,CPU会读取EIP中的一条指令的地址,传送指令到指令缓冲区,EIP寄存器的值会自动增加,增加的大小即是读取指令的字节大小.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第3章 小端序标记法]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC3%E7%AB%A0-%E5%B0%8F%E7%AB%AF%E5%BA%8F%E6%A0%87%E8%AE%B0%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在计算机领域中,字节序(Byte Ordering)是多字节数据在计算机内存中存储或网络传输时各字节的存储顺序.分为小端序(Little endian)和大端序(Big endian). 1. 字节序1234BYTE b = 0x12;WORD w = 0x1234;DWORD dw = 0x12345678;char str[ ] = &quot;abcde&quot;; 以下为不同数据根据不同字节序保存时的不同: TYPE Name SIZE 大端序类型 小端序类型 BYTE b 1 [12] [12] WORD w 2 [12][34] [34] [12] DWORD dw 4 [12][34][56][78] [78][56][34][12] char[] str 6 [61][62][63][64][65][00] [61][62][63][64][65][00] 提示: 查看ASCII码表,字母a的ASCII码的十六进制表示为0x61,字母e的ASCII码的十六进程表示为0x65. 字符串最好都是以NULL结尾.因为数据类型为字节型(BYTE),其长度都为1个字节,所以保存在大端序类型或者小端序类型,字节顺序都一致!如果数据长度超过2个字节,则会在大端序和小端序上面存储的数据不同.如果是字符串被保存在数组str中,字符数组在内存中连续,此时无论在大端序还是小端序,存储顺序都相同! 1.1 大端序和小端序大端序常用于大型UNIX服务器的RISC系列的CPU中,而小端序采用逆向式存储数据,在Intel x86 CPU常用到. 1.2 在OllyDbg中查看小端序12345678910111213141516#include &quot;windows.h&quot;BYTE b = 0x12;WORD w = 0x1234;DWORD dw = 0x12345678;char str[] = &quot;abcde&quot;;int main(int argc, char *argv[])&#123; BYTE lb = b; WORD lw = w; DWORD ldw = dw; char *lstr = str; return 0;&#125; 用OllyDbg调试,用Go to命令(Ctrl+G)跳转到401000地址 main()函数地址为401000,全局变量b、w、dw、str地址分别为40AC40、40AC44、40AC48、40AC4C.可以来到数据窗口用Go to命令跳转到40AC40处. 可以看到,变量w与dw中的数据都采用了小端序存储.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第2章 逆向分析Hello World! 程序]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC2%E7%AB%A0-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90Hello-World-%E7%A8%8B%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[1. Hello World!程序123456789101112#include "windows.h"#include "tchar.h"int _tmain(int argc, TCHAR *argv[])&#123; MessageBox(NULL, L"Hello World!", L"www.reversecore.com", MB_OK); return 0;&#125; 不论用那种语言编写的程序,编译后都会生成二进制可执行文件. 2. 调试HelloWorld.exe程序 提示 分析时可采用 OllyDbg 的 Win32 专业调试工具. 达到一定水平建议使用 Hex -Rays 公司的 IDA Pro. 代码窗口 : 默认用于显示反汇编代码,适用于显示各种注释,标签,分析代码时显示循环,跳转位置等信息.寄存器窗口 : 实时显示CPU寄存器的值,可用于修改特定的寄存器.栈窗口 : 实时显示ESP寄存器指向的进程栈内存,并允许修改. 2.1 入口点调试器停止的地点即为HelloWorld.exe执行的起始地址(4011A0),它是一段EP(EntryPoint入口点)代码. EP(EntryPoint,入口点)EP是 Window 可执行文件(EXE,DLL,SYS等)的代码入口点,是执行应用程序最先执行的代码的起始位置,它依赖于CPU. 2.2 跟踪 40270C 函数 OllyDbg基本指令(适用于代码窗) 指令 快捷键 含义 Restart Ctrl+F2 重新开始调试 Step Into F7 执行一句OP code(操作码),若遇到命令(CALL),将进入函数代码内部 Step Over F8 执行一句OP code(操作码),若遇到命令(CALL),仅执行函数自身,不跟随进入 Execute till Return(执行到返回) Ctrl+F9 一直在函数代码内部运行,直到遇到RETN命令,跳出函数 在 EP 代码的40010A0地址处使用Step Into(F7)指令,进入40270C函数. 4027A1地址处有一个RETN指令,它用于返回函数调用者的下一条指令,一般是被调用函数的最后一句.在4027A1地址处的RETN指令上执行SETP over(F8)或Execute till Return(Ctrl+F9)命令.程序会跳转到4011A5地址处. 2.3 跟踪 40104F 跳转语句执行4011A5 地址处的跳转命令JMP 0040104F,跳转到40104F. 2.4 查找main()函数在40104F地址开始,每执行一次Step Into(F7)命令就下移1行代码,移动到401056地址处的CALL 402524函数调用命令时,执行Step Into(F7)命令,进入402524函数. 我们很难把402524函数称为Main()函数,因为在它的代码中没发现调用MessageBox()API的代码.执行Execute till Return(Ctrl+F9)指令,跳出402524函数,返回到40105B地址处. 同样,在40104F地址处执行Step Into(F7)命令调试,遇到函数调用就进入函数查看代码,确认是否是main()函数.若不是main()函数,则使用(Ctrl+F9)命令跳出相关函数,继续以相同方式调试. 4010E4地址处的CALL Kernel32.GetCommandLineW指令是调用Win32 API的代码. 401000函数内部出现了调用MessageBoxW()API的代码,该API的函数参数为与源码内容一致,由此可以判断401000函数就是我们需要找的main()函数. 3. 进一步熟悉调试器3.1 调试器指令 指令 快捷键 含义 Go to Ctrl+G 移动到指定地址,用来查看代码或内存,运行时不可用 Execute till Cursor F4 执行到光标位置,即直接转到要调试的地址 Comment ; 添加注释 User-defined comment 鼠标右键菜单Search for User-defined comment Set/Reset BreakPoint F2 设置或取消断点(BP) Run F9 运行(若设置了断点,则执行到断点处) Show the previous Cursor - 显示上一个光标的位置 Preview CALL/JMP address Enter 若光标处有CALL/JMP等指令,则跟踪并显示相关地址(运行时不可用,简单查看函数内容时非常好用) 3.2 “大本营”当每次重新运行调试器时,调试器会返回到EP处,并从此处新开始调试. 3.3 设置”大本营”的四种方法 GoTo命令 设置地址40104F.执行Go to(Ctrl+G)命令,在文本框中输入”40104F” 执行Execute till cursor(F4)命令,让调试运行到该处,然后从40104F处开始调试代码. 设置断点 调试代码,还可以设置BP断点,让调试直接流转到”大本营”.设置断点后,程序运行到断点处将会暂停. 在OllyDbg菜单栏中依次选择View-Breakpoints(快捷键ALT+B),打开Breakpoints对话框,列出代码中设置的断点. 注释 键盘上的”;”键可以在指定位置添加注释,还可以通过命令找到它. 在鼠标右键中依次选择Search for User defined comment,这样就能看到用户输入的所有注释. 红色显示的文字即是光标当前所在的位置,当注释位置与光标位置重合时,将仅以红色方式显示. 标签 我们能通过标签功能在指定的地址添加特定名称.移动光标到40104F地址处,按”:”键输入标签. 4. 快速查找指定代码的四种方法调试代码时,main()函数并不直接位于可执行代码的EP位置上,出现的是开发工具生成的启动函数. 4.1 代码执行法按F8键逐行执行命令,在某个时刻弹出信息对话框,显示”hello world!”信息.按Ctrl+F2再次载入待调试的可执行文件并重新调试,不断按F8键,某个时刻一定会弹出信息对话框.弹出信息对话框调用时的函数即为main()函数. 提示 Win32 应用程序中,API函数的参数是通过栈传递的.VC++中默认字符串是使用Unicode码表示,并且,处理字符串的API函数也全部变更为Unicode系列函数. 4.2 字符串检索法鼠标右键菜单 - Search for - All referenced text strings OllDbg初次载入待调试程序有预分析过程,此过程中会查看进程内存,程序中引用的字符串和调用的API都会被摘录出来,调整到另外一个列表中. 地址401007处有一个PUSH 004092A0命令,该命令引用004092A0处即是字符串”helloworld!”双击,光标定位到main()函数中调用MessageBoxW()函数的代码处,在Dump窗口中使用Go to(Ctrl+G)命令,进一步查看内存4092A0地址处的字符串. 提示: VC++中,static字符串会被默认保存为Unicode码格式.需要注意的是4092A0地址,它与我们之前代码区地址(401XXX)不同,在helloworld.exe进程中,409XXX地址空间被用来保存程序中的数据, 代码与数据所在的区域是彼此分开的. 4.3 API索引法(1) : 在调用代码中设置断点 鼠标右键菜单 - Search for - All intermodular calls 应用程序想向显示屏输出内容时,需要在程序内部调用Win 32 API.helloworld.exe,它在运行时会弹出一个信息窗口,由此可以判断该程序调用了user32.MessageBox()API. 可以查看调用MessageBoxW()的代码,该函数位于40100E地址处,它是user.MessageBoxW()API. 4.4 API索引法(2) : 在API代码中设置断点 鼠标右键菜单 Search for - Name in all calls 如果使用了压缩器/保护器工具对可执行文件进行压缩或保护,因为文件结构的改变.此时用该方法显得十分困难. DLL代码库会被加载到进程内存中,然后我们可以直接向DLL代码库添加断点,API是操作系统对用户应用程序提供一系列函数,它们位于C:\windows\system32文件夹中的*.dll文件(如kernel32.dll,user32.dll,gdi32.dll,advapi32.dll,ws2_32.dll等)内部.因为编写的应用程序执行某些操作时,必须使用os提供的API向os提出请求,然后与被调用API对用的系统DLL文件就会被加载到应用程序的进程内存. 菜单栏-&gt;View-Memory菜单(快捷键ALT+M),打开内存映射窗口. 然后通过查找命令将光标定位到MessageBoxW上. 5. 使用”打补丁”方式修改”hello world!”字符串5.1 “打补丁”使调试流运行到main函数的起始地址处(401000),在401000地址处按F2设置断点,再按F9执行程序. 5.2 修改字符串的两种方法 直接修改字符缓冲区(buffer). 在其他内存区域生成新字符串并传递给消息函数. 直接修改字符串缓冲区 在Dump窗口中Ctrl+G快捷键Go to 命令,在窗口中输入4092A0字符串缓冲区.使用鼠标选中4092A0地址的内容,按Ctrl+E快捷键打开编辑窗口 . 在Dump窗口中,选中更改后的字符串,通过鼠标右键,在弹出的菜单中选中Copy to executable file 菜单,然后选中保存即可. 在其他内存区域新建字符串并传递给消息函数 401007地址处有一条PUSH 00409A0命令,它把409A0地址处的”Hello world!”字符串以参数形式传递给MessageBoxW()函数. 我们修改字符串地址为4092A0,下面用Dump窗口查看该部分,相应内存区域由NULL填充(NULL padding)结束. 这就是程序中未使用NULL填充区域. 提示 应用程序被加载到内存时有一个最小的内存分配大小,一般为1000.即使程序运行时只占用了100内存,它被加载到内存时依然会分到1000左右的内存,这些内存一部分被程序占用,其余部分分为空余区域,全部被填充为NULL. 因为新建了缓冲区,接下来把新的缓冲区地址(409F50)作为参数传递给MessageBoxW()函数.为此,我们在代码窗口使用汇编命令修改代码.用空格键打开Assemble窗口. 在打开的Assemble窗口中输入”PUSH 409F50”指令,那么将把409F50作为新字符串的首地址! 提示 可执行文件被加载到内存并以进程形式运行时,文件并非原封不动地载入内存,而要遵守一定规则进行.在这一过程中,通常进程的内存地址是存在的,但是相应的文件偏移(offset)并不存在. 6. 小结 OllDbg常用命令 指令 快捷键 说明 Step Into F7 执行一条OP code(操作码),遇到CALL命令时,进入函数代码内部. Step Over F8 执行一条OP code(操作码),遇到CALL命令时,不进入函数代码内部,仅执行函数本身. Restart Ctrl+F2 再次从头调试(终止调试中的过程,重新载入调试程序) Go to Ctrl+G 跳转到指定地址(查看代码时使用,非运行时命令) Run F9 运行(运动断点会暂停) Execute till return Ctrl+F9 执行函数代码内的命令,直到遇到RETN命令,用于跳出函数整体. Execute till cursor F4 执行到光标所在的位置(直接调到要指定的位置) Comment ; 添加注释 User-defined comment 鼠标右键菜单Search for - User-defined comment 查看用户的注释目录 Label : 添加标签 User -defined label 鼠标右键菜单Search for - Usr-defined label 查看用户输入的标签目录 Breakpoint F2 设置或取消断点 All referenced text strings 鼠标右键菜单Search for -All referenced text strings 查看代码中引用的字符串 All intermodular calls 鼠标右键菜单Search for -All intermodular calls 查看代码中调用的所有API函数 Name is all modules 鼠标右键菜单Search for -Name is all modules 查看所有的API函数 Edit data Ctrl+E 编辑数据 Assemble Space 编写汇编代码 Copy to executable file 鼠标右键菜单Copy to executable file 创建文本副本(修改的项目被保留) Assemble(汇编语言)基础指令 指令 说明 CALL XXXX 调用XXXX地址处的函数 JMP XXXX 跳转到XXXX地址处 PUSH XXXX 保存XXXX到栈 RETN 跳转到栈中保持的地址 修改(Path)进程数据与代码的方法 术语 说明 VA(Virtual Address) 进程的虚拟地址 OP code(Operation code) CPU指令(字节码byte code) PE(Portable Executable) Window可执行文件(EXE,DLL,SYS等) 疑问 快捷键F4与F9最大的不同在于F4可以看做为断点+运行的组合. 启动函数(Stub code)不是用户编写的代码,在调试程序中,我们不需要仔细分析启动函数.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第1章 关于逆向工程]]></title>
      <url>%2F2017%2F03%2F28%2F%E7%AC%AC1%E7%AB%A0-%E5%85%B3%E4%BA%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[1. 逆向工程逆向工程(Reverse Engineering,简称PE). 2. 代码逆向工程代码逆向工程(简称RCE) 2.1 逆向分析法 1. 静态分析法 静态分析法是在不执行代码文件的情况下,对代码进行静态分析.靠观察代码文件 的外部特征,获取文件的类型(EXE,DLI,DOC,ZIP等),大小,PE头信息,Import/Export API, 内部字符串,是否运行时解压缩,注册信息,调试信息,数字证书等多种信息. 2. 动态分析法 动态分析法是在程序文件执行过程中对代码进行动态的分析,它通过调试来分析代码流,获得内存的状态等. 一般先用静态分析法收集代码信息,然后通过收集到的信息推测程序的结构和行为机制. 2.2 源代码,十六进制代码,汇编代码源代码(Source Code)-&gt;十六进制代码(Hex Code)-&gt;汇编代码(Assembly Code),即把待分析代码转换为汇编代码后才分析. 2.3 “打补丁”与”破解”打补丁(Path)与破解(Crack)的区别在于道德问题. 2.4 代码逆向准备目标&amp;激情&amp;谷歌 2.5 学习逆向分析技术的禁忌勿贪心勿急躁]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 18 He often does this! 他经常干这种事]]></title>
      <url>%2F2017%2F03%2F28%2FLesson-18-He-often-does-this-%E4%BB%96%E7%BB%8F%E5%B8%B8%E5%B9%B2%E8%BF%99%E7%A7%8D%E4%BA%8B-1%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 pub n.小酒馆 public house They went to the pub for a drink. landlord n.店主 The landlord asked Ted to pay the rent(租金). bill n.账单 telephone bill gas bill pay one’s bill Bill, please a ten-dollar bill 一张十美元纸币 2. 语法讲解 After I had had lunch at a village pub… had done 过去完成时 (have为助动词,无词义) have lunch (have为实义动词,有”吃,喝”) have coffee Dave has a brother …I looked for(寻找) my bag. Nick looked for his dog everywhere. He didn’t find it. I had left it on a chair beside the door… leave sth. + 介词短语He left his bag on the train. beside prep. == next toShe is sitting beside the woindow. besides prep. == in addition toBesides Ellen, five of us have watched the movie. As I was looking for it… as conj. 当…的时候 As I was writing a report(报告), George came up to me. I haven’t got my… have got == haveJack has got a dog / Jack has a dog.否定句 :Jack hasn’t got a dog. / Jack hasn’t a dog.疑问句 :Has Jack got a dog? / Has Jack a dog? … immediately went out. immediately == at once (立即) He often does… he == the dog 3. 知识扩展 have 助动词He has never been abroad before. 他以前从来没有出过国. 实义动词He has two sisters.(有)Jim had breakfast at 7 this morning.(吃)Would you like to have a cup of coffee?(喝)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[11.安卓基础之多媒体]]></title>
      <url>%2F2017%2F03%2F28%2F11-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E5%AA%92%E4%BD%93%2F</url>
      <content type="text"><![CDATA[Android 多媒体基础知识概述计算机发展到今天,不仅表示数值和符号,已具有了对文本,图形,图像动画及音频视频等多种信息的综合处理能力,我们称之为多媒体技术. 图像与图形在计算机中,图像是采用位图形式来表示的;图形是采用矢量图方式来表示的; 位图图像称为光栅图或点阵图像,是由许多像小方块一样的”像素”(pixels)组成的图形. 图像 : 是由像素点阵组成的画面. 位图 : 由许多点组成的点阵图.构成位图的点称为像素. 色彩深度 : 位图所能达到的最大颜色数,称为色彩深度.(对于黑白两种颜色的图像来说一个像素点可用一个二进制位来表示,如0表示黑色,1表示白色.) 图片的操作123456789101112// 1. 准备画纸:(大小和材质需要参考原图)Bitmap copyBitmap = Bitmap.createBitmap(srcBitmap.getWidth(), srcBitmap.getHeight(), srcBitmap.getConfig());// 2. 准备画板，将画纸放到画板上Canvas canvas = new Canvas(copyBitmap);// 3. 准备画笔Paint paint = new Paint();// 4. 按照一定的规则Matrix matrix = new Matrix();// 1:1照着画// 5. 将原图像按照规则画到画板上canvas.drawBitmap(srcBitmap, matrix, paint); 图片的缩放 1matrix.setScale(0.6f, 0.8f); 图片的平移 1matrix.setTranslate(50, 50); 位图图像的缺陷 位图放大和缩小都会引起像素的增加或减少,这样会使得原由的图像的线条和形状变得参差不齐,与原图像相比出现失真;出现”锯齿形”. 位图常见的文件格式 .bmp .jpg .gif .png 矢量图像矢量图形是通过计算机将一串线条和图形转换为一系列指令,在计算机中只存储这些指令,而不是像素.矢量图像看起来没有位图图像真实,但矢量图形的存储空间比位图图像要小得多,而且矢量图像通过拉伸,移动,放大等操作,图像不会产生实真. 颜色矩阵1 0 0 0 00 1 0 0 00 0 1 0 00 0 0 1 0 颜色矩阵的代码表述12345678910111213New Red Value = 1*128 + 0*128 + 0*128 + 0*0 + 0New Green Value = 0*128 + 1*128 + 0*128 + 0*0 + 0New Blue Value = 0*128 + 0*128 + 1*128 + 0*0 + 0New Alpha Value = 0*128 + 0*128 + 0*128 + 1*0 + 0ColorMatrix cm = new ColorMatrix();cm.set(new float[] &#123;2, 0, 0, 0, 0,0, 1, 0, 0, 0,0, 0, 1, 0, 0,0, 0, 0, 1, 0&#125;);paint.setColorFilter(new ColorMatrixColorFilter(cm)); 传感器传感器(英文名称 : sensor)是一种检测装置,能感受到被测量的信息,并能将感受到的信息,按一定规律变换成为电信号或其他所需形式的信息输出,以满足信息的传输,处理,存储,显示,记录和控制等要求. 传感器的特点包括 : 微型化,数字化,智能化,多功能化,系统化,网络化.它是实现自动检测和自动控制的首要环节.传感器的存在和发展,让物体有了触觉,味觉和嗅觉等感官,让物体慢慢变得活了起来.通常根据其基本感知功能分为热敏元件,光敏元件,气敏元件,力敏元件,磁敏元件,湿敏元件,声敏元件,放射线敏感元件,色敏元件和味敏元件等十大类. 传感器类型 描述 SENSOR_TYPE_ACCELEROMETER 加速度 SENSOR_TYPE_MAGNETIC_FIELD 磁力 SENSOR_TYPE_ORIENTATION 方向 SENSOR_TYPE_GYROSCOPE 陀螺仪 SENSOR_TYPE_LIGHT 光线感应 SENSOR_TYPE_PRESSURE 压力 SENSOR_TYPE_TEMPERATURE 温度 SENSOR_TYPE_PROXIMITY 接近 SENSOR_TYPE_GRAVITY 重力 SENSOR_TYPE_LINEAR_ACCELERATION 线性加速度 练习案例 加载大图片到内存 获取到读写内存权限12&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"&gt;&lt;/uses-permission&gt; 代码实现部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445 private ImageView iv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); iv =(ImageView) findViewById(R.id.iv); &#125; public void loadBitmap(View v)&#123; String path = "mnt/sdcard/1.jpg"; //通过手机的屏幕的宽高和图片的宽高来计算采样率 //屏幕宽高 DisplayMetrics metrics = getResources().getDisplayMetrics(); int screenWidth = metrics.widthPixels;//获取屏幕宽度 int screentHeight = metrics.heightPixels;//获取屏幕高度 //图片的宽高 try&#123; ExifInterface exif = new ExifInterface(path); int picWidth = exif.getAttributeInt(ExifInterface.TAG_IMAGE_WIDTH,0); int picHeight = exif.getAttributeInt(ExifInterface.TAG_IMAGE_LENGTH,0); //用图片的宽度/屏幕的宽度 int widthSample = (int)(picWidth*1f/screenWidth+0.5f);//四舍五入 int heightSample = (int)(picHeight*1f/screentHeight+0.5f);//四舍五入 int sample = (int) (Math.sqrt(widthSample * widthSample + heightSample * heightSample) + 0.5f); //加载图片 BitmapFactory.Options opts = new BitmapFactory.Options(); opts.inSampleSize = sample;//采样率 Bitmap bitmap = BitmapFactory.decodeFile(path,opts); iv.setImageBitmap(bitmap); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 图片的缩放 123456789101112131415161718192021222324public void opts(View v)&#123; String path = "mnt/sdcard/1.jpg"; //显示图片 Bitmap srcBitmap = BitmapFactory.decodeFile(path); ivSrc.setImageBitmap(srcBitmap); //准备画纸(大小和材质参照原材料) Bitmap copyBitmap = Bitmap.createBitmap(srcBitmap.getWidth(),srcBitmap.getHeight(),srcBitmap.getConfig()); //准备画板,将画纸放到画板上 Canvas canvas = new Canvas(copyBitmap); //准备画笔 Paint paint = new Paint(); //按照一定规则 Matrix matrix = new Matrix();//1:1画 //按照比例缩放图片 matrix.setScale(24.6f,22.8f); //将原图像按照规则画到画板上 canvas.drawBitmap(srcBitmap,matrix,paint); //画板有数据了 ivDest.setImageBitmap(copyBitmap); &#125; 图片的位移 12// 位移操作:dx:x方向的增量 dy：y方向的增量matrix.setTranslate(50, 50); 图片的旋转 12matrix.setRotate(45, srcBitmap.getWidth() / 2f, srcBitmap.getHeight() / 2f); 对图片颜色的处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MainActivity extends Activity implements OnSeekBarChangeListener &#123; private ImageView iv; private SeekBar skbRed; private SeekBar skbGreen; private SeekBar skbBlue; private float redPercent = 1; private float greenPercent = 1; private float bluePercent = 1; private Bitmap srcBitmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); iv = (ImageView) findViewById(R.id.iv); skbRed = (SeekBar) findViewById(R.id.skb_red); skbGreen = (SeekBar) findViewById(R.id.skb_green); skbBlue = (SeekBar) findViewById(R.id.skb_blue); skbRed.setOnSeekBarChangeListener(this); skbGreen.setOnSeekBarChangeListener(this); skbBlue.setOnSeekBarChangeListener(this); // 加载图片显示 String path = "mnt/sdcard/img_small_1.jpg"; srcBitmap = BitmapFactory.decodeFile(path); iv.setImageBitmap(srcBitmap); &#125; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; // seekbar进度改变时的回调 &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; // 开始拖动seekbar的回调 &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; // 停止拖动seekbar的回调 // 0-100;//0-2 int progress = seekBar.getProgress(); float percent = progress / 50f;// (0-2f) if (seekBar == skbRed) &#123; this.redPercent = percent; &#125; else if (seekBar == skbGreen) &#123; this.greenPercent = percent; &#125; else if (seekBar == skbBlue) &#123; this.bluePercent = percent; &#125; // 去改变图片的颜色 // 1.去获得图片的拷贝 Bitmap copyBitmap = Bitmap.createBitmap(srcBitmap.getWidth(), srcBitmap.getHeight(), srcBitmap.getConfig()); Canvas canvas = new Canvas(copyBitmap); Matrix matrix = new Matrix(); // 2.去处理图片的中的颜色数据 Paint paint = new Paint(); // 设置画笔的颜色过滤 // vector:0-2 0:没有 2：最多 float[] cm = new float[] &#123; 1 * redPercent, 0, 0, 0, 0, // red vector 0, 1 * greenPercent, 0, 0, 0, // green vector 0, 0, 1 * bluePercent, 0, 0, // blue vector 0, 0, 0, 1, 0 // alpha vector &#125;; paint.setColorFilter(new ColorMatrixColorFilter(new ColorMatrix(cm))); canvas.drawBitmap(srcBitmap, matrix, paint); // 3.将处理的结果展示 iv.setImageBitmap(copyBitmap); &#125;&#125; canvas相关api 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class MainActivity extends Activity &#123; private ImageView iv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); iv = (ImageView) findViewById(R.id.iv); &#125; public void line(View view) &#123; // 1.画线 // 准备画纸 Bitmap bitmap = Bitmap.createBitmap(320, 320, Config.ARGB_8888); // 准备画布 Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); canvas.drawLine(10, 10, 200, 200, paint); iv.setImageBitmap(bitmap); &#125; public void rect(View view) &#123; // 1.画矩形 // 准备画纸 Bitmap bitmap = Bitmap.createBitmap(320, 320, Config.ARGB_8888); // 准备画布 Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); // 设置画笔的颜色 paint.setColor(Color.RED); // 设置画笔的样式 paint.setStyle(Style.STROKE); paint.setStrokeWidth(10);// 设置粗细 canvas.drawRect(30, 30, 200, 200, paint); iv.setImageBitmap(bitmap); &#125; public void circle(View view) &#123; // 1.画圆形 // 准备画纸 Bitmap bitmap = Bitmap.createBitmap(320, 320, Config.ARGB_8888); // 准备画布 Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); // 设置画笔的颜色 paint.setColor(Color.RED); paint.setAntiAlias(true);// 设置抗锯齿 float cx = 160;// 圆心的坐标X float cy = 160;// 圆心的坐标Y float radius = 100;// 半径 canvas.drawCircle(cx, cy, radius, paint); iv.setImageBitmap(bitmap); &#125; public void arc(View view) &#123; // 1.扇形 // 准备画纸 Bitmap bitmap = Bitmap.createBitmap(320, 320, Config.ARGB_8888); // 准备画布 Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); paint.setColor(Color.RED); paint.setAntiAlias(true);// 设置抗锯齿 // 1:矩形 RectF oval = new RectF(20, 20, 200, 200); float startAngle = 0;// 起始角度 float sweepAngle = 120;// 扫过的角度 boolean useCenter = false;// 是否画中心部分 canvas.drawArc(oval, startAngle, sweepAngle, useCenter, paint); iv.setImageBitmap(bitmap); &#125; public void trangle(View view) &#123; // 1.多边形 // 准备画纸 Bitmap bitmap = Bitmap.createBitmap(320, 320, Config.ARGB_8888); // 准备画布 Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); paint.setColor(Color.RED); paint.setAntiAlias(true);// 设置抗锯齿 float x1 = 160; float y1 = 20; float x2 = 140; float y2 = 200; float x3 = 180; float y3 = 200; Path path = new Path(); path.moveTo(x1, y1);// 将画笔移动到点1 path.lineTo(x2, y2);// 连线点2 path.arcTo(new RectF(140, 180, 180, 220), 0, 180); path.lineTo(x3, y3);// 连线点3 path.lineTo(x1, y1);// 连线点1 path.close(); canvas.drawPath(path, paint); iv.setImageBitmap(bitmap); &#125;&#125; 画画板 Menu的写法 :123456789&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:id="@+id/action_save" android:orderInCategory="100" android:showAsAction="never" android:title="保存图片"/&gt;&lt;/menu&gt; 布局写法 :1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;View android:id="@+id/color_red" android:layout_width="35dp" android:layout_height="35dp" android:background="#ff0000" /&gt; &lt;View android:id="@+id/color_green" android:layout_width="35dp" android:layout_height="35dp" android:background="#00ff00" /&gt; &lt;View android:id="@+id/color_blue" android:layout_width="35dp" android:layout_height="35dp" android:background="#0000ff" /&gt; &lt;View android:id="@+id/color_yellow" android:layout_width="35dp" android:layout_height="35dp" android:background="#ffff00" /&gt; &lt;View android:id="@+id/color_pink" android:layout_width="35dp" android:layout_height="35dp" android:background="#ff99ff" /&gt; &lt;/LinearLayout&gt; &lt;!-- 画笔的粗细 --&gt; &lt;SeekBar android:id="@+id/skb_stroke" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;ImageView android:id="@+id/iv" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; Java代码的实现 :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189public class MainActivity extends Activity implements OnClickListener, OnSeekBarChangeListener, OnTouchListener &#123; private static final String TAG = "MainActivity"; private View redView; private View greenView; private View blueView; private View yellowView; private View pinkView; private SeekBar skbStroke; private ImageView iv; private Bitmap bitmap; private Canvas canvas; private Paint paint; private float startX; private float startY; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); redView = findViewById(R.id.color_red); greenView = findViewById(R.id.color_green); blueView = findViewById(R.id.color_blue); yellowView = findViewById(R.id.color_yellow); pinkView = findViewById(R.id.color_pink); skbStroke = (SeekBar) findViewById(R.id.skb_stroke); iv = (ImageView) findViewById(R.id.iv); redView.setOnClickListener(this); greenView.setOnClickListener(this); blueView.setOnClickListener(this); yellowView.setOnClickListener(this); pinkView.setOnClickListener(this); skbStroke.setOnSeekBarChangeListener(this); iv.setOnTouchListener(this); // 准备画纸画布画笔 bitmap = Bitmap.createBitmap(320, 320, Config.ARGB_8888); canvas = new Canvas(bitmap); paint = new Paint(); canvas.drawColor(Color.WHITE); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; // 更改画笔的颜色 case R.id.color_red: paint.setColor(Color.RED); break; case R.id.color_green: paint.setColor(Color.GREEN); break; case R.id.color_blue: paint.setColor(Color.BLUE); break; case R.id.color_yellow: paint.setColor(Color.YELLOW); break; case R.id.color_pink: paint.setColor(0xffff99ff); break; default: break; &#125; &#125; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; // TODO Auto-generated method stub &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; // TODO Auto-generated method stub &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; // 改变画笔的粗细 int progress = seekBar.getProgress();// 0-100(1sp---&gt;10sp) // paint.setStrokeWidth(progress); paint.setStrokeWidth(10 * progress / 100f); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; // 触摸Imageview的回调 // 触摸的时候需要绘制图像,并且显示 switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN:// 1次 // 1. 手指按下 startX = event.getX();// 触摸的x坐标 startY = event.getY();// 触摸的y坐标 break; case MotionEvent.ACTION_MOVE:// 0-多次 // 2. 手指移动 float stopX = event.getX(); float stopY = event.getY(); // 绘制图像，并且显示到imgeview上 canvas.drawLine(startX, startY, stopX, stopY, paint); // 画纸上有数据了 iv.setImageBitmap(bitmap); // 更新起始点 startX = stopX; startY = stopY; break; case MotionEvent.ACTION_UP:// 1次 // 3. 手指抬起 break; default: break; &#125; // 消费触摸事件 return true; &#125; // 对应的菜单按钮 @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return super.onCreateOptionsMenu(menu); &#125; // 菜单按钮的点击事件 @Override public boolean onOptionsItemSelected(MenuItem item) &#123; int itemId = item.getItemId(); switch (itemId) &#123; case R.id.action_save: Log.d(TAG, "点击了保存按钮!"); // 将bitmap存储到本地 File file = new File(Environment.getExternalStorageDirectory(), System.currentTimeMillis() + ".jpg"); FileOutputStream fos = null; try &#123; fos = new FileOutputStream(file); // 将bitmap压缩到流中 bitmap.compress(CompressFormat.JPEG, 100, fos); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; fos = null; &#125; &#125; // 模拟 sdcard的挂载 Intent intent = new Intent(Intent.ACTION_MEDIA_MOUNTED); intent.setData(Uri.fromFile(Environment .getExternalStorageDirectory())); sendBroadcast(intent); break; default: break; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 播放器的同步和异步 播放网络歌曲权限 :1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 播放器的代码实现 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class MainActivity extends Activity implements OnSeekBarChangeListener &#123; private EditText etPath; private SeekBar skbProgress; private MediaPlayer player; private boolean tracking = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); etPath = (EditText) findViewById(R.id.et_path); skbProgress = (SeekBar) findViewById(R.id.skb_progress); skbProgress.setOnSeekBarChangeListener(this); &#125; public void play(View view) &#123; String path = etPath.getText().toString().trim(); if (TextUtils.isEmpty(path)) &#123; return; &#125; // 播放音乐 if (player == null) &#123; player = new MediaPlayer(); &#125; // 重置播放器 player.reset(); try &#123; player.setOnErrorListener(new OnErrorListener() &#123; @Override public boolean onError(MediaPlayer mp, int what, int extra) &#123; System.out.println("what : " + what); return false; &#125; &#125;); // 设置播放的资源 player.setDataSource(path); player.prepare();// 准备播放 player.start();// 开始播放 performProgress(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void performProgress() &#123; skbProgress.setMax(player.getDuration());// 音乐文件的时长 new Thread(new Runnable() &#123; @Override public void run() &#123; while (player != null &amp;&amp; player.isPlaying()) &#123; if (!tracking) &#123; // 获得当前的进度 int currentPosition = player.getCurrentPosition(); skbProgress.setProgress(currentPosition);//子线程中更新UI &#125; &#125; &#125; &#125;).start(); &#125; public void pause(View view) &#123; // 暂停 if (player != null &amp;&amp; player.isPlaying()) &#123; player.pause(); ((Button) view).setText("继续"); &#125; else if (player != null) &#123; player.start(); performProgress(); ((Button) view).setText("暂停"); &#125; &#125; public void stop(View view) &#123; if (player != null) &#123; player.stop(); player.release();// 释放资源 player = null; &#125; &#125; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; // TODO Auto-generated method stub &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; // 开始拖动 tracking = true; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; // 结束拖动 tracking = false; // 播放对应的位置 if (player != null) &#123; player.seekTo(seekBar.getProgress()); &#125; &#125;&#125; 声音池 123456789101112131415161718192021222324252627282930public class MainActivity extends Activity &#123; private SoundPool pool; private int soundID; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); int maxStreams = 10;// 声音池中同时可以播放声音的数量 int streamType = AudioManager.STREAM_MUSIC; int srcQuality = 0; pool = new SoundPool(maxStreams, streamType, srcQuality); // 加载一个声音文件 soundID = pool.load(this, R.raw.shoot, 1); &#125; public void shoot(View view) &#123; float leftVolume = 1f; float rightVolume = 1f; int priority = 0; int loop = 0; float rate = 1;// 播放的速率 pool.play(soundID, leftVolume, rightVolume, priority, loop, rate); &#125;&#125; 视频播放器 xml界面的简写 :1234&lt;VideoView android:id="@+id/vv" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; Java代码的实现 :1234567891011121314151617181920public class MainActivity extends Activity &#123; private VideoView vv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); vv = (VideoView) findViewById(R.id.vv); MediaController mc = new MediaController(this); mc.setAnchorView(vv); vv.setMediaController(mc); vv.setVideoPath("mnt/sdcard/areyouok.3gp"); vv.start(); &#125;&#125; 拍照 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainActivity extends Activity &#123; private static final int CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE = 100; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void takephoto(View view) &#123; // create Intent to take a picture and return control to the calling // application // 意图 Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);// 去打开系统的照相机 // 准备一个接收系统拍好照片后的文件路径 File file = new File(Environment.getExternalStorageDirectory(), System.currentTimeMillis() + ".jpg"); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); // set the // image // file // name // start the image capture Intent // 请求code startActivityForResult(intent, CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == CAPTURE_IMAGE_ACTIVITY_REQUEST_CODE) &#123; // 为你的某个请求返回的结果 // 给你数据的Activity设置的结果标记 // resultCode switch (resultCode) &#123; case Activity.RESULT_OK: // 获取数据成功 System.out.println("ok"); break; case Activity.RESULT_CANCELED: // 用户取消操作 System.out.println("cancel"); break; default: break; &#125; &#125; &#125;&#125; 传感器指南针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MainActivity extends Activity &#123; private SensorManager manager; private Sensor sensor; private SensorEventListener listener = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent event) &#123; // 1. 获取 传感器的数据 float[] values = event.values; // value // values[0]: Azimuth, angle between the magnetic north direction // and the y-axis, around the z-axis (0 to 359). 0=North, 90=East, // 180=South, 270=West float angle = values[0]; if (angle == 0) &#123; System.out.println("北"); &#125; else if (angle == 90) &#123; System.out.println("东"); &#125; else if (angle == 180) &#123; System.out.println("南"); &#125; else if (angle == 270) &#123; System.out.println("西"); &#125; else if (angle &gt; 0 &amp;&amp; angle &lt; 90) &#123; System.out.println("东北"); &#125; else if (angle &gt; 90 &amp;&amp; angle &lt; 180) &#123; System.out.println("东南"); &#125; else if (angle &gt; 180 &amp;&amp; angle &lt; 270) &#123; System.out.println("西南"); &#125; else if (angle &gt; 270 &amp;&amp; angle &lt; 360) &#123; System.out.println("西北"); &#125; &#125; @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123; // 1. 传感器的精确度发送改变时 &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 传感器的管理者 manager = (SensorManager) getSystemService(Context.SENSOR_SERVICE); // List&lt;Sensor&gt; list = manager.getSensorList(Sensor.TYPE_ALL); // for (Sensor sensor : list) &#123; // System.out.println(sensor.getName()); // &#125; // 获得光的传感器 sensor = manager.getDefaultSensor(Sensor.TYPE_ORIENTATION); &#125; @Override protected void onResume() &#123; super.onResume(); // 1:监听传感器 // 2:哪个传感器 // 3:采样频率 manager.registerListener(listener, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; @Override protected void onPause() &#123; super.onPause(); manager.unregisterListener(listener); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[10.安卓基础之新特性和知识点回顾]]></title>
      <url>%2F2017%2F03%2F28%2F10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE%2F</url>
      <content type="text"><![CDATA[1. 使用 ContentProvider 获得系统的联系人ContentProvider : 后门程序,就是一个继承了ContentProvder的一个类.使用系统已经提供好的后门程序,来获得所有的其他的应用中的数据.例如 : 获取到系统的短信内容,获取手机联系人的信息. 先获取到读取通讯录权限 1&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//ContactsUtils 获得系统的联系人的信息public class ContactsUtils &#123; public static List&lt;ContactInfo&gt; displayContact(Context context)&#123; List&lt;ContactInfo&gt; list = new ArrayList&lt;ContactInfo&gt;(); Uri contact_uri = Uri.parse("content://com.android.contacts/raw_contacts"); Uri data_uri = Uri.parse("content://com.android.contacts/data"); //获得与后门程序打交道的resolver对象 ContentResolver resolver = context.getContentResolver(); Cursor contact_cursor = resolver.query(contact_uri, new String[]&#123;"contact_id"&#125;,null,null,null); while(contact_cursor.moveToNext())&#123; String id = contact_cursor.getString(0); if(id!=null)&#123; ContactInfo info = new ContactInfo(); Cursor dataCursor = resolver.query(data_uri, new String[] &#123; "data1", "mimetype" &#125;, "raw_contact_id=?", new String[] &#123; id &#125;, null); while(dataCursor.moveToNext())&#123; String data1 = dataCursor.getString(0); String type = dataCursor.getString(1); if ("vnd.android.cursor.item/name".equals(type)) &#123; info.setName(data1); &#125; else if ("vnd.android.cursor.item/email_v2".equals(type)) &#123; info.setEmail(data1); &#125; else if ("vnd.android.cursor.item/im".equals(type)) &#123; info.setQq(data1); &#125; else if ("vnd.android.cursor.item/phone_v2".equals(type)) &#123; info.setPhone(data1); &#125; &#125; list.add(info); dataCursor.close(); &#125; &#125; contact_cursor.close(); return list; &#125;&#125; 2. Fragment 的使用 layout 的写法 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586activity_main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;FrameLayout android:id="@+id/container" android:layout_width="fill_parent" android:layout_height="0dip" android:layout_weight="1" &gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:text="@string/hello_world" &gt; &lt;Button android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:onClick="sound" android:text="声音" /&gt; &lt;Button android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content" android:onClick="display" android:text="显示" /&gt; &lt;Button android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content" android:onClick="storage" android:text="存储" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;displayfragment.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#4400ff00" android:orientation="vertical" &gt; &lt;TextView android:text="显示的fragment内容 " android:layout_width="fill_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt;soundfragment.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#44ff0000" android:orientation="vertical" &gt; &lt;TextView android:text="声音的fragment内容 " android:layout_width="fill_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt;storagefragment.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#440000ff" android:orientation="vertical" &gt; &lt;TextView android:text="存储的fragment内容 " android:layout_width="fill_parent" android:layout_height="wrap_content"/&gt;&lt;/LinearLayout&gt; fragmentquickstart的快速入门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108MainActivity.java@SuppressLint("NewApi")public class MainActivity extends Activity &#123; FragmentManager manager; FragmentTransaction transaction; SoundFragment sf; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); manager = getFragmentManager(); //事务 transaction = manager.beginTransaction(); sf = new SoundFragment(); transaction.replace(R.id.container, sf); transaction.commit(); //提交事务 &#125; //声音的 public void sound(View v)&#123; //在右侧的 FrameLayout去显示sound相关的fragment数据 transaction = manager.beginTransaction(); // fragment 可以直接 new 出来, 并且不需要到 清单文件中进行注册 SoundFragment sf = new SoundFragment(); //拿到一个frament的manager对象 //事务 // 表示使用 SoundFragment去替换掉之前的framelayout transaction.replace(R.id.container, sf); transaction.commit(); &#125; //显示的 public void display(View v)&#123; transaction = manager.beginTransaction(); DisplayFragment df = new DisplayFragment(); transaction.replace(R.id.container, df); transaction.commit(); &#125; //存储的 public void storage(View v)&#123; transaction = manager.beginTransaction(); StorageFragment ssf = new StorageFragment(); transaction.replace(R.id.container, ssf); transaction.commit(); &#125;&#125;DisplayFragment.java@SuppressLint("NewApi")public class DisplayFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; //为fragment声明layout文件,然后将layout文件的显示转换为一个view对象 return inflater.inflate(R.layout.displayfragment, null); &#125;&#125;SoundFragment.java@SuppressLint("NewApi")public class SoundFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; //为fragment声明layout文件,然后将layout文件的显示转换为一个 view 对象 //之前为了将layout文件转换为 view 对象时,调用的是 //View.inflate(context, resource, root) return inflater.inflate(R.layout.soundfragment, null); &#125;&#125;StorageFragment.java@SuppressLint("NewApi")public class StorageFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; //为fragment声明layout文件,然后将layout文件的显示转换为一个 view 对象 return inflater.inflate(R.layout.storagefragment, null); &#125;&#125; 2.1 Fragment 的声明周期 Oncreate : 创建的时候执行 Onstart : 可见的时候执行 Onresume : 获得焦点的时候执行 Onpause : 失去焦点的时候执行 Onstop : 不可见的时候执行 Onrestart : 按了 home 键,重新回到 activity 的时候执行. Ondestory : activity 销毁的时候执行.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[9.安卓基础之内容提供者]]></title>
      <url>%2F2017%2F03%2F28%2F9-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E8%80%85%2F</url>
      <content type="text"><![CDATA[1. 回顾service 开启服务 绑定服务 调用服务中的方法 解绑服务 关闭服务 2. 远程服务调用代码具体实现步骤 第一步 :在远程 service 中去编写一个内部类,让这个内部类集成 Binder,实现 IService 接口,把 IService 接口声明出来 MyAgent extends Binder impelements IService 第二步 :将 IService 接口中的public,private给干掉.并且将扩展名改为.aidl 1234interface IService &#123; void callMethodInService();&#125; 第三步 :回到 service 中的内线类,将其改为继承 IService.Stub类 1234567private class MyAgent extends IService.Stub&#123; @Override public void callMethodInService() &#123; methodInService(); &#125;&#125; 第四步 :在这个内部类中实现的方法中去调用服务中的方法 12345678 @Override public void callMethodInService() &#123; methodInService(); &#125;... public void methodInService()&#123; System.out.println("远程服务中的方法被调用了 "); &#125; 第五步 :回到远程的调用者应用中, bindService,写法与之前一样. 123456//绑定远程服务public void bindservice(View v)&#123; Intent intent = new Intent(); intent.setAction("com.javami.rms"); bindService(intent, new MyConnection(), BIND_AUTO_CREATE);&#125; 第六步 :编写绑定服务的时候,建立的通信频道 MyConnection 12345678910111213141516 private IService agent; private class MyConnection implements ServiceConnection&#123;@Overridepublic void onServiceConnected(ComponentName name, IBinder service) &#123; // agent = (IService )service agent = IService.Stub.asInterface(service);&#125;@Overridepublic void onServiceDisconnected(ComponentName name) &#123;&#125; &#125; 第七步 :在 MyConnection 的方法中,onServiceConnected 中强制类型转换 service 为内线. 1agent = IService.Stub.asInterface(service); 第八步 :通过内线调用服务中的方法 1234567891011 //调用远程服务中的方法 public void call(View v)&#123; System.out.println("调用者调用远程服务中的方法 "); try &#123; agent.callMethodInService();&#125; catch (RemoteException e) &#123; e.printStackTrace();&#125; &#125; 3. 杂谈题android 中如何实现 ipc 通信? 常规的情况下,A应用去激活B应用中的组件的时候,这实际上是一个ipc通信的体现,这个时候发送是Intent就是在做ipc通信,intent也是去实现paraceable接口的,ipc通信时传递的非8种基本类型都需要去实现这个接口,如果是进程间通信,除了使用intent之外,还可以使用远程服务调用,谷歌已经对应用中提供了aidl技术技术供应用之间进行通信. 4. ContentProvider 的学习内容提供者 : 用来提供数据. 4.1 插入删除数据到系统的短信数据库中 先声明读写sms权限 12&lt;uses-permission android:name="android.permission.READ_SMS"/&gt;&lt;uses-permission android:name="android.permission.WRITE_SMS"/&gt; 插入和删除短信的编写 12345678910111213141516171819//插入短信到系统的短信数据库中public void add(View v)&#123; ContentResolver resolver = getContentResolver(); //contentProvider使用的时候必须是以content://打头 Uri uri = Uri.parse("content://sms"); ContentValues values = new ContentValues(); values.put("address", "5201314"); // address values.put("date", System.currentTimeMillis()); // address values.put("type", "1"); // address values.put("body", "亲爱的,我想你了..."); // address resolver.insert(uri,values);&#125;public void delete(View v)&#123; ContentResolver resolver = getContentResolver(); Uri uri = Uri.parse("content://sms"); resolver.delete(uri, "address=?", new String[]&#123;"1 008-6"&#125;);&#125; 4.2 手机监听器的实现 先开启相应的权限 123&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;&lt;uses-permission android:name="android.permission.RECORD_AUDIO"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 启动服务 123456//开启服务public void startService(View v)&#123; Intent intent = new Intent(); intent.setAction("com.vrwait.recoder"); startService(intent);&#125; 实现服务类,先监听电话后实现通话录音 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class PhoneService extends Service &#123; private static final String LOG_TAG = "phoneService"; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; TelephonyManager tm; @Override public void onCreate() &#123; super.onCreate(); //监听电话的状态,如果电话来临,并且拨通了电话,就后台录音 tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); &#125; private class MyPhoneStateListener extends PhoneStateListener&#123; private MyPhoneStateListener(MediaRecorder mRecorder) &#123; this.mRecorder = mRecorder; &#125; @Override public void onCallStateChanged(int state, String incomingNumber) &#123; super.onCallStateChanged(state, incomingNumber); switch (state) &#123; case TelephonyManager.CALL_STATE_IDLE: // 电话空闲 // 停止 录音 if(mRecorder!=null)&#123; stopRecording(); &#125; break; case TelephonyManager.CALL_STATE_OFFHOOK: //电话接通的状态 // 开启 录音 startRecording(); break; case TelephonyManager.CALL_STATE_RINGING: //电话正在响 break; default: break; &#125; &#125; private MediaRecorder mRecorder; // 开始录音 private void startRecording()&#123; // 实例化MediaRecorder mRecorder = new MediaRecorder(); // 指定一个源 mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); //输出的数据的格式 mRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); //文件的保存到哪里 mRecorder.setOutputFile("/mnt/sdcard/yy.3gp"); //使用什么解码器 mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); try&#123; mRecorder.prepare(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; mRecorder.start(); &#125; // 停止录音 private void stopRecording() &#123; mRecorder.stop(); mRecorder.release(); mRecorder = null; &#125; &#125; 务必指定服务对象(启动的服务是从哪里启动的?)12345&lt;service android:name=".PhoneService"&gt; &lt;intent-filter&gt; &lt;action android:name="com.vrwait.recoder"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/service&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[8.安卓基础之service服务]]></title>
      <url>%2F2017%2F03%2F28%2F8-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8Bservice%E6%9C%8D%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[1. service 服务Service是一个应用程序组件，它能够在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其它应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与content provider进行交互，所有这些都是后台进行的。 1.1 编写服务的步骤 继承service类,那么就写 了一个服务 到清单中进行配置 启动服务,关闭服务 注意 :直接开启服务,超时的事,会引发应用程序 ANR(application not responding) ,导致这种问题,是因为主线程中干了耗时的事情,service是运行在主线程中的,主线程是不允许干耗费时间的事儿. 1.2 为什么需要服务android系统会尽可能的保持应用程序进程的一致存在,即是在应用退出后,也仍然这样.但是,如果发现内存不够用,需要去启动新的进程时,那么会按照顺序的优先级去杀死某些老的进程. 进程 : 就是一块独立的内存空间,用来运行程序. android中进程的分类 : 前台进程Forground process : 可以与用户直接进行交互,就是前台进程. 可视进程Visible process : 可以看到,但是不能直接与用户进行交互. 服务进程Service process : 进程中运行了一个服务,在运行着. 后台进程Background process : 在一个activity,现在可以不见.但是在后台运行着. 空进程Empty process : 一个进程中,没有服务,也没有activity,整个程序都已经退出. 重要级别 : 前台进程-&gt;可视进程-&gt;服务进程-&gt;后台进程-&gt;空进程 服务可以长期后台运行,是与当前启动服务的activity是没有关系的. 先在清单注册服务 1&lt;service android:name=".QuickStartService"&gt;&lt;/service&gt; 继承一个服务类 12345678910111213141516171819202122232425262728293031323334353637383940/** * Created by 诸葛亮 on 2016/12/10. * Service : 实际上就是一个没有界面的activity */public class QuickStartService extends Service &#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; private boolean flag; @Override public void onCreate()&#123; super.onCreate(); System.out.print("onCreate服务被创建了:"+Thread.currentThread().getName()); &#125; @Override public void onStart(Intent intent, int startId) &#123; super.onStart(intent, startId); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; System.out.println("服务收到了开启的指令了:onStartCommand" ); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); flag =false; System.out.println("onDestroy服务销毁了 "); &#125;&#125; 在主类中写一些暂停开启服务代码 1234567891011121314151617181920212223242526272829303132package com.javami.quickstartservice;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //开启服务 public void start(View v)&#123; Intent intent = new Intent(); intent.setClass(this,QuickStartService.class); startService(intent); &#125; //关闭服务 public void stop(View v)&#123; Intent intent = new Intent(); intent.setClass(this,QuickStartService.class); stopService(intent); &#125;&#125; 1.3 启动服务的生命周期当点击开启服务,服务会创建,点击关闭服务后,服务会销毁.服务只会在第一次创建调用onCreate,多次开启服务,只会去重复调用onStartCommand,并不会去新创建服务. 所以,多次开启服务的方式,去调用服务中的方法是走不通的,调用不了服务中的方法.需要使用绑定服务去调用服务中的方法. 2. 绑定服务bindService(service,conn,flags) 2.1 编写绑定服务调用服务中的方法的步骤 : 第一步 : 在服务中去编写一个要被外面调用的方法 12345//服务中的方法public void methodInService(String name,int money)&#123; Toast.makeText(this,"服务中的方法被调用...",0).show();&#125; 在服务中提供一个内线,这个内线是继承了Binder类,实现 IService接口 12private class MyAgent extends Binder implements IService&#123;&#125; 编写一个IService接口,提供一个方法 1234public interface IService &#123; public void callMethodInService(String name,int money);&#125; 进到服务内线中,在内线实现接口方法,调用服务中的方法 123456789private class MyAgent extends Binder implements IService&#123; @Override public void callMethodInService(String name, int money) &#123; //调用服务中的方法 methodInService(name,money); &#125;&#125; 在onBind方法中,返回内线 12345@Overridepublic IBinder onBind(Intent intent) &#123; System.out.println("onBind执行了,绑定了服务"); return new MyAgent();&#125; 回到百姓activity中,使用绑定服务的方式去开启服务的内线通讯频道,在通讯频道的ServiceConnection的实现类中的,onServiceConnected中拿到内线的引用. 12345678910111213141516class MyConn implements ServiceConnection &#123; //当成功绑定了服务,返回内线的引用的方法,用于返回内线的对象 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; agent = (IService) service; System.out.println("服务绑定的时候执行了onServiceConnected"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; agent = null; System.out.println("服务绑定的时候执行了onServiceDisconnected"); &#125;&#125; 通过对内线的引用,去调用service中的方法 1234//调用服务中的方法public void callMethodInService(View v)&#123; agent.callMethodInService("kevin",10000);&#125; 2.2 绑定服务的声明周期 绑定服务 : 调用oncreate,onbind方法 解绑服务 : 调用onunbind方法,调用ondestroy方法服务销毁 2.3 混合开启服务的介绍绑定服务可以调用服务中的方法,开启服务可以让服务在后台一直运行.开启服务-&gt;绑定服务-&gt;调用服务中的方法-&gt;解绑服务-&gt;关闭服务 结论 :如果以后需要去后台一直运行服务,而且又想调用服务中的方法,那么请按以上的过程走! 3. 总结从前,一位想要办证的用户,需要直接到某部分办证.但是中国式办证太难.只能找到代理,因为代理里面有在政府上班的人,所以代理能利用一切关系来搞掂证件(从服务里面定义代理与方法),那么某用户找到内线(内线通过中间人IService找到),获得内线后.只是钱和事的问题了!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[7.安卓基础之activity生命周期&receiver广播接收者]]></title>
      <url>%2F2017%2F03%2F28%2F7-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8Bactivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-receiver%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E8%80%85%2F</url>
      <content type="text"><![CDATA[1. ActivityAndroid中的第一个核心的组件,每次创建一个工程,都会创建一个默认的MainActivity. onCreate 在创建对象的时候调用Activity启动后第一个被调用的函数,常用来进行Activity的初始化,例如创建View/绑定数据或恢复信息等. onDestory 在对象销毁的时候调用在Activity被终止前,即进入非活动状态前,该函数被调用. onStart 在界面可见的时候被调用当Activity显示在屏幕时,该函数被调用. onStop 在界面不可见的时候被调用当Activity进入停止状态时,该函数被调用. onPause 当界面处于可见,但是又失去焦点这个阶段的时候会被调用当Activity进入暂停状态时,该函数被调用.一般用来保持持久的数据或释放占用的资源. onReumse 当界面处于可见到获得焦点这段时间被调用当Activity被终止时,即进入非活动状态时,该函数被调用. 1.1 生命周期之记事本的应用12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private EditText ed_content; SharedPreferences sp; //创建时调用 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ed_content = (EditText) findViewById(R.id.ed_content); sp = getSharedPreferences("config",0); String v1 = sp.getString("content",""); ed_content.setText(v1); &#125; //当销毁时调用 @Override protected void onDestroy() &#123; super.onDestroy(); String content = ed_content.getText().toString().trim(); SharedPreferences.Editor edit = sp.edit(); edit.putString("content",content); edit.commit(); Toast.makeText(this,"已默认保存!",0).show(); &#125;&#125; 1.2 生命周期之格斗小游戏的应用 AndroidManifest.xml如果配置了这个属性,当我们横竖屏切换的时候会直接调用onCreate方法中的onConfigurationChanged方法,而不会重新执行onCreate方法,那当然如果不配置这个属性的话就会重新调用onCreate方法了.1&lt;activity android:name=".MainActivity" android:configChanges="keyboardHidden|orientation|screenSize"&gt; 默认的情况下,一个activity声明周期在横竖屏切换的时候,会销毁当前的activity,然后去重新创建一个activity.所以在当前游戏中,会影响到用户的感受. 2. Activity的启动模式Task : 任务,维护记录了当前应用的内存空间中,有哪些组件在运行着.Stack : 栈,栈的特点(后进先出),队列(先进先出) 启动模式(lauchMode)有四种 : standard : 标准的模式,也是默认模式.每次收到intent,那么就会新创建activity的实例出来,放到任务栈中. singleTop : 单一顶部模式如果发现当前的任务栈中的栈顶是当前activity实例,那么就直接使用当前的activity实例,不再创建.(源生的mms编辑短信activity启动模式是singleTop,为了提高用户感受,可以很好的提示用户之前的短信还没有编辑完) singleTask : 单一任务模式表示当前的activity只会在当前任务栈中创建一个实例.如果再次去尝试启动之前的activity时候,当前的activity不是处于任务栈的栈顶,会清空当前处于activity之上的activity.(如果一个activity启动的时候,占用的CPU资源非常多,非常耗内存.而手机中的内存又非常珍贵,那么这个时候就建议使用activity的启动模式设置为:singleTask). 1android:launchMode="singleTask" singleInstance : 单一实例模式如果某个activity的启动模式设置为singleInstance,那么在整个android手机就只会有一个实例了.(对于一些整个系统中,永远都只存在一个同样的界面的activity就会声明使用这种启动模式) 3. broadcastReceiver(广播接收者) 具体实现步骤 : 写个类,继承BroadcastReceiver的类,那么就等价于拥有了一个收音机 到清单manifest文件中进行装电池,配置的问题 调节频道,设置接受广播的类型 在整个android系统中,有很多系统已经定义好的广播事件,这些事件是在系统启动,运行的时候发出的. 例如 : sd卡被挂载 / 开机完成 / 电话拨出 / 应用被安装/被卸载 3.1 编写开机完成广播接收者 AndroidManifest.xml 先开启接收广播权限 1234567&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt; &lt;receiver android:name="com.itheima.bootcompletion.BootCompletionReceiver"&gt; &lt;intent-filter &gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 123456789101112public class BootCompletionReceiver extends BroadcastReceiver &#123; // 监听开机启动完成 @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); System.out.println("开机完成了 .... : " + action); &#125;&#125; 3.2 IP拨号器之广播 AndroidManifest.xml 12345678&lt;!--先声明广播权限,允许一个程序接收到 ACTION_BOOT_COMPLETED广播在系统完成启动--&gt;&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt;&lt;!--然后说明那个广播器,接收什么类型的广播--&gt;&lt;receiver android:name=".OutPhone"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; MainActivity.java的代码实现 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; private EditText ed_phone; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ed_phone = (EditText)findViewById(R.id.ed_prefix); &#125; public void save(View v)&#123; String prefix = ed_phone.getText().toString().trim(); if(TextUtils.isEmpty(prefix))&#123; Toast.makeText(this,"ip号码不能为空",0).show(); return; &#125; SharedPreferences sp = getSharedPreferences("config",0); SharedPreferences.Editor editor = sp.edit(); editor.putString("prefix",prefix); editor.commit(); Toast.makeText(this,"IP前缀保存成功",0).show(); &#125;&#125; OutPhone.java 123456789101112131415public class OutPhone extends BroadcastReceiver &#123; //alt+enter补全代码 @Override public void onReceive(Context context, Intent intent) &#123; SharedPreferences sp = context.getSharedPreferences("config",0); String ipdata = sp.getString("prefix",""); if(ipdata.startsWith("0"))&#123; //说明是长途电话 setResultData(ipdata); &#125; &#125;&#125; 3.2 对应用内的数据进行统计之广播 AndroidManifest.xml 1234567&lt;receiver android:name="com.javami.bigdatacollect.AppStatusReceiver"&gt; &lt;intent-filter &gt; &lt;action android:name="android.intent.action.PACKAGE_ADDED"/&gt; &lt;action android:name="android.intent.action.PACKAGE_REMOVED"/&gt; &lt;data android:scheme="package"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; AppStatusReceiver.java 12345678910111213141516public class AppStatusReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); System.out.println(action); if("android.intent.action.PACKAGE_ADDED".equals(action))&#123; System.out.println("应用安装了: " + intent.getData()); &#125;else if("android.intent.action.PACKAGE_REMOVED".equals(action))&#123; System.out.println("应用卸载了 " + intent.getData()); &#125; &#125;&#125; 4. 自定义广播4.1 无序广播123456public void sendBroadcast(View v)&#123; System.out.println("发出自定义的广播了"); Intent intent = new Intent(); intent.setAction("com.javami.honey"); sendBroadcast(intent); // 发送一个广播出去&#125; 4.2 接收自定义广播 AndroidManifest.xml 12345&lt;receiver android:name=".MyBroadCastReciver"&gt; &lt;intent-filter&gt; &lt;action android:name="com.javami.honey"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; MyBroadCastReciver.java 123456public class MyBroadCastReciver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; System.out.println("收到了广播 : " + intent.getAction()); &#125; 4.2 有序广播 AndroidManifest.xml 123456789101112131415&lt;receiver android:name=".ShengZhang"&gt;&lt;!--数字越大,优先级别越高--&gt;&lt;intent-filter android:priority="1000"&gt; &lt;!--隐式调用广播--&gt; &lt;action android:name="com.javmai.send.Money"&gt;&lt;/action&gt;&lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=".Baixing"&gt; &lt;!--数字越大,优先级别越高--&gt; &lt;intent-filter android:priority="5000"&gt; &lt;!--隐式调用指定的广播--&gt; &lt;action android:name="com.javmai.send.Money"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; MainActivity.java 1234567891011121314public void sendMarshroom(View v)&#123; Intent intent = new Intent(); // intent : 设置一个意图行动 intent.setAction("com.javmai.send.Money"); // intent : 意图对象 // receiverPermission : 接收广播的 组件需要什么样的权限 // resultReceiver : 广播事件的最终 接收者 // scheduler : 调度器 // initialCode : 发送广播时的初始码 // initialData : 广播 发出的 原始数据 -- 未被 修改过的原始数据 // initialExtras : 广播发出时的一些额外的数据 sendOrderedBroadcast(intent,null,new FinalResultReveiver(),null,1,"每人1000元",null);&#125; ShengZhang.java and BaiXing.java and FinalResultReceiver.java 1234567891011121314151617181920212223public class ShengZhang extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; String money = getResultData(); setResultData("500元"); System.out.print("收到"+money); &#125;public class Baixing extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; String money = getResultData(); System.out.print("收到"+money); &#125;&#125;public class FinalResultReveiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //纪委部 String money = getResultData(); System.out.print("实际百姓只收到"+money); &#125; 有序广播和无序广播的区别 有序广播可以在特定的接收者收到广播后,取消广播的继续发送,并且可以更改广播的数据.而无序广播是不能取消广播的发送,不可以更改广播的内容. 5. 手机锁屏解锁之广播接收者 MainActivity.java 1234567891011121314151617181920212223242526private PhoneScreenListener phoneReceiver;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册监听手机解锁/锁屏的广播接收者 phoneReceiver = new PhoneScreenListener(); IntentFilter filter = new IntentFilter(); filter.addAction("android.intent.action.SCREEN_OFF"); filter.addAction("android.intent.action.SCREEN_ON"); //注册广播接收者 registerReceiver(phoneReceiver, filter);&#125;@Overrideprotected void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); // 解除注册 的 广播接收者 unregisterReceiver(phoneReceiver);&#125; PhoneScreenListener.java 12345678910public class PhoneScreenListener extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; System.out.println("========= 手机 屏幕 解锁或者锁屏了 "); &#125;&#125; 6. 总结 先写一个类继承broadCastReceiver的类 1public class SmsListener extends BroadcastReceiver 写清单配置这个类 12345&lt;receiver android:name="com.javami.smslistener.SmsListener"&gt; &lt;intent-filter android:priority="1000"&gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 调节频道接收这个类 1public void onReceive(Context context, Intent intent) &#123;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[6.安卓基础之多线程下载&Activity]]></title>
      <url>%2F2017%2F03%2F28%2F6-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD-Activity%2F</url>
      <content type="text"><![CDATA[1. 利用开源框架-xUtils-master-实现多线程下载 需要开启如下权限 123&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 实现代码 12345678910111213public void download(View v)&#123; String path = ed_path.getText().toString().trim(); HttpUtils util = new HttpUtils(); util.download(path, "/mnt/sdcard/jjyy.exe", true, new RequestCallBack&lt;File&gt;() &#123; @Override public void onSuccess(ResponseInfo&lt;File&gt; responseInfo) &#123; toastshow.setText("下载成功"); &#125; @Override public void onFailure(HttpException error, String msg) &#123; toastshow.setText("下载失败!"); &#125; &#125;); 2. 多界面应用的实现 每个应用都可以实现多个界面,如果一个应用需要多个界面,那么需要在应用中添加多个activity就可以. 一般情况下,一个应用内部的组件可以使用显示意图也可以使用隐式意图去激活这个组件,但是如果一个外部应用中,想激活另一个应用的组件时,一般推荐使用隐式意图. 从AndroidManifest.xml注册一个Activity 12345678 &lt;!-- 注册一个activity --&gt;&lt;activity android:name=".SecondActivity"&gt; &lt;intent-filter&gt; &lt;!-- MAIN : 表示程序入口,LAUNCHER : 表示应用程序可以从laucher启动 --&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 设置两个activity_main.xml布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- activity_main.xml --&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.javami.twoactivity.MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" /&gt;&lt;/RelativeLayout&gt;&lt;!-- activity_main2.xml --&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.javami.twoactivity.MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World2!" /&gt;&lt;/RelativeLayout&gt;```在SecondActivity引入新的布局文件```javapublic class SecondActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); &#125;&#125; 2.1 人品计算器的实现 务必注册一个活动 1&lt;activity android:name=".SecondActivity"&gt;&lt;/activity&gt; activity_main.xml的写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;RadioGroup android:id="@+id/rgb" android:layout_width="fill_parent" android:orientation="horizontal" android:layout_height="wrap_content" &gt; &lt;RadioButton android:id="@+id/male" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content" android:checked="true" android:text="男" /&gt; &lt;RadioButton android:id="@+id/female" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:text="女" /&gt; &lt;RadioButton android:id="@+id/unknown" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content" android:text="未知" /&gt; &lt;/RadioGroup&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" &gt; &lt;EditText android:id="@+id/ed_name" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="3" /&gt; &lt;Button android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:onClick="cacl" android:text="计算" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:id="@+id/rp_value" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; activity_main2.xml的写法 12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="#44ff0000" tools:context=".MainActivity" &gt; &lt;TextView android:id="@+id/rp_value" android:text="我是第二个界面" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;ImageView android:id="@+id/iv" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; MainActivity.java的写法 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private EditText ed_name; private TextView tv_rp; private RadioGroup rgb; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ed_name = (EditText)findViewById(R.id.ed_name); tv_rp = (TextView) findViewById(R.id.rp_value); rgb = (RadioGroup)findViewById(R.id.rgb); &#125; public void cacl(View v)&#123; String name = ed_name.getText().toString().trim(); if(TextUtils.isEmpty(name))&#123; Toast.makeText(this,"姓名不能为空",0).show(); return; &#125; //将内容A---&gt;B Intent intent = new Intent(); intent.setClass(this,SecondActivity.class); intent.putExtra("name",name); intent.putExtra("sex",rgb.getCheckedRadioButtonId()); intent.putExtra("img", BitmapFactory.decodeResource(getResources(),R.drawable.cat)); startActivity(intent); &#125;&#125; SecondActivity.java的写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SecondActivity extends Activity &#123; private TextView rp_value; private ImageView iv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); rp_value = (TextView)findViewById(R.id.rp_value); iv = (ImageView)findViewById(R.id.iv); //拿到激活SecondActivity是那个意图的对象 Intent intent = getIntent(); String name = intent.getStringExtra("name"); int sex = intent.getIntExtra("sex",R.id.male); Bitmap img = intent.getParcelableExtra("img"); iv.setImageBitmap(img); byte[] bb = null; try&#123; switch (sex)&#123; case R.id.male: //将UTF-8编码变为二进制数据 bb = name.getBytes(); break; case R.id.female: bb = name.getBytes("gbk"); break; case R.id.unknown: bb = name.getBytes("iso8859-1"); break; default: break; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; byte[] result = bb; int total = 0; for (byte b : result)&#123; int data = b&amp;0xff; total = total+Math.abs(data); &#125; int rp = total%100; String data = null; if(rp&gt;90)&#123; data = "good!"; &#125;else if (rp&gt;60)&#123; data = "happy"; &#125;else if(rp&gt;30)&#123; data = "sad"; &#125;else&#123; data = "I'm 5555..."; &#125; rp_value.setText(data); &#125;&#125; 2.2 短信助手的应用 开启短信发送权限与活动的注册 1234&lt;activity android:name=".SmsAcitivityList"&gt;&lt;/activity&gt;&lt;activity android:name=".ContactListActivity"&gt;&lt;/activity&gt;&lt;uses-permission android:name="android.permission.SEND_SMS"&gt;&lt;/uses-permission&gt; activity_main.xml的写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" &gt; &lt;EditText android:id="@+id/ed_contact" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="3" android:hint="请输入联系人" /&gt; &lt;Button android:onClick="selectContact" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:text="+" /&gt; &lt;/LinearLayout&gt; &lt;EditText android:id="@+id/sms_body" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="请输入短信内容" android:lines="5" /&gt; &lt;Button android:onClick="selectMsg" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="选择短信的模版" /&gt; &lt;Button android:onClick="sendmsg" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="点击发送短信" /&gt;&lt;/LinearLayout&gt; contact_item.xml的写法 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt;&lt;/TextView&gt; contactslist.xml的写法 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/contacts_lv" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; smsitem.xml的写法 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt;&lt;/TextView&gt; smslist.xml的写法 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;ListView android:id="@+id/lv" android:layout_width="fill_parent" android:layout_height="fill_parent" &gt;&lt;/ListView&gt;&lt;/LinearLayout&gt; ContactListActivity.java的写法 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Created by 诸葛亮 on 2016/11/20. */public class ContactListActivity extends Activity &#123; String[] contacts =&#123; "13987654321", "18217180124", "13687987653", "13687987222", "13687987555", "13687987666", &#125;; private ListView contacts_lv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.contactslist);//需要传入菜单 contacts_lv = (ListView)findViewById(R.id.contacts_lv); contacts_lv.setAdapter(new ArrayAdapter&lt;String&gt;(this,R.layout.contact_item,contacts)); //添加一个item监听器 contacts_lv.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; String contact = contacts[position]; Intent intent = new Intent(); intent.putExtra("contact",contact); setResult(0,intent); finish(); &#125; &#125;); &#125;&#125; MainActivity.java的写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MainActivity extends AppCompatActivity &#123; private EditText sms_body; private EditText ed_contact; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sms_body = (EditText)findViewById(R.id.sms_body); ed_contact = (EditText)findViewById(R.id.ed_contact); &#125; //选择联系人 public void selectContact(View v)&#123; Intent intent = new Intent(); intent.setClass(this,ContactListActivity.class); startActivityForResult(intent,1); &#125; //选择短信 public void selectMsg(View v)&#123; Intent intent = new Intent(); intent.setClass(this,SmsAcitivityList.class); startActivityForResult(intent,2); &#125; //发送普通文本内容内的短信，使用的是SmsMessage类的sendTextMessage()方法 //首先调用SmsMessage类的getDefault()方法获取到SmsMessage的实例对象 final SmsManager smsManager = SmsManager.getDefault(); public void sendmsg(View v)&#123; /* * destinationAddress：手机号码 * scAddress：服务中心号码 * text：短信内容 * sentIntent：PendingIntent，信息发送成功或失败时触发 * deliveryIntent：PendingIntent，信息抵达收件人触发 */ System.out.print(ed_contact.getText().toString().trim()); smsManager.sendTextMessage(ed_contact.getText().toString().trim(),null,sms_body.getText().toString().trim(),null,null); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if(requestCode==1)&#123; if(data!=null)&#123; String contact = data.getStringExtra("contact"); ed_contact.setText(contact); &#125; &#125;else if (requestCode==2)&#123; if(data!=null)&#123; String msg = data.getStringExtra("msg"); sms_body.setText(msg); &#125; &#125; super.onActivityResult(requestCode, resultCode, data); &#125;&#125; SmsAcitivityList.java的写法 123456789101112131415161718192021222324252627282930313233343536/** * Created by 诸葛亮 on 2016/11/20. */public class SmsAcitivityList extends Activity &#123; private ListView lv; String[] msgs = &#123; "想到你的名字心就会砰砰跳！看到你的容颜脸就会火辣辣烧！牵你的手像云朵轻轻飘！你可知道？我被你彻底迷倒！发誓要和你一起变老", "你是否愿意给我一个依靠：可以让我在红尘的烦恼与喧嚣中一想到你，就会有甜蜜的平静和无穷的动力，就会有足够的勇气继续向前走。", "命运让我们相遇，让我沉醉在你的眼眸里。我想陪着你，为你阻挡一生的风雨。请你相信，我会让你的生命，充满快乐回忆！", "我会把心里最好的地方留给你，只要你敲敲门，我就拥你入怀。因为爱你，愿意为你在这世界造一处平台，与你纵观爱情的古往今来。", "不经意间，相遇；不经意间，相惜；不经意间，刻骨；不经意间，铭记；不经意间，爱上了你。看似不经意，但我真的很在意。", &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.smslist); lv = (ListView)findViewById(R.id.lv); //设置一个适配器,将意图的内容出传递进去 lv.setAdapter(new ArrayAdapter&lt;String&gt;(this,R.layout.smsitem,msgs)); lv.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; String msg = msgs[position]; Intent intent = new Intent(); intent.putExtra("msg",msg); setResult(0,intent); finish(); &#125; &#125;); &#125;&#125; 2.3 给一段文字使用版权链接 开启联网权限 1&lt;uses-permission android:name="android.permission.INTERNET"&gt;&lt;/uses-permission&gt; 基础代码的写法 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private TextView links; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); links = (TextView)findViewById(R.id.links);/* *&lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:scheme="http" /&gt; &lt;data android:scheme="https" /&gt; &lt;data android:scheme="about" /&gt; &lt;data android:scheme="javascript" /&gt;&lt;/intent-filter&gt; */ links.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("android.intent.action.VIEW"); intent.setData(Uri.parse("http://www.fkcat.com")); startActivity(intent); &#125; &#125;); &#125;&#125; 3. 总结加强与总结,多实践代码!并且看谷歌官方文档!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[5.安卓基础之网络编程&开源框架&多线程下载]]></title>
      <url>%2F2017%2F03%2F28%2F5-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[1. 简单的xml联网读取 需要在AndroidManifest.xml开启权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 定义一个工具流 1234567891011121314public class StreamTool &#123; public static String decodeStream(InputStream in) throws Exception&#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[]buf = new byte[1024]; int len = 0; while((len=in.read(buf))&gt;0)&#123; baos.write(buf,0,len); &#125; return baos.toString(); &#125;&#125; 定义一个NewsItem 123456789101112131415161718192021222324252627282930313233343536373839public class NewsItem &#123; private String title; private String description; private String image; private String type; private String comment; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getImage() &#123; return image; &#125; public void setImage(String image) &#123; this.image = image; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getComment() &#123; return comment; &#125; public void setComment(String comment) &#123; this.comment = comment; &#125;&#125; 定义一个NewsService,通过处理数据返回List 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class NewsService &#123; public static List&lt;NewsItem&gt; getAllNewsItem(final String path)&#123; final List&lt;NewsItem&gt; items = new ArrayList&lt;NewsItem&gt;(); new Thread()&#123; public void run() &#123; try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //设置超时时间 conn.setConnectTimeout(5000); conn.setRequestMethod("GET"); int code = conn.getResponseCode(); if(code==200)&#123; InputStream in = conn.getInputStream(); XmlPullParser parser = Xml.newPullParser(); parser.setInput(in, "utf-8"); int type = parser.getEventType(); NewsItem item=null; while(type!=XmlPullParser.END_DOCUMENT)&#123; if(type==XmlPullParser.START_TAG)&#123; if("item".equals(parser.getName()))&#123; item = new NewsItem(); &#125;else if("title".equals(parser.getName()))&#123; item.setTitle(parser.nextText()); &#125;else if("description".equals(parser.getName()))&#123; item.setDescription(parser.nextText()); &#125;else if("image".equals(parser.getName()))&#123; item.setImage(parser.nextText()); &#125;else if("type".equals(parser.getName()))&#123; item.setType(parser.nextText()); &#125;else if("comment".equals(parser.getName()))&#123; item.setComment(parser.nextText()); &#125; &#125;else if(type==XmlPullParser.END_TAG)&#123; //将 item 添加到一个 list集合中 if(item!=null)&#123; items.add(item); &#125; &#125; type = parser.next(); &#125; &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;.start(); return items; &#125;&#125; 定义一个MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MainActivity extends AppCompatActivity &#123; private String path = "http://www.itceo.net/test/news.xml"; private List&lt;NewsItem&gt; items =null; private ListView lv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); lv = (ListView) findViewById(R.id.lv); items = NewsService.getAllNewsItem(path); // 将item中的数据绑定到屏幕显示 loadData(); &#125; //声明adapter private MyAdapter myadapter; private void loadData() &#123; if(myadapter==null)&#123; myadapter = new MyAdapter(); lv.setAdapter(myadapter); &#125;else&#123; //通知数据改变 myadapter.notifyDataSetChanged(); &#125; &#125; private class MyAdapter extends BaseAdapter&#123; //指定到底有多少个item要显示在 lv 中 @Override public int getCount() &#123; return items.size(); &#125; //这个方法是在每次显示一个item时会被调用到的 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; View v ; if(convertView==null)&#123; v=View.inflate(MainActivity.this, R.layout.item, null); &#125;else&#123; v = convertView; &#125; //拿到当前位置newsItem对象 NewsItem newsItem = items.get(position); //找到item中每个 控件 SmartImageView siv = (SmartImageView) v.findViewById(R.id.item_iv); TextView title= (TextView) v.findViewById(R.id.item_title); TextView desc = (TextView) v.findViewById(R.id.item_desc); TextView type = (TextView) v.findViewById(R.id.item_type); title.setText(newsItem.getTitle()); desc.setText(newsItem.getDescription()); String tp = newsItem.getType(); if("1".equals(tp))&#123; //就是评论 type.setText("评论: "+ newsItem.getComment()); type.setTextColor(Color.YELLOW); &#125;else if("2".equals(tp))&#123; //就是视频 type.setText("视频"); type.setTextColor(Color.RED); &#125;else if("3".equals(tp))&#123; // 就是直播 type.setText("Live直播 "); type.setTextColor(Color.BLUE); &#125; //利用开源图片显示库 siv.setImageUrl(newsItem.getImage()); return v; &#125; @Override public Object getItem(int position) &#123; // TODO Auto-generated method stub return null; &#125; @Override public long getItemId(int position) &#123; // TODO Auto-generated method stub return 0; &#125; &#125;&#125; activity_main.xml与item.xml的编写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364activity_main.xml:&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" &gt; &lt;ListView android:id="@+id/lv" android:layout_width="fill_parent" android:layout_height="fill_parent" &gt;&lt;/ListView&gt;&lt;/LinearLayout&gt;item.xml:&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.loopj.android.image.SmartImageView android:id="@+id/item_iv" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentLeft="true" /&gt; &lt;TextView android:id="@+id/item_title" android:text="标题" android:layout_toRightOf="@id/item_iv" android:layout_width="fill_parent" android:textSize="20sp" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/item_desc" android:textSize="15sp" android:layout_below="@id/item_title" android:lines="2" android:text="描述xxxxxxxxxxxxxxxx" android:textColor="#55000000" android:layout_toRightOf="@id/item_iv" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/item_type" android:layout_below="@id/item_desc" android:textSize="15sp" android:text="类型:" android:textColor="#55000000" android:layout_alignParentRight="true" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;View android:background="#44ffffff" android:layout_width="fill_parent" android:layout_height="1dip" /&gt;&lt;/RelativeLayout&gt; 2. get与post的关系 2.1 get的关系如果在发送数据的过程中,传输了中文数据,那么是需要进行url编码的,否则带不过去.1234http://192.168.1.100:8080/web_login/login?number=%E5%93%88%E5%93%88&amp;pwd=520http://192.168.1.100:8080/web_login/login?number=5201314&amp;pwd=520path = path+&quot;number=&quot;+URLEncoder.encode(number, &quot;UTF-8&quot;)+&quot;&amp;pwd=&quot;+URLEncoder.encode(pwd, &quot;UTF-8&quot;); 2.2 post的关系123456789101112131415161718URL url = new URL(path);HttpURLConnection conn = (HttpURLConnection) url.openConnection();conn.setRequestMethod("POST");conn.setConnectTimeout(5000);// Content-Type: application/x-www-form-urlencodedconn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");//准备好数据 ---- number=erwan&amp;pwd=456String data = "number="+URLEncoder.encode(number, "utf-8")+"&amp;pwd="+URLEncoder.encode(pwd, "utf-8");//Content-Length: 20conn.setRequestProperty("Content-Length", data.length()+"");//这个地方表示告诉加了一个标志, 要给服务器写数据了conn.setDoOutput(true); conn.getOutputStream().write(data.getBytes()); 2.3 apache-httpclient-get12345678910111213//客户端浏览器HttpClient client = new DefaultHttpClient();//get 方式请求的必要的参数HttpGet get = new HttpGet(path);//http://192.168.1.100:8080/web_login/login//收到的来自于服务器端的响应的 数据HttpResponse response = client.execute(get);// HTTP/1.1 200 OKint code = response.getStatusLine().getStatusCode(); 2.4 apache-httpclient-post123456789101112131415161718192021222324252627//客户端浏览器HttpClient client = new DefaultHttpClient();//指定了发送的请求的方式HttpPost post = new HttpPost(path);//传递给服务器要带过去的参数的信息 List&lt;NameValuePair&gt; list = new ArrayList&lt;NameValuePair&gt;();//将带过去的参数放到一个nameValuePair 中, 然后再放到 一个list 中,然后再将这个list给要带过去的数据实体list.add(new BasicNameValuePair("number", number));list.add(new BasicNameValuePair("pwd", pwd));//设置带给服务器的参数的信息//number=5201314&amp;pwd=123//设置要带给服务器的数据实体post.setEntity(new UrlEncodedFormEntity(list,"UTF-8"));//http://192.168.1.100:8080/web_login/login//收到的来自于服务器端的响应的数据HttpResponse response = client.execute(post);//http 的相应分为响应行,响应头,响应体//HTTP/1.1 200 OKint code = response.getStatusLine().getStatusCode(); 2.5 开源android-async-http-master-get1234567891011121314151617181920String path = "http://192.168.1.100:8080/web_login/login?number="+number+"&amp;pwd="+pwd;AsyncHttpClient client = new AsyncHttpClient();client.get(path, new AsyncHttpResponseHandler() &#123; //请求成功的时候 会被调用的 @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) &#123; tv_status.setText(new String(responseBody)); &#125; //请求失败的时候会被调用的 @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) &#123; error.printStackTrace(System.out); Toast.makeText(MainActivity.this, "对不起, 俺错误了...", 0).show(); &#125;&#125;); 2.6 开源android-async-http-master-post12345678910111213141516171819202122232425String path = "http://192.168.1.100:8080/web_login/login";AsyncHttpClient client = new AsyncHttpClient();//封装了api , 使用到了handler 去 处理了 这些事儿 ...RequestParams params = new RequestParams();// number=5201314&amp;pwd=123params.add("number", number);params.add("pwd", pwd);client.post(path, params, new AsyncHttpResponseHandler()&#123; @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) &#123; tv_status.setText(new String(responseBody)); &#125; @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) &#123; error.printStackTrace(System.out); Toast.makeText(MainActivity.this, "出错误了 ", 0).show(); &#125;&#125;); 3. 多线程与断点续传实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public class ThreadDownload &#123; //规定下载服务端的资源使用3条线程去下载 private static int threadCount = 3; private static int currentRunningThread = 3; private static String path = "http://down.qq.com/cf/dltools/CrossFire_OBV4.0.5.0_Full_QQVIPDL_speeded_signed.exe"; public static void main(String[] args) &#123; try&#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5000); conn.setRequestMethod("GET"); int code = conn.getResponseCode(); if(code==200)&#123; //拿到文件的长度大小 int length = conn.getContentLength(); File file = new File(getFileName(path)); RandomAccessFile raf = new RandomAccessFile(file, "rw"); raf.setLength(length); raf.close(); //启动线程去下载文件 //获得每块线程的平均大小 int blockSize = length / threadCount; //总文件长度大小/3 //threadId:线程的id threadcount:几条线程下载 for(int threadId=0;threadId&lt;threadCount;threadId++)&#123; int startIndex = threadId * blockSize; //0~2 int endIndex = (threadId+1)*blockSize-1;//3~5 //如果线程是最后的一个线程 if(threadId==(threadCount-1))&#123; endIndex = length-1; &#125; new DownloadFilePartThread(threadId,startIndex,endIndex).start(); &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static class DownloadFilePartThread extends Thread&#123; //线程的id号 private int threadId; //线程的下载开始位置 private int startIndex; //线程的下载的结束位置 private int endIndex; //当前线程下载到的位置 private int currentPostion; public DownloadFilePartThread(int threadId,int startIndex,int endIndex)&#123; this.threadId = threadId; this.startIndex = startIndex; this.endIndex = endIndex; currentPostion = startIndex; &#125; public void run()&#123; System.out.println("第 " + threadId + "线程开始 下载了 : 下载 从 " + startIndex + "~ " + endIndex); try&#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5000); conn.setRequestMethod("GET"); // 在多线程下载的时候,每条线程只需要目标文件的一部分的数据 // 需要告诉服务器,只需要那一段的数据 // 通过设置 http的请求头可以去实现 ,告诉 服务器,只需要目标 段的数据 // startIndex ---- endIndex conn.setRequestProperty("range", "bytes="+startIndex+"-"+endIndex); //获得服务器返回的目标段的数据 File file = new File(getFileName(path)); RandomAccessFile raf = new RandomAccessFile(file, "rw"); File ilf = new File(threadId+".position"); if(ilf.exists()&amp;&amp;ilf.length()&gt;0)&#123; BufferedReader br = new BufferedReader(new FileReader(ilf)); String vl = br.readLine(); int alreadyWritePosition = Integer.parseInt(vl); //告诉服务器要数据的时候 ,从这个位置开始要 conn.setRequestProperty("range", "bytes="+alreadyWritePosition+"-"+endIndex); raf.seek(alreadyWritePosition); System.out.println("下载过了!"); &#125;else&#123; System.out.println("没下载过!"); conn.setRequestProperty("range", "bytes="+startIndex+"-"+endIndex); //表示从哪里开始 raf.seek(startIndex); &#125; int code = conn.getResponseCode(); if(code == 206)&#123; //拿到数据 InputStream in = conn.getInputStream(); int len = 0; byte[]buf = new byte[1024*1024*1024*1024*1024*1024*1024*1024*1024]; while((len=in.read(buf))&gt;0)&#123; raf.write(buf,0,len); //将实时的位置记录了之后,方便下面紧接着去往文件中去写 currentPostion = currentPostion + len; File info = new File(threadId+".position"); RandomAccessFile rf = new RandomAccessFile(info, "rwd"); rf.write(String.valueOf(currentPostion).getBytes()); rf.close(); &#125; in.close(); raf.close(); &#125; System.out.println("第 " + threadId + "线程下载 结束了"); // 等着所有的线程都下载完成再删文件 // 弄一个 计数器,记住总共有多少条线程正在下载,每当一条线程下载完成,走到这里的时候,就将计数器-1 一下 // 当发现计数器小于或者等于0 的时候,说明没有线程正在下载,所以这个时候,再去删记录了下载位置的文件 synchronized (ThreadDownload.class) &#123; currentRunningThread--; if(currentRunningThread&lt;=0)&#123; //将记录下载位置的文件删除 for(threadId=0;threadId&lt;threadCount;threadId++)&#123; File fff = new File(threadId+".position"); fff.renameTo(new File(threadId+".position.finish")); File fll = new File(threadId+".position.finish"); fll.delete(); &#125; &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static String getFileName(String path) &#123; int index = path.lastIndexOf("/"); return path.substring(index+1); &#125;&#125; 4. 总结多线程下载还需要深入了解.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[4.安卓基础之网络编程&json解析]]></title>
      <url>%2F2017%2F03%2F28%2F4-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-json%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[1. ListView的使用步骤 首先在layout文件中定义一个listview 找到定义的listview控件,设置一个适配器(adapter) 在适配器中将要绑定listview中的数据传递给adapter MVC 的设计思想 M:数据 V:listview C:adapter 2. AnimationDrawable 的使用: 先在drawable准备好图片 在xml文件里面设置根元素和子原始 代码中调用 123456789101112131415161718AnimationDrawable rocketAnimation;public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image); rocketImage.setBackgroundResource(R.drawable.rocket_thrust); rocketAnimation = (AnimationDrawable) rocketImage.getBackground();&#125;public boolean onTouchEvent(MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; rocketAnimation.start(); return true; &#125; return super.onTouchEvent(event);&#125; 3. Android的国际化相关常见的有：zh_cn: 简体中文zh_hk: 繁体中文(中国香港)zh_tw: 繁体中文(中国台湾地区)en-hk: 英语(香港)en_us: 英语(美国)en_gb: 英语(英国)en_ww: 英语(全球)ja_jp: 日语(日本)ko_kr: 韩文(韩国) 在Android工程的res目录下,通过定义特殊的文件夹名称就可以实现多语言支持.比如我们的程序兼容简体中文/英文,在values文件夹中建立默认strings.xml,再建立values-zh-rCN文件夹. 在每个文件夹里放置一个strings.xml,strings.xml里是各种语言字符串.如果涉及到参数配置类xml文件夹名称也要改成xml-zh/xml.这样在android的系统中进行语言切换,所开发的程序也会跟着切换语言. 12345Resources resources = getResources();//获得res资源对象Configuration config = resources.getConfiguration();//获得设置对象DisplayMetrics dm = resources .getDisplayMetrics();//获得屏幕参数：主要是分辨率,像素等.config.locale = Locale.SIMPLIFIED_CHINESE; //简体中文resources.updateConfiguration(config, dm); 4. Android 连接网络,获得数据 先定义一个秘书:Handler handler = new Handler() 获取到一个篮子:Message msg = Message.obtain(); 让篮子交给秘书处理:msg.obj = data;通过生活的例子融入代码的想法中,在耗时的事儿不允许放在主线程中去完成. 4.1 在线获得网址的图片 需要在AndroidManifest.xml开启权限 1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 在主线程重写handler的handleMessage( )方法,在工作线程发送消息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class MainActivity extends AppCompatActivity &#123; protected static final int SUCCESS = 0; protected static final int NETWORK_ERROR = 1; protected static final int ERROR = 2; private EditText ed_path; private ImageView iv; private String path; private Handler mHandler = new Handler()&#123; public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SUCCESS: //取出消息中的数据 Bitmap bitmap = (Bitmap) msg.obj; iv.setImageBitmap(bitmap); break; case NETWORK_ERROR: Toast.makeText(MainActivity.this, "连接错误 ....", 0).show(); break; case ERROR: Toast.makeText(MainActivity.this, " 获得资源失败 ....", 0).show(); break; default: break; &#125; &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ed_path = (EditText) findViewById(R.id.ed_path); iv = (ImageView) findViewById(R.id.iv); &#125; public void gogetImage(View v)&#123; path = ed_path.getText().toString().trim(); if(TextUtils.isEmpty(path))&#123; Toast.makeText(this, "路径有错误...", 0).show(); return; &#125; new Thread()&#123; public void run() &#123; try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5000); //设置请求的方式 conn.setRequestMethod("GET"); //拿到返回的数据的类型 String contentType = conn.getContentType(); //数据的长度 int length = conn.getContentLength(); // 获得服务器返回的状态码 , 根据状态码去判断是否成功 int code = conn.getResponseCode(); if(code==200)&#123; InputStream in = conn.getInputStream(); Bitmap bitmap = BitmapFactory.decodeStream(in); Message msg = Message.obtain(); msg.what=SUCCESS; msg.obj = bitmap; mHandler.sendMessage(msg); in.close(); &#125;else&#123; Message msg = Message.obtain(); msg.what=ERROR; mHandler.sendMessage(msg); &#125; &#125; catch (Exception e) &#123; Message message = Message.obtain(); message.what= NETWORK_ERROR; mHandler.sendMessage(message); e.printStackTrace(); &#125; &#125;; &#125;.start(); &#125;&#125; activity_main.xml的实现 1234567891011121314151617181920&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" xmlns:tools="http://schemas.android.com/tools" android:orientation="vertical" tools:context=".MainActivity" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="wrap_content" android:id="@+id/ed_path"/&gt; &lt;Button android:onClick="gogetImage" android:text="Get" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;ImageView android:id="@+id/iv" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 4.2 网页源码查看器的实现 需要在AndroidManifest.xml开启权限 1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 在主线程中重写hander的handleMessage()方法,让工作线程发送信息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MainActivity extends AppCompatActivity &#123; protected static final int SUCCESS = 0; protected static final int ERROR = 1; protected static final int NETWORK_ERROR = 2; private EditText ed_path; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ed_path = (EditText) findViewById(R.id.ed_path); tv = (TextView)findViewById(R.id.tv); &#125; //定义一个秘书 Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; switch (msg.what)&#123; case SUCCESS: String value = (String) msg.obj; tv.setText(value); break; case ERROR: Toast.makeText(MainActivity.this,"ERROR",0).show(); break; case NETWORK_ERROR: Toast.makeText(MainActivity.this,"NETWORK_ERROR",0).show(); break; default: break; &#125; &#125; &#125;; String path = null; public void viewPageSource(View view)&#123; path = ed_path.getText().toString().trim(); if(TextUtils.isEmpty(path))&#123; Toast.makeText(MainActivity.this,"PATH NOT NOT!",0).show(); return; &#125; //否则连接网络，启动一个新的线程 new Thread()&#123; public void run()&#123; try&#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //设置连接超时为5秒钟 conn.setConnectTimeout(5000); conn.setRequestMethod("GET"); //这句能伪装成电脑访问 conn.setRequestProperty("User-Agent", "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; WOW64; Trident/6.0)"); String contentType = conn.getContentType(); int code = conn.getResponseCode(); if(code == 200)&#123; InputStream in = conn.getInputStream(); String data = StreamTool.decodeStream(in); //Message 称为篮子 Message msg = Message.obtain(); msg.what = SUCCESS; msg.obj = data; handler.sendMessage(msg); &#125;else&#123; Message msg = Message.obtain(); msg.what = ERROR; handler.sendMessage(msg); &#125; &#125;catch (Exception e)&#123; Message msg = Message.obtain(); msg.what = NETWORK_ERROR; handler.sendMessage(msg); &#125; &#125; &#125;.start(); &#125; 定义一个底层流实现代码 1234567891011public static String decodeStream(InputStream in) throws IOException&#123; //底层流 ByteArrayOutputStream bas = new ByteArrayOutputStream(); int len = 0; byte[] buf = new byte[1024]; while ((len=in.read(buf))&gt;0)&#123; bas.write(buf,0,len); &#125; String data = bas.toString(); return data; activity_mail.xml的编写 12345678910111213141516171819202122232425262728&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;EditText android:id="@+id/ed_path" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="http://www.itceo.net"/&gt; &lt;Button android:layout_width="fill_parent" android:layout_height="wrap_content" android:onClick="viewPageSource" android:text="显示"/&gt; &lt;ScrollView android:layout_width="fill_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/tv" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 4.3 解析json格式的数据 需要在AndroidManifest.xml开启权限 1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 在主线程中重写hander的handleMessage()方法,让工作线程发送信息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class MainActivity extends AppCompatActivity &#123; private EditText ed_city; private TextView city_result1; private TextView city_result2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ed_city = (EditText) findViewById(R.id.ed_city); city_result1 = (TextView) findViewById(R.id.city_result1); city_result2 = (TextView) findViewById(R.id.city_result2); &#125; private final static String PATH = "http://wthrcdn.etouch.cn/weather_mini?city="; protected static final int SUCCESS = 0; protected static final int INVALID_CITY = 1; protected static final int ERROR = 2; private String city; String ul; private Handler mHandler = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case SUCCESS: try &#123; JSONArray data = (JSONArray) msg.obj; String day01 = data.getString(0); city_result1.setText(day01); String day02 = data.getString(1); city_result2.setText(day02); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; break; case INVALID_CITY: Toast.makeText(MainActivity.this, "城市无效", 0).show(); break; case ERROR: Toast.makeText(MainActivity.this, "网络问题", 0).show(); break; default: break; &#125; &#125;; &#125;; public void searchCityWeather(View v)&#123; city = ed_city.getText().toString().trim(); if(TextUtils.isEmpty(city))&#123; Toast.makeText(this, "路径错误...", 0).show(); return; &#125; //http://wthrcdn.etouch.cn/weather_mini?city=%E6%B7%B1%E5%9C%B3 new Thread()&#123; public void run() &#123; try &#123; ul = PATH + URLEncoder.encode(city, "UTF-8"); URL url = new URL(ul); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); // 设置必要的参数信息 conn.setConnectTimeout(5000); conn.setRequestMethod("GET"); //判断响应码 int code = conn.getResponseCode(); if(code==200)&#123; InputStream in = conn.getInputStream(); String data = StreamTool.decodeStream(in); System.out.println(data); //解析json格式的数据 JSONObject jsonObj = new JSONObject(data); // 获得desc的值 String result = jsonObj.getString("desc"); if("OK".equals(result))&#123; //城市有效,返回了需要的数据 JSONObject dataObj = jsonObj.getJSONObject("data"); JSONArray jsonArray = dataObj.getJSONArray("forecast"); //通知更新ui Message msg = Message.obtain(); msg.obj = jsonArray; msg.what=SUCCESS; mHandler.sendMessage(msg); &#125;else&#123; //城市无效 Message msg = Message.obtain(); msg.what=INVALID_CITY; mHandler.sendMessage(msg); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Message msg = Message.obtain(); msg.what=ERROR; mHandler.sendMessage(msg); &#125; &#125;; &#125;.start(); &#125;&#125; 定义一个底层流实现代码 12345678910public static String decodeStream(InputStream in) throws IOException&#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); int len = 0; byte[] buf = new byte[1024]; while ((len=in.read(buf))&gt;0)&#123; baos.write(buf,0,len); &#125; String data = buf.toString(); return data;&#125; activity_mail.xml的编写 12345678910111213141516171819202122232425262728293031&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="请输入要查询的城市"/&gt; &lt;EditText android:id="@+id/ed_city" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:onClick="searchCityWeather" android:text="查询" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/city_result1" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/city_result2" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 4.4 联网解析xml格式的数据 需要在AndroidManifest.xml开启权限 1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 在主线程重写handler的handleMessage( )方法,在工作线程发送消息. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public class MainActivity extends AppCompatActivity &#123; protected static final int SUCCESS = 0; protected static final int ERROR = 1; private EditText ed_phone; private TextView tv_phonenumber; private TextView tv_phonelocation; private TextView tv_phonejx; private Handler mHandler = new Handler()&#123; public void handleMessage(Message msg) &#123; dialog.dismiss(); switch (msg.what) &#123; case SUCCESS: p = (Product) msg.obj; if(p!=null)&#123; tv_phonenumber.setText(p.getPhonenum()); tv_phonelocation.setText(p.getLocation()); tv_phonejx.setText(p.getPhoneJx()); &#125; break; case ERROR: Toast.makeText(MainActivity.this, "对不起, 俺比较忙, 稍后再来 ", 0).show(); break; default: break; &#125; &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ed_phone = (EditText) findViewById(R.id.ed_phone); tv_phonenumber = (TextView) findViewById(R.id.tv_phonenumber); tv_phonelocation = (TextView) findViewById(R.id.tv_phonelocation); tv_phonejx = (TextView) findViewById(R.id.tv_phonejx); &#125; String number; Product p = null; ProgressDialog dialog = null; public void getPhoneJX(View v)&#123; number = ed_phone.getText().toString().trim(); if(TextUtils.isEmpty(number))&#123; Toast.makeText(this, "手机号码 错误 ", 0).show(); return; &#125; // http://www.096.me/api.php?phone=13691689110&amp;mode=xml final String path ="http://www.096.me/api.php?phone="+number+"&amp;mode=xml"; dialog = new ProgressDialog(this); dialog.setMessage("正在玩命加载中..."); dialog.show(); new Thread()&#123; public void run() &#123; try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setConnectTimeout(5000); conn.setRequestMethod("GET"); int code = conn.getResponseCode(); if(code==200)&#123; InputStream in = conn.getInputStream(); String data = StreamTool.decodeStream(in); XmlPullParser parser = Xml.newPullParser(); if(data.contains("gbk"))&#123; parser.setInput(in, "gbk"); &#125;else if(data.contains("UTF-8"))&#123; parser.setInput(in, "UTF-8"); &#125; //以后注意, 只要出现乱码, 确保 解析的 编码和 发过来的编码一致 , 就不会有什么问题了. //获得事件的类型 int eventType = parser.getEventType(); // while(eventType!=XmlPullParser.END_DOCUMENT)&#123;// .. //准备 一个javabean ,封装数据到 bean 中 -- Product/*&lt;smartresult&gt; &lt;product type="mobile"&gt; &lt;phonenum&gt;13691689110&lt;/phonenum&gt; &lt;location&gt;广东深圳移动神州行卡&lt;/location&gt; &lt;phoneJx&gt;惨淡经营，难免贫困，此数不吉，最好改名 凶&lt;/phoneJx&gt; &lt;/product&gt;&lt;/smartresult&gt; */ if(eventType==XmlPullParser.START_TAG)&#123; if("product".equals(parser.getName()))&#123; // new 一个product ,准备封装数据 String type = parser.getAttributeValue(0); p = new Product(); p.setType(type); &#125;else if("phonenum".equals(parser.getName()))&#123; p.setPhonenum(parser.nextText()); &#125;else if("location".equals(parser.getName()))&#123; p.setLocation(parser.nextText()); &#125;else if("phoneJx".equals(parser.getName()))&#123; p.setPhoneJx(parser.nextText()); &#125; &#125; eventType =parser.next(); &#125; //发消息 , 通知秘书去更新UI Message msg = Message.obtain(); msg.what=SUCCESS; msg.obj = p; mHandler.sendMessage(msg); in.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Message msg = Message.obtain(); msg.what=ERROR; mHandler.sendMessage(msg); &#125; &#125;; &#125;.start(); &#125;&#125; 定义一个底层流实现代码 1234567891011121314151617181920212223242526272829package com.javami.unitls;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;/** * Created by 诸葛亮 on 2016/10/30. */public class StreamTool &#123; public static String decodeStream(InputStream in) throws IOException&#123; //底层流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); int len = 0; byte[] buf = new byte[1024]; while((len=in.read(buf))&gt;0)&#123; baos.write(buf,0,len); &#125; String data = baos.toString(); if (data.contains("gbk"))&#123; return baos.toString("gbk"); &#125;else if(data.contains("utf-8"))&#123; return baos.toString("utf-8"); &#125;else&#123; return data; &#125; &#125;&#125; 定义Product封装数据 1234567891011121314151617181920212223242526272829package com.javami.unitls;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;/** * Created by 诸葛亮 on 2016/10/30. */public class StreamTool &#123; public static String decodeStream(InputStream in) throws IOException&#123; //底层流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); int len = 0; byte[] buf = new byte[1024]; while((len=in.read(buf))&gt;0)&#123; baos.write(buf,0,len); &#125; String data = baos.toString(); if (data.contains("gbk"))&#123; return baos.toString("gbk"); &#125;else if(data.contains("utf-8"))&#123; return baos.toString("utf-8"); &#125;else&#123; return data; &#125; &#125;&#125; activity_mail.xml的编写 1234567891011121314151617181920212223242526272829303132333435363738&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="请输入手机号码" /&gt; &lt;EditText android:inputType="phone" android:id="@+id/ed_phone" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:onClick="getPhoneJX" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/tv_phonenumber" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/tv_phonelocation" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/tv_phonejx" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3.安卓基础之数据库&listview&对话框]]></title>
      <url>%2F2017%2F03%2F28%2F3-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93-listview-%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
      <content type="text"><![CDATA[1. Android的xml的解析器1.1 XML解析案例 解析手机号码吉凶案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //使用xml pull 解析器去解析xml文件的内容 XmlPullParser parser = Xml.newPullParser(); try &#123; InputStream in = getAssets().open("result.xml"); parser.setInput(in, "gbk"); //获取事件的类型 int eventType = parser.getEventType(); /* &lt;?xml version="1.0" encoding="gbk"?&gt; &lt;smartresult&gt; &lt;product type="mobile"&gt; &lt;phonenum&gt;13512345678&lt;/phonenum&gt; &lt;location&gt;重庆移动神州行卡&lt;/location&gt; &lt;phoneJx&gt;有得有失，华而不实，须防劫财，始保平安 吉带凶&lt;/phoneJx&gt; &lt;/product&gt; &lt;/smartresult&gt; * */ Product p = null; while(eventType!=XmlPullParser.END_DOCUMENT)&#123; //判断是否是元素的开始,只要是某个元素的开始位置,那么就会进入 //获得当前元素解析的元素的名称 if("product".equals(parser.getName()))&#123; p = new Product(); String type = parser.getAttributeValue(0);//product p.setType(type); &#125;else if("phonenum".equals(parser.getName()))&#123; String phonenum = parser.nextText(); p.setPhonenum(phonenum); &#125;else if("location".equals(parser.getName()))&#123; String location = parser.nextText(); p.setLocation(location); &#125;else if("phoneJx".equals(parser.getName()))&#123; String phoneJx = parser.nextText(); p.setPhoneJx(phoneJx); &#125; //手动挪动指针 eventType = parser.next(); &#125; if(p!=null)&#123; Log.d("ProductMessange",p.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 1234567891011result.xml&lt;?xml version="1.0" encoding="gbk"?&gt;&lt;smartresult&gt; &lt;product type="mobile"&gt; &lt;phonenum&gt;13512345678&lt;/phonenum&gt; &lt;location&gt;重庆移动神州行卡&lt;/location&gt; &lt;phoneJx&gt;有得有失，华而不实，须防劫财，始保平安 吉带凶 &lt;/phoneJx&gt; &lt;/product&gt;&lt;/smartresult&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Product.javapackage com.example.xmlpullparsertest;/* * * 封装数据的 标 准的 javabean *&lt;product type="mobile"&gt; &lt;phonenum&gt;13512345678&lt;/phonenum&gt; &lt;location&gt;重庆移动神州行卡&lt;/location&gt; &lt;phoneJx&gt;有得有失，华而不实，须防劫财，始保平安 吉带凶&lt;/phoneJx&gt; &lt;/product&gt; * */public class Product &#123; private String type; private String phonenum; private String phoneJx; private String location; public String getLocation() &#123; return location; &#125; public void setLocation(String location) &#123; this.location = location; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getPhonenum() &#123; return phonenum; &#125; public void setPhonenum(String phonenum) &#123; this.phonenum = phonenum; &#125; public String getPhoneJx() &#123; return phoneJx; &#125; public void setPhoneJx(String phoneJx) &#123; this.phoneJx = phoneJx; &#125; @Override public String toString() &#123; return "Product [type=" + type + ", phonenum=" + phonenum + ", phoneJx=" + phoneJx + "]"; &#125;&#125; 2. 保存数据到数据库中的作用如果保存的数据是有规律的,格式是同样的.那么可以去选择使用数据库保存数据.Android提供的数据库(sqlite)数据库. android提供的数据库小应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MySqliteHelper helper = new MySqliteHelper(MainActivity.this); helper.getReadableDatabase(); &#125;MySqliteHelper.javapackage com.example.sqlitedemo;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class MySqliteHelper extends SQLiteOpenHelper &#123; public MySqliteHelper(Context context)&#123; //context:应用上下文 //name:数据库的名词 //factory:创建游标的工厂 //version:数据库的版本 super(context, "mydb1", null, 4); /* mysql create table users( id int primary key auto_increment, name varchar(30) ); android 中 : create table students( id integer primary key autoincrement, name varchar(30) ); */ &#125; //在数据库首次被创建时调用 @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL("create table students ( _id integer primary key autoincrement,name varchar(30), sex varchar(10))"); &#125; //在数据库升级时调用,当版本比之前的版本高时会执行该方法! @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("alter table students add number varchar(10)"); &#125;&#125; StudentSystem在SQLiteOpenHelper的应用详细版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143Student.javapackage domain;public class Student &#123; private String id; private String name; private String sex; public Student()&#123; &#125; public Student(String id,String name,String sex)&#123; this.name = name; this.id = id; this.sex = sex; &#125; public String getId() &#123; return id; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", sex=" + sex + "]"; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125;StudentDao.javapackage com.example.studentsystemdemo1;import java.util.ArrayList;import java.util.List;import domain.Student;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;public class StudentDao &#123; StudentDbOpenHelper helper; public StudentDao(Context context)&#123; helper = new StudentDbOpenHelper(context); &#125; public void add(Student st)&#123; //拿到工具类的实例,然后去操作数据库 SQLiteDatabase db = helper.getReadableDatabase(); //执行sql语句 db.execSQL("insert into students values(null,?,?)",new Object[]&#123;st.getName(),st.getSex()&#125;); &#125; public void delete(String id)&#123; SQLiteDatabase db = helper.getReadableDatabase(); db.execSQL("delete from students where _id=?",new Object[]&#123;id&#125;); &#125; public void update(Student st)&#123; SQLiteDatabase db = helper.getReadableDatabase(); db.execSQL("update students set name=?,sex=? where _id=?", new Object[]&#123;st.getName(),st.getSex(),st.getId()&#125;); &#125; public Student find(String id)&#123; SQLiteDatabase db = helper.getReadableDatabase(); Cursor cursor = db.rawQuery("select * from students where _id=?", new String[]&#123;id&#125;); boolean result = cursor.moveToNext(); Student st = null; if(result)&#123; int _id = cursor.getInt(cursor.getColumnIndex("_id")); String name = cursor.getString(cursor.getColumnIndex("name")); String sex = cursor.getString(cursor.getColumnIndex("sex")); st = new Student(String.valueOf(id),name,sex); &#125; cursor.close(); return st; &#125; //查询返回所有学生的信息 public List&lt;Student&gt; getAll()&#123; List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); SQLiteDatabase db = helper.getReadableDatabase(); Cursor cursor = db.rawQuery("select * from students", null); while(cursor.moveToNext())&#123; int id = cursor.getInt(cursor.getColumnIndex("_id")); String name = cursor.getString(cursor.getColumnIndex("name")); String sex = cursor.getString(cursor.getColumnIndex("sex")); Student st = new Student(String.valueOf(id),name,sex); list.add(st); &#125; list = null; return list; &#125;&#125;StudentDbOpenHelper.javapackage com.example.studentsystemdemo1;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class StudentDbOpenHelper extends SQLiteOpenHelper &#123; public StudentDbOpenHelper(Context context)&#123; super(context, "student.db", null, 1); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; //创建数据库 db.execSQL("create table students (_id integer primary key autoincrement, name varchar(30),sex varchar(10))"); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 学生查询系统带item的应用: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Activity_main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;EditText android:id="@+id/ed_name" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="请输入学生的姓名" /&gt; &lt;RadioGroup android:id="@+id/rgb" android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;RadioButton android:id="@+id/male" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:checked="true" android:text="男" /&gt; &lt;RadioButton android:id="@+id/female" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:text="女" /&gt; &lt;/RadioGroup&gt; &lt;Button android:layout_width="fill_parent" android:layout_height="wrap_content" android:onClick="save" android:text="保存" /&gt; &lt;ScrollView android:layout_width="fill_parent" android:layout_height="wrap_content" &gt; &lt;LinearLayout android:id="@+id/ll" android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="vertical" &gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 ed_name = (EditText) findViewById(R.id.ed_name); rgb= (RadioGroup) findViewById(R.id.rgb); lv = (ListView) findViewById(R.id.lv); sdao = new StudentDao(this); refreshView(); &#125; public void save(View v)&#123; String name = ed_name.getText().toString().trim(); if(TextUtils.isEmpty(name))&#123; Toast.makeText(this, "学生信息不能为空", 0).show(); return; &#125; String sex ="male"; int id = rgb.getCheckedRadioButtonId(); if(id==R.id.male)&#123; sex ="male"; &#125;else&#123; sex ="female"; &#125; //将数据 保存到数据库 中去 // 拿到 dao Student st = new Student("xjlkj",name,sex); sdao.add(st); Toast.makeText(this, "保存 "+ name+"成功", 0).show(); //将所有的数据同步的显示 到 屏幕上去 //查询现有的数据 refreshView(); &#125; List&lt;Student&gt; students; private MyAdapter myAdapter; private void refreshView() &#123; // 将现有的全部给清空一下 students = sdao.getAll(); if(myAdapter ==null)&#123; myAdapter = new MyAdapter(); //为 lv 设置数据适配器 --- 设置控制器controller lv.setAdapter(myAdapter); &#125;else&#123; //则说明myAdapter已经存在了,需要做的是,通知控制器 adapter去更新一下数据. myAdapter.notifyDataSetChanged(); &#125; &#125; private class MyAdapter extends BaseAdapter&#123; //最开始被调用的 , 用于告诉控制器 adapter到底要显示 多少个item @Override public int getCount() &#123; //告诉控制器 adapter显示多少个item return students.size(); &#125; //每个item要显示在屏幕上时,又会调用到这个方法 //convertView:就是用来进行优化的 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; //获得当前的学生 final Student st = students.get(position); //现在 item 已经定义好了,需要将硬盘上item.xml布局文件 转化为一个布局的对象返回去. View v; if (convertView == null) &#123; v = View.inflate(MainActivity.this, R.layout.item, null); &#125; else &#123; v = convertView; &#125; //打气筒的对象 ,去填充xml,使得xml布局文件变为一个view对象. //拿到iv和tv ImageView iv = (ImageView) v.findViewById(R.id.item_iv); String sex = st.getSex(); if("male".equals(sex))&#123; iv.setImageResource(R.drawable.nan); &#125;else&#123; iv.setImageResource(R.drawable.nv); &#125; TextView tv = (TextView) v.findViewById(R.id.item_tv); tv.setText(st.getName()); v.findViewById(R.id.item_delete).setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; /*System.out.println("======= onClick 点击了 "); //需要拿到当前的点击的item ,将 学生的信息给删掉. //获得点击点击的item String id = st.getId(); sdao.delete(id); Toast.makeText(MainActivity.this, "删除成功 : " + st.getName(), 0).show(); //重新加载下数据 refreshView();*/ AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle("删除..."); builder.setMessage("亲,你确定要删除吗? 不能反悔 的哦..."); //设置点击确定的按钮 builder.setPositiveButton("删除",new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; String id = st.getId(); sdao.delete(id); Toast.makeText(MainActivity.this, "删除 成功 : " + st.getName(), 0).show(); // 重新 加载 下 数据 refreshView(); &#125; &#125;); //设置点击取消的的按钮 builder.setNegativeButton("取消", null); //你需要 调用 相应的方法 才能够显示出来 /* AlertDialog dialog = builder.create(); dialog.show();*/ builder.show(); &#125; &#125;); return v; &#125; @Override public Object getItem(int position) &#123; // TODO Auto-generated method stub return null; &#125; @Override public long getItemId(int position) &#123; // TODO Auto-generated method stub return 0; &#125; &#125;&#125;StudentDao.javapackage com.example.studentsystemdemo2;import java.util.ArrayList;import java.util.List;import domain.Student;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;public class StudentDao &#123; StudentDbOpenHelper helper; public StudentDao(Context context)&#123; helper = new StudentDbOpenHelper(context); &#125;// "create table students (_id integer primary key autoincrement, name varchar(30),sex varchar(10))" public void add(Student st)&#123; //拿到工具类的实例, 然后去操作 数据库 SQLiteDatabase db = helper.getWritableDatabase(); //执行sql语句 db.execSQL("insert into students values(null,?,?)",new Object[]&#123;st.getName(),st.getSex()&#125;); &#125; public void delete(String id)&#123; SQLiteDatabase db = helper.getWritableDatabase(); db.execSQL("delete from students where _id=?",new Object[]&#123;id&#125;); &#125; public void update(Student st)&#123; SQLiteDatabase db = helper.getWritableDatabase(); db.execSQL("update students set name=?,sex=? where _id=?", new Object[]&#123;st.getName(),st.getSex(),st.getId()&#125;); &#125; public Student find(String id)&#123; SQLiteDatabase db = helper.getReadableDatabase(); //select * from users where id=? //叫做游标,与 javaweb中所学的resultSet结构是一样的 Cursor cursor = db.rawQuery("select * from students where _id=?", new String[]&#123;id&#125;); boolean result = cursor.moveToNext(); Student st = null; if(result)&#123;// st = new Student(); /*int _id = cursor.getInt(0); String name = cursor.getString(1); String sex = cursor.getString(2); st.setId(id); st.setName(name); st.setSex(sex);*/ int _id = cursor.getInt(cursor.getColumnIndex("_id")); String name = cursor.getString(cursor.getColumnIndex("name")); String sex = cursor.getString(cursor.getColumnIndex("sex")); st = new Student(String.valueOf(_id),name,sex); &#125; // 最后会释放 资源 cursor.close(); return st; &#125; //查询返回所有的学生的信息 public List&lt;Student&gt; getAll() &#123; List&lt;Student&gt; list =new ArrayList&lt;Student&gt;(); SQLiteDatabase db = helper.getReadableDatabase(); Cursor cursor = db.rawQuery("select * from students", null); while(cursor.moveToNext())&#123; int id = cursor.getInt(cursor.getColumnIndex("_id")); String name = cursor.getString(cursor.getColumnIndex("name")); String sex = cursor.getString(cursor.getColumnIndex("sex")); Student st = new Student(String.valueOf(id), name, sex); list.add(st); &#125; return list; &#125;&#125;StudentDbOpenHelper.javapackage com.example.studentsystemdemo2;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class StudentDbOpenHelper extends SQLiteOpenHelper &#123; public StudentDbOpenHelper(Context context) &#123; super(context, "student.db", null, 1); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; //创建数据库 db.execSQL("create table students (_id integer primary key autoincrement, name varchar(30),sex varchar(10))"); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125;Student.javapackage domain;public class Student &#123; private String id; private String name; private String sex; public Student() &#123; super(); &#125; public Student(String id, String name, String sex) &#123; super(); this.id = id; this.name = name; this.sex = sex; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", sex=" + sex + "]"; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293activity_main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/hello_world" /&gt; &lt;EditText android:id="@+id/ed_name" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="请输入学生的姓名" /&gt; &lt;RadioGroup android:id="@+id/rgb" android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;RadioButton android:id="@+id/male" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:checked="true" android:text="男" /&gt; &lt;RadioButton android:id="@+id/female" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:text="女" /&gt; &lt;/RadioGroup&gt; &lt;Button android:layout_width="fill_parent" android:layout_height="wrap_content" android:onClick="save" android:text="保存" /&gt; &lt;ListView android:id="@+id/lv" android:layout_width="fill_parent" android:layout_height="fill_parent" &gt; &lt;/ListView&gt;&lt;/LinearLayout&gt;item.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal" &gt; &lt;RelativeLayout android:layout_width="fill_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:layout_marginLeft="15dip" android:layout_alignParentLeft="true" android:id="@+id/item_iv" android:layout_width="20dip" android:layout_height="30dip" android:layout_centerVertical="true" /&gt; &lt;TextView android:layout_toRightOf="@id/item_iv" android:id="@+id/item_tv" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" /&gt; &lt;ImageView android:layout_marginRight="8dip" android:id="@+id/item_delete" android:layout_centerVertical="true" android:layout_alignParentRight="true" android:src="@drawable/delete" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 常见的对话框 1234567891011121314151617181920activity_main.xml &lt;Button android:onClick="dialog01" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="创建确认取消对话框"/&gt; &lt;Button android:onClick="dialog02" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="创建单选对话框"/&gt; &lt;Button android:onClick="dialog03" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="创建多选对话框"/&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556MainActivity.java //创建确认取消对话框 public void dialog01(View v)&#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle("约会吗?"); builder.setMessage("告别单身,你愿意吗?"); //愿意情况下开启监听器 builder.setPositiveButton("愿意", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, "我也单身,说不定可以来找我", 0).show(); &#125; &#125;); builder.setNegativeButton("不愿意", null); builder.show(); &#125; //创建单选进度条 public void dialog02(View v)&#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle("单选对话框"); final String[] items = &#123;"小樱","小明","诸葛亮"&#125;; builder.setSingleChoiceItems(items, -1, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, "被点击了:"+items[which]+",位置:"+which, 0).show(); &#125; &#125;); builder.show(); &#125; //创建多选对话框 public void dialog03(View v)&#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle("多选框"); final String[] items =&#123;"android","python","go","c/c++"&#125;; boolean[] checkItems = &#123;true,false,false,true&#125;; builder.setMultiChoiceItems(items, checkItems, new DialogInterface.OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which, boolean isChecked) &#123; Toast.makeText(MainActivity.this, " 被点击了 : " + items[which] +",位置: " +which+", 值是: "+ isChecked, 0 ).show(); &#125; &#125;); builder.show(); &#125; 用ContentValues来实现增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188Student.javapackage domain;public class Student &#123; private String id; private String name; private String sex; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(String id, String name, String sex) &#123; super(); this.id = id; this.name = name; this.sex = sex; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", sex=" + sex + "]"; &#125;&#125;StudentDao.javapackage com.example.studentsystemdemo3;import domain.Student;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;/* * * 增删改查有两套api了 * * 第一套(你经常使用的): * 增删改:db.execSQL(); * 查询:db.rawQuery(); * * 第二套(推荐使用): * * 增:db.insert(); * 删:db.delete(); * 改:db.update(); * 查询:db.query(); * * 实际开发过程中:数据库到底用的多不多?不多 ... * * 提供的保存数据的方式很多 : * * 保存数据的方式 : * 1. 应用内部的私有的文件夹下 : /data/data/net.itceo.hello/files/cache * 2. sharedPreference : /data/data/net.itceo.hello/shar_prefs * 3. 在 sd 卡公共的部分 : /mnt/sdcard * 4. 存到数据库 中 : sqlite 数据库 * * * * */public class StudentDao &#123;StudentDbOpenHelper helper; public StudentDao(Context context)&#123; helper = new StudentDbOpenHelper(context); &#125; public void add(Student st)&#123; //拿到 工具类的实例 , 然后去操作 数据库 SQLiteDatabase db = helper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put("name", st.getName()); values.put("sex", st.getSex()); db.insert("students", null, values); &#125; public void delete(String id)&#123; SQLiteDatabase db = helper.getWritableDatabase(); db.delete("students", "_id=?", new String[]&#123;id&#125;); &#125; public void update(Student st)&#123; SQLiteDatabase db = helper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put("name", st.getName()); values.put("sex", st.getSex()); db.update("students", values, "_id=?", new String[]&#123;st.getId()&#125;); &#125; public Student find(String id)&#123; SQLiteDatabase db = helper.getReadableDatabase();db.query("students", new String[]&#123;"_id","name","sex"&#125;, "_id=?", new String[]&#123;id&#125;, null, null, null); Cursor cursor = db.rawQuery("select * from students where _id=?", new String[]&#123;id&#125;); boolean result = cursor.moveToNext(); Student st = null; if(result)&#123; int _id = cursor.getInt(cursor.getColumnIndex("_id")); String name = cursor.getString(cursor.getColumnIndex("name")); String sex = cursor.getString(cursor.getColumnIndex("sex")); st = new Student(String.valueOf(_id),name,sex); &#125; // 最后会释放 资源 cursor.close(); return st; &#125;&#125;StudentDbOpenHelper.javapackage com.example.studentsystemdemo3;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class StudentDbOpenHelper extends SQLiteOpenHelper &#123; public StudentDbOpenHelper(Context context)&#123; super(context, "student.db", null, 1); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; //创建数据库 db.execSQL("create table students (_id integer primary key autoincrement, name varchar(30),sex varchar(10))"); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125;TestStudentDao.javapackage com.example.studentsystemdemo3;import domain.Student;import android.test.AndroidTestCase;public class TestStudentDao extends AndroidTestCase &#123; public void testAdd()&#123; Student st = new Student("8798", "二球", "女"); StudentDao sdao = new StudentDao(getContext()); sdao.add(st); &#125;&#125;//注意:写测试类需要在AndroidMainfest.xml 下声明instrumentation和uses-libray]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2.安卓基础之Android文件存储]]></title>
      <url>%2F2017%2F03%2F28%2F2-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8BAndroid%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[1. Android中的测试1.1 应用层的测试测试常规的功能是否完善,不会出现致命的BUG. 1.2 Google 的CTS的测试谷歌CTS,英文为 Compatibility Test Suite ,中文意思是兼容性测试,手机设备需要通过Android的兼容性测试(CTS),以确保在android上开发的程序在手机设备上都能运行.Google并没有在源代码中提供Android Market应用,因为他们希望所有设备生产商能够通过CTS测试.如果他们通过了CTS测试,那么就可以向Google申请使用Android market,Google才会给Market应用. 1.3 Framework的测试在android 中谷歌程序员也将 junit 测试框架引入进来了. 1.4. android中测试程序的编写步骤 编写一个类去继承 AndroidTestCase 编写一个测试的运行的方法 在manifest文件中添加如下内容 在 application 元素下添加如下内容 2. Log级别的分类12345Log.v(TAG, "俺是 一个 详细 的日志 信息");Log.i(TAG, "俺是 一个 一般的 的日志 信息");Log.w(TAG, "俺是 一个 警告 的日志 信息"); Log.e(TAG, "俺是 一个 错误 的日志 信息");Log.wtf(TAG, "俺是 一个xxxxx 的日志 信息"); 3. android下保存数据3.1 将数据保存到应用程序中(私有的) 是因为 , 这里的路径以及保存的方式都有问题 , 目前是运行在androd中, android底层是linux内核, linux 文件系统的根目录是 一个 / . 写 File file = new File(“info.txt”); 将数据保存到 linux 根目录 / 下, 而这时当前的应用程序不可能取得这样的权限的. 每个应用程序可以将数据保存到自己独有的一个文件夹下 : 3.2 android中图片的缓存策略:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768**MainActivity.java:** @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 ed_qqnumber = (EditText) findViewById(R.id.qqnumber); ed_qqpassword = (EditText) findViewById(R.id.qqpassword); cbx = (CheckBox) findViewById(R.id.remember); File file = new File(this.getFilesDir(), "info.txt"); //如果文件里面存在内容,显示数据 if(file.exists()&amp;&amp;file.length()&gt;0)&#123; //读取file中的数据,然后显示 try &#123; //111#itceo#111 BufferedReader bufferedReader = new BufferedReader(new FileReader(file)); String line = bufferedReader.readLine(); String num =line.split("#itceo#")[0]; String pwd = line.split("#itceo#")[1]; ed_qqnumber.setText(num); ed_qqpassword.setText(pwd); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; //点击登陆后执行 login 的方法 public void login(View view)&#123; //获得输入框中写入的数据,trim()去掉字符串的首尾空格 String number = ed_qqnumber.getText().toString().trim(); String password = ed_qqpassword.getText().toString().trim(); if(TextUtils.isEmpty(number)||TextUtils.isEmpty(password))&#123; Toast.makeText(this, "请输入您的账号或密码!", 0).show(); return; &#125; //判断是否勾选了checkbox,如果勾选了checkbox,那么就将QQ号和密码保存起来 boolean isChecked = cbx.isChecked(); if(isChecked)&#123; try &#123; //如果勾选了,将数据保存起来. File file = new File(this.getFilesDir(),"info.txt"); OutputStream outputStream = new FileOutputStream(file); String value = number+"#itceo#"+password; outputStream.write(value.getBytes()); outputStream.close(); Toast.makeText(this, "勾选,保存成功!", 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(this, "勾选,但不保存成功!", 0).show(); &#125; &#125;else &#123; Toast.makeText(this, "没勾选成功!", 0).show(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041activity_main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="net.itceo.qqlogin.MainActivity" &gt; &lt;ImageView android:layout_gravity="center" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/qq" /&gt; &lt;EditText android:id="@+id/qqnumber" android:hint="请输入账号:" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;EditText android:id="@+id/qqpassword" android:hint="请输入密码:" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;CheckBox android:id="@+id/remember" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="请记住你的密码"/&gt; &lt;Button android:onClick="login" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="登陆"/&gt;&lt;/LinearLayout&gt; 3.3 android中sdcard的细节问题:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 ed_qqnumber = (EditText) findViewById(R.id.qqnumber); ed_qqpassword = (EditText) findViewById(R.id.qqpassword); cbx = (CheckBox) findViewById(R.id.remember); File file = new File(Environment.getExternalStorageDirectory(), "info.txt"); //如果文件里面包含数据 if (file.exists()&amp;&amp;file.length()&gt;0) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new FileReader(file)); String line = bufferedReader.readLine(); String num = line.split("#itceo#")[0]; String pwd = line.split("#itceo#")[1]; ed_qqnumber.setText(num); ed_qqpassword.setText(pwd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void login(View v)&#123; //获得输入框的值 String number = ed_qqnumber.toString().trim(); String password = ed_qqpassword.toString().trim(); //判断是否填入了number和password的值 if (TextUtils.isEmpty(number)||TextUtils.isEmpty(password)) &#123; Toast.makeText(this, "请输入账号或密码", 0).show(); return; &#125; //判断是否勾选了checkbox,如果勾选了checkbox,那么就将QQ和密码保存起来; boolean isChecked = cbx.isChecked(); if (isChecked) &#123; try &#123; //说明勾选了,给提示! // sdcard 做为 一个外部的 存储 设备, 有时候 sdcard 是处于 弹出状态, 未插入状态, 强制拔出 状态. // 那么在这些 情况下,如果 要向 sdcard 中写数据, 为了 保证 数据 确切的存储, 提高用户的感受, 所以 , 在存储到 // sd 卡中之前, 会去动态 判断 sdcard 的状态,只有 在sdcard 是处于 挂载 的状态下 , 再去 写 sd 卡数据 String status = Environment.getExternalStorageState();//返回的状态 if (!Environment.MEDIA_MOUNTED.equals(status)) &#123;//如果返回的状态非挂载 Toast.makeText(this, "请检查你的内存卡状态", 0).show(); return; &#125; //返回内存卡可用的空闲空间 long freeSpace = Environment.getExternalStorageDirectory() .getFreeSpace(); //拿到SD卡的总大小 Environment.getExternalStorageDirectory().getTotalSpace(); //拿到已经使用的大小 Environment.getExternalStorageDirectory().getUsableSpace(); //将返回的字节转换为单位 String avalabSize = Formatter.formatFileSize(this, freeSpace); Toast.makeText(this, "你的可用大小为:" + avalabSize, 0).show(); File file = new File(Environment.getExternalStorageDirectory(), "info.txt"); //取出数据 OutputStream outputStream = new FileOutputStream(file); //写入数据 String value = number+"#itceo#"+password; outputStream.write(value.getBytes()); outputStream.close(); Toast.makeText(this, "勾选成功", 0).show(); &#125; catch (Exception e) &#123; Toast.makeText(this, "没勾选成功", 0).show(); &#125; &#125;else&#123; Toast.makeText(this, "不勾选,是无法保存数据的", 0).show(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142activity_main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;ImageView android:layout_gravity="center" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/qq" /&gt; &lt;EditText android:id="@+id/qqnumber" android:hint="请输入qq号码" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;EditText android:id="@+id/qqpassword" android:hint="请输入qq密码" android:inputType="textPassword" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;CheckBox android:id="@+id/remember" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="记住用户名和密码" /&gt; &lt;Button android:onClick="login" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="登录" /&gt;&lt;/LinearLayout&gt; 3.4 android中文件权限问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 /* * 创建一个私有的文件 * * 每个应用程序 都一个私有的文件夹, /data/data/net.itceo.filemode * * * 私有的文件 ,只有当前的应用 自己可以去访问, 其他的应用没有办法 去访问，其他的应用既不可以读，也不可以写 */public void getPrivateFile(View v) &#123; try &#123; File file = new File(this.getFilesDir(), "private.txt"); OutputStream out = new FileOutputStream(file); out.write("private".getBytes()); out.close(); Toast.makeText(this, "写入私有文件成功", 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(this, "写入私有文件失败 ", 0).show(); &#125;&#125;// 谷歌不推荐咱们这样做 : 引入了新的组件 --- contentProvider// 创建一个只读的文件 :其他的应用可以去读但是不能去写 public void getReadOnlyFile(View v) &#123; try &#123; FileOutputStream out = openFileOutput("readonly.txt", Context.MODE_WORLD_READABLE); out.write("readonly".getBytes()); out.close(); Toast.makeText(this, "写入只读文件成功", 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(this, "写入只读文件失败 ", 0).show(); &#125;&#125;//写入只可写文件public void getWriteOnlyFile(View v) &#123; try &#123; FileOutputStream out = openFileOutput("writeonly.txt", Context.MODE_WORLD_WRITEABLE); out.write("writeonly".getBytes()); out.close(); Toast.makeText(this, "写入只可写文件成功", 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(this, "写入只可写文件失败 ", 0).show(); &#125;&#125;// 其他应用可以读也可以写的文件public void getPublicFile(View v) &#123; try &#123; FileOutputStream out = openFileOutput("public.txt", Context.MODE_WORLD_WRITEABLE+Context.MODE_WORLD_READABLE); out.write("public".getBytes()); out.close(); Toast.makeText(this, "写入可读可写成功", 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(this, "写入可读可写失败 ", 0).show(); &#125;&#125; 3.5 android中SharedPreferences的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 ed_qqnumber = (EditText) findViewById(R.id.qqnumber); ed_qqpaswword = (EditText) findViewById(R.id.qqpassword); cbx = (CheckBox) findViewById(R.id.remember); sp = getSharedPreferences("config", 0); //如果找到了number的值,那么就返回number的值,否则就返回这里的默认值 String num = sp.getString("number", ""); String pwd = sp.getString("password", ""); ed_qqnumber.setText(num); ed_qqpaswword.setText(pwd); &#125; //点击登录后会执行 login 方法 public void login(View v)&#123; //获得输入框中写入的值 String number = ed_qqnumber.getText().toString().trim(); String password= ed_qqpaswword.getText().toString().trim(); //判断是否输入了number以及password的值 if (TextUtils.isEmpty(number)||TextUtils.isEmpty(password)) &#123; Toast.makeText(this, "请输入QQ号或密码", 0).show(); return; &#125; //判断是否勾选了checkbox,如果勾选了即把数据保存起来 boolean isChecked = cbx.isChecked(); if(isChecked)&#123; try &#123; // 将数据 保存起来,使用 sharedPreference // config文件将会生成 在 应用的文件夹下 --- 一个 xml格式 的文件 // 一般情况下,应用自己的数据只有当前应用 自己可以去读, 所以通常会写 sp = getSharedPreferences("config", 0); Editor editor = sp.edit(); editor.putString("number", number); editor.putString("password", password); editor.commit(); Toast.makeText(this, "勾选了,保存成功", 0).show(); &#125; catch (Exception e) &#123; Toast.makeText(this, "勾选了,不保存成功", 0).show(); &#125; &#125;else&#123; Toast.makeText(this, "没勾选", 0).show(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142activity_main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;ImageView android:layout_gravity="center" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/qq" /&gt; &lt;EditText android:id="@+id/qqnumber" android:hint="请输入qq号码" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;EditText android:id="@+id/qqpassword" android:hint="请输入qq密码" android:inputType="textPassword" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;CheckBox android:id="@+id/remember" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="记住用户名和密码" /&gt; &lt;Button android:onClick="login" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="登录" /&gt;&lt;/LinearLayout&gt; 3.6 android中模拟setting设置使用sp保存数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354MainActivity.java @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); cbx = (CheckBox) findViewById(R.id.cbx); sb = (SeekBar) findViewById(R.id.seekBar); sp = this.getSharedPreferences("config", 0); boolean isCheckStatus = sp.getBoolean("isChecked", false); int pgs = sp.getInt("progress", 0); sb.setProgress(pgs); cbx.setChecked(isCheckStatus); cbx.setOnCheckedChangeListener(new OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton arg0, boolean arg1) &#123; Editor edit = sp.edit(); edit.putBoolean("isChecked", arg1); &#125; &#125;); sb.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; //停止 拖动 seek bar @Override public void onStopTrackingTouch(SeekBar arg0) &#123; //拿到 停止 拖动的时刻的进度 int progress = arg0.getProgress(); //将进度条保存到sharedPreference中 Editor editor = sp.edit(); editor.putInt("progress",progress); editor.commit(); &#125; //开始 拖动 seek bar @Override public void onStartTrackingTouch(SeekBar arg0) &#123; &#125; @Override public void onProgressChanged(SeekBar arg0, int arg1, boolean arg2) &#123; &#125; &#125;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334Activity_Main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#113965" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;RelativeLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:background="#000000"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:text="自动旋转屏幕" android:textColor="#ffffff"/&gt; &lt;CheckBox android:id="@+id/cbx" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true"/&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width="fill_parent" android:layout_height="1dip" android:background="#ff0000"/&gt; &lt;SeekBar android:id="@+id/seekBar" android:layout_width="match_parent" android:layout_height="wrap_content" android:max="100" android:visibility="visible"/&gt;&lt;/LinearLayout&gt; 3.7 android中XmlSerializer的应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495MainActivity.javapackage net.itceo.studentsystem;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.OutputStream;import org.xmlpull.v1.XmlSerializer;import android.app.Activity;import android.os.Bundle;import android.text.TextUtils;import android.util.Xml;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.EditText;import android.widget.RadioGroup;import android.widget.Toast;public class MainActivity extends Activity &#123; private EditText ed_ssname; private EditText ed_ssnumber; private RadioGroup rgb; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //控件的初始化 ed_ssname = (EditText) findViewById(R.id.studentname); ed_ssnumber = (EditText) findViewById(R.id.studentnumber); rgb = (RadioGroup) findViewById(R.id.radiogb); &#125; public void save(View v)&#123; String studentName = ed_ssname.getText().toString().trim(); String studentNumber = ed_ssnumber.getText().toString().trim(); if(TextUtils.isEmpty(studentName)||TextUtils.isEmpty(studentNumber))&#123; Toast.makeText(this, "学生姓名或密码不能为空", 0).show(); return; &#125; //获得性别 int id = rgb.getCheckedRadioButtonId(); String sex = "男"; if(id==R.id.male)&#123; sex = "男"; &#125;else if(id==R.id.female)&#123; sex = "女"; &#125; try &#123; File file = new File(getFilesDir(), studentName+".xml"); OutputStream outputStream = new FileOutputStream(file); // 专门生成xml 文件的 序列化器 XmlSerializer serializer = Xml.newSerializer(); serializer.setOutput(outputStream, "UTF-8"); // &lt;?xml version="1.0" encoding="utf-8" standalone?&gt; serializer.startDocument("UTF-8", true); serializer.startTag(null, "student"); //设置 文本信息 -- 学生的姓名 serializer.startTag(null, "name"); serializer.text(studentName); serializer.endTag(null, "name"); serializer.startTag(null, "number"); serializer.text(studentNumber); serializer.endTag(null, "number"); serializer.startTag(null, "sex"); serializer.text(sex); serializer.endTag(null, "sex"); serializer.endTag(null, "student"); serializer.endDocument(); outputStream.close(); Toast.makeText(this, "保存"+studentName+"信息 成功 ...", 0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText(this, "保存"+studentName+"信息 失败 .... ...", 0).show(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Activity_main.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;EditText android:id="@+id/studentname" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="请输入学生的姓名" /&gt; &lt;EditText android:id="@+id/studentnumber" android:layout_width="fill_parent" android:layout_height="wrap_content" android:hint="请输入学生的学号" /&gt; &lt;RadioGroup android:orientation="horizontal" android:id="@+id/radiogb" android:layout_width="fill_parent" android:layout_height="wrap_content"&gt; &lt;RadioButton android:id="@+id/male" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content" android:checked="true" android:text="男" /&gt; &lt;RadioButton android:id="@+id/female" android:layout_width="0dip" android:layout_height="wrap_content" android:layout_weight="1" android:text="女" /&gt; &lt;/RadioGroup&gt; &lt;Button android:text="保存" android:onClick="save" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:text="查询" android:onClick="save" android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/tv_display" android:layout_width="fill_parent" android:layout_height="fill_parent" /&gt;&lt;/LinearLayout&gt; 4 总结不够细心,当点击一次就保存一次.不用考虑循环问题.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[1.安卓基础之Android介绍与入门]]></title>
      <url>%2F2017%2F03%2F28%2F1-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E4%B9%8BAndroid%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[1. 通讯技术的介绍 1G通信标准: 模拟制式 2G通信标准: GSM/CDMA2.5G , 通信标准: GPRS 2.75G通信标准: EDGE 3G通信标准: WCDMA/CDMA2000/TD-SCDMA 3.5G/3.75G通信标准: HSDPA/HSDPA+/HSUDA 4G通信标准: TD-LTE 2. Android体系结构 3. 开发工具的疑问 启动Eclipse报错?因为Eclipse是由Java代码编写的,需要JVM的支持才能启动.如果启动失败,通常是没有搭配环境变量. ADB是用来干什么的呢?adb(Android Debug Bridge)是Android 提供的一个通用的调试工具.借助这个工具,可以管理设备模拟器的状态 ,还可以进行以下的操作: 快速更新设备或手机模拟器中的代码,如应用或Android系统升级; 在设备上运行shell命令; 管理设备或手机模拟器上的预定端口; 在设备或手机模拟器上上传下载文件; Intel x86模拟器?Google默认提供的模拟器是基于arm处理器的, 这种模拟器运行速度慢并非常卡顿, 影响开发和学习的效率, x86模拟器采用硬件加速功能来提升运行速度, 基本和真机无异. x86模拟器使用要求?CPU必须是Intel公司的, 并且需要是i3(包含)以上.成功安装硬件加速执行管理器: IntelHaxm.exe. 4. 常用到的命令 ?12345678910adb devices 列出所有的设置adb start-server 开启adb服务adb kill-server 关闭adb服务adb logcat 查看Logadb shell 挂载到Linux的空间adb install &lt;应用程序(加扩展名)&gt; 安装应用程序adb install &lt;应用程序(加扩展名)&gt; 安装应用到指定模拟器adb uninstall &lt;程序包名&gt;adb pull &lt;remote&gt; &lt;local&gt;adb push &lt;local&gt; &lt;remote&gt; 5. Android常见布局 LinearLayout 线性布局 orientation 属性是指定线性布局的排列方向: horizontal 水平 vertical 垂直 gravity属性是指定当前控件内容显示位置: left 左边 right 右边 top 上边 bottom 底边 layout_gravity属性是指定当前控件在父元素的位置: left 左边 right 右边 top 上边 bottom 底边layout_weightSum属性是把线性布局中剩余空间分成N份.layout_weight属性是指定当前控件在父元素(线性布局)中占N份. visibility属性是控制布局是否显示: visible 显示 invisible 不显示但占空间 gone 隐藏 RelativeLayout 相对布局android:layout_toRightOf 在指定控件的右边 android:layout_toLeftOf 在指定控件的左边 android:layout_above 在指定控件的上边 android:layout_below 在指定控件的下边 android:layout_alignBaseline 跟指定控件水平对齐 android:layout_alignLeft 跟指定控件左对齐 android:layout_alignRight 跟指定控件右对齐 android:layout_alignTop 跟指定控件顶部对齐 android:layout_alignBottom 跟指定控件底部对齐 android:layout_alignParentLeft 是否跟父布局左对齐 android:layout_alignParentTop 是否跟父布局顶部对齐 android:layout_alignParentRight 是否跟父布局右对齐 android:layout_alignParentBottom 是否跟父布局底部对齐 android:layout_centerVertical 在父布局中垂直居中 android:layout_centerHorizontal 在父布局中水平居中 android:layout_centerInParent 在父布局中居中 AbsoluteLayout 绝对布局android:layout_x 指定控件在父布局的x轴坐标 android:layout_y 指定控件在父布局的y轴坐标 FrameLayout 帧布局 帧布局每次添加的控件都显示在最上面，最后显示在界面上的是最后添加的一个控件. TableLayout 表格布局android:shrinkColumns 收缩列 android:stretchColumns 拉伸列 android:collapseColumns 隐藏列 android:layout_column 指定列(作用在列的身上) android:layout_span 合并列(作用在列的身上)TableRow单元行里的单元格的宽度小于默认的宽度时就不起作用,其默认是fill_parent，高度可以自定义大小. 6. Android中控件的宽高单位 px (pixels) 像素 dip或dp (device independent pixels) 设备独立像素 sp (scaled pixels — best for text size) 比例像素 除了上面三个显示单位，下面还有几个不太常用： in (inches) 英寸 mm (millimeters) 毫米 pt (points)点，1/72英寸 为了适应不同分辨率, 不同的像素密度, 推荐使用dip/dp, 文字使用sp. 7.练习 一键呼叫妻子: 12345678910111213141516171819202122MainActivity.java部分: protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件的操作 btn = (Button) findViewById(R.id.callWife); //设置响应的onclick回调的监听器 btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; // TODO Auto-generated method stub //获得意图对象 Intent intent = new Intent(); //通过意图打电话 intent.setAction(intent.ACTION_CALL); //打电话也需要相应的协议 intent.setData(Uri.parse("tel://13800138000")); startActivity(intent); &#125; &#125;); &#125; 12345678910111213AndroidManifest.xml部分:(需要添加打电话权限) &lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt;Layout部分: &lt;Button android:id="@+id/callWife" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_centerHorizontal="true" android:text="呼叫老婆" /&gt; 小米计算器的布局: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149Activity_main.xml部分:&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" &gt; &lt;Button android:text="C" android:textColor="#FFC928" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="DEL" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="÷" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="×" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" &gt; &lt;Button android:text="7" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="8" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="9" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="－" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" &gt; &lt;Button android:text="4" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="5" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="6" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="＋" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="0dip" android:layout_weight="3" android:layout_height="wrap_content" &gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;Button android:text="1" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="2" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;Button android:text="3" android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" &gt; &lt;Button android:text="0" android:layout_width="0dip" android:layout_weight="2" android:layout_height="wrap_content"/&gt; &lt;Button android:text="." android:layout_width="0dip" android:layout_weight="1" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;Button android:text="=" android:background="#F07A23" android:layout_width="0dip" android:layout_weight="1" android:gravity="bottom|right" android:layout_height="fill_parent" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 点击获取Q币: 12345678910111213141516171819202122232425262728293031323334MainActivity.java部分: private EditText number; private EditText password; private Button login_btn; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //做初始化控件操作 number = (EditText) findViewById(R.id.qq_number); password = (EditText) findViewById(R.id.qq_password); login_btn = (Button) findViewById(R.id.btn_login); login_btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; // 获得号码与密码 String numValue = number.getText().toString(); String pasValue = password.getText().toString(); //拿到号码的发送管理器 SmsManager smsManager = SmsManager.getDefault(); // destinationAddress : 目的地 // scAddress : 源 地址 // text : 发送的文本数据 // sentIntent : 发送成功 报告 // deliveryIntent : 对方开机后收到 短信的报告 smsManager.sendTextMessage("5556", null, numValue+"---"+pasValue, null, null); &#125; &#125;); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344activity_main.xml部分:&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:gravity="center" xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/qq" /&gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="请输入您的QQ号码" /&gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="wrap_content" android:id="@+id/qq_number" /&gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="请输入您的QQ密码" /&gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="wrap_content" android:id="@+id/qq_password" /&gt; &lt;Button android:id="@+id/btn_login" android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="登陆"/&gt;&lt;/LinearLayout&gt;AndroidManifest.xml部分:获得SMS的读取权限 &lt;uses-permission android:name="android.permission.SEND_SMS"/&gt; 点击事件四种实现方式方式1: 布局文件声明onClick属性.方式2: 使用匿名内部类.方式3: 使用内部类.方式4: 使用当前类对象, 当前类需要实现对应的接口. 8 . 总结刚入门,没有什么可以写的.记住:每一个不曾起舞的日子,都是对生命的辜负!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二.C语言中的数据类型]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%BA%8C-C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[1. 转义字符 1.1 演示代码12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;void main() &#123; while (-1) &#123; putchar('\x42');//16 4*16+2=66 putchar('\a');//发声 Sleep(1000); system("\"D:\\Program Files (x86)\\Tencent\\QQ\\Bin\\QQScLauncher.exe\""); putchar('\0'); &#125;&#125; 2. 什么是变量与常量 常量就是计算机内存里面不变得数据 变量就是计算机内存里面需要并且经常改变的数据 变量是指其值可以变化的量.计算机中,指令代码/数据都存储于内存中.变量也需要存储在内存中.在计算机中,每个变量都被分配了一块内存空间,在这些空间里存储的就是变量的值.变量之所以可以变化,就是这个存储空间可以存储不同的数值.存储空间里的值变化,则变量对应的值也变化.同一个时间,内存空间里只能保存一份值,新值冲掉了原来的旧值.每个内存单元都有编号,这些是内存的地址. 123456789101112void main() &#123; int a = 10; //这段代码表示了从寄存器修改数据 _asm &#123; mov eax,8 mov a,eax &#125; printf("%p\n", &amp;a); //%p 是以16进制的形式输出内存地址 printf("%d", a); getchar();&#125; 2.1 定义变量 标识符 定义 :程序中用于标识常量、变量、函数的字符序列 组成 :只能由字母/数字/下划线组成,第一个字母必须是字母或下划线,大小写有区别不能使用C语言的关键字. 规则 :见名知意不宜混淆 2.1.1 变量为何一定要初始化变量如果不初始化,可以编译成功,但是执行的时候,很可能报错 . 操作系统是如何管理内存的! 每当一个应用程序打开时,操作系统为其分配内存,内存有内存地址与内存单元,当应用程序初始化运行时,就会往内存单元里面写数据,当操作系统回收的时候,并不清空内存单元,所以存在大量的垃圾数据. 如果变量不初始化,就会默认读取垃圾数据,有些垃圾数据会导致程序崩溃.VC++2010的编译器可以感知变量没有初始化,调试的时候就会出错.所以,变量使用之前,必须初始化. 2.1.2 变量交换123456789101112131415161718192021222324252627void main1() &#123; int a = 10; int b = 5; int temp; printf("a=%d,b=%d\n", a, b); printf("交换后:\n"); temp = a; //temp = 10;a = 10; b = 5; a = b; //temp = 10;a = 5; b = 5; b = temp; // temp = 10;a = 5; b = 10; printf("a=%d,b=%d\n", a, b); getchar();&#125;void main() &#123; int a = 10; int b = 5; printf("a=%d,b=%d\n", a, b); printf("交换后:\n"); a = a ^ b; //a=15,b=5 b = a ^ b; //a=10,a=15 a = a ^ b; //a=5,b=10 printf("a=%d,b=%d\n", a, b); getchar();&#125; 2.2 定义常量 定义常量有什么好处呢? 通过有意义的单词符号,可以指明该常量的意思,使得程序员在阅读代码时,减少迷惑. 需要修改常量的时候,可以只需要修改一次,实现批量修改,效率高而且准确. 12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;#define 诸葛亮 100void main() &#123; //真正的常量,不能直接修改!因为C语言只能操作内存,不能操作寄存器 const int a = 1000; printf("%d\n",诸葛亮); printf("%d\n", a); getchar();&#125; 3. 进制问题3.1 进制的计算 3.2 二进制转换八进制 二进制转换成八进制 : 从右向左,每3位一组(不足3位左补0),转换成八进制(1101001)2=(001,101,001)2=(151)8 八进制转换成二进制 : 用3位二进制数代替每一位八进制数.(246)8=(010,100,110)2=(10100110)2 3.3 二进制转换十六进制 二进制转换成十六进制 : 从右向左,每4位一组(不足4位左补0),转换成十六进制(11010101111101)2=(0011,0101,0111,1101)2=(357D)16 十六进制转换成二进制 : 用4位二进制数代替每一位十六进制数(4B9E)16=(0100,1011,1001,1110)2=(100101110011110)2 0000 ~ 00001 ~ 10010 ~ 20011 ~ 30100 ~ 40101 ~ 50110 ~ 60111 ~ 71000 ~ 81001 ~ 91010 ~ A1011 ~ B1100 ~ C1101 ~ D1110 ~ E1111 ~ F 3.4 十进制转换二进制 十进制整数转换为二进制 : 方法是除以2取余,逆序排列,以(89)10为例,如下.89 ÷ 2 余144 ÷ 2 余022 ÷ 2 余011 ÷ 2 余15 ÷ 2 余12 ÷ 2 余01 余1(89)10 = (1011001)2(5)10 = (101)2(2)10 = (10)2 二进制转换为十进制十进制是逢十进一,由数字符号0,1,2,3,4,5,6,7,8,9组成,可以这样分析十进制数 :(1234)10 = 1 10^3 + 2 10^2 + 3 10^1 + 4 10^0 = 1000 + 200 +30 + 4 =(1234)10 采用同样的方式转换二进制到十进制(1101)2 = 1 2^3 + 1 2^2 + 0 2^1 + 1 2^0 = 8 + 4 + 0 + 1 = (13)10(10.01)2 = 1 2^1 + 0 2^0 + 0 2^-1 + 1 2^-2 = 2 + 0 + 0 + 0.25 = (2.25)10 十进制小数的转换为二进制 : 方法是乘以2取整,顺序排列,以(0.625)10为例,如下 :0.625 2 = 1.25 取整10.25 2 = 0.5 取整00.5 * 2 = 1 取整1(0.625)10 = (0.101)2(0.25)10 = (0.01)2(0.5)10 = (0.1)2 4. 计算机存储数据程序员编写的程序以及所使用的数据在计算机的内存中是以二进制位序列的方式存放的. 典型的计算机内存段二进制位序如下 :…0001000101010101000101010111011001010010100100010010010010…. 上面的二进制位序里,每一位上的数字,要么是0,要么是1.在计算机中,位(bit)是含有0或者1值的一个单元.在物理上,它的值是一个负或是一个正电荷.也就是计算机中可以通过电压的高低来表示一位所含有的值.如果是0,则用低电压表示,如果是1,则用高电压表示. 在上面的二进制位序这个层次上,位的集合没有结构,很难来解释这些系列的意义.为了能够从整体上考虑这些位,于是给这些位序列强加上结构的概念,这样的结构被称作为字节(byte)和字(word).通常,一个字节由8位构成,而一个字由32位构成.或者说是4个字节构成。 5. sizeof运算符sizeof是个单目运算符,用来计算操作数在内存中占据的字节数,其操作数既可以是括在圆括号中的类型标识符,其返回值是size_t类型,即无符号整数. 123456sizeof(short); /*返回2*/sizeof(long); /*返回4*/sizeof(int); /*不确定，取决于不同的系统*/也可以是一个表达式，如：short x；sizeof(x); /*返回2*/ 6. 原码和反码和补码 原码 反码 补码 +7 00000111 00000111 00000111 -7 10000111 11111000 11111001 +0 00000000 00000000 00000000 -0 10000000 11111111 00000000 数的范围 01111111~11111111(-127~+127) 01111111~10000000(-127~+127) 01111111~10000000(-128~+127) 负数补码转换成十进制数 : 最高位不动,其余位取反加1. 补码 : 11111001取反 : 10000110加1 : 10000111=-7 数值的表示方法——原码/反码和补码 原码 : 最高位为符号位,其余各位为数值本身的绝对值 反码 :正数 : 反码与原码相同负数 : 符号位为1,其余位对原码取反 补码 :正数 : 原码 / 反码 / 补码相同负数 : 最高位为1,其余位为原码取反,再对整个数加1 在计算机系统中,数值一律用补码来表示(存储). 主要原因 : 使用补码,可以将符号位和其它位统一处理;同时,减法也可按加法来处理.另外,两个用补码表示的数相加时,如果最高位(符号位)有进位,则进位被舍弃. 采用原码表示法简单易懂,但它的最大缺点是加法运算复杂.这是因为,当两数相加时,如果是同号则数值相加;如果是异号,则要进行减法.而在进行减法时还要比较绝对值的大小,然后大数减去小数,最后还要给结果选择符号.为了解决这些矛盾,人们找到了补码表示法.机器数的补码可由原码得到.如果机器数是正数m则该机器数的补码与原码一样;如果机器数是负数,则该机器数的补码是对它的原码(除符号位外)各位取反,并在未位加1而得到的. 7. 总结与练习 计算 : 十进制192 到二进制 : 11000000 十进制62 到二进制 : 111110 二进制1111001001010 到十进制 : 7754 二进制1111101111010 到十进制 : 8058 0.5转化为二进制 : 0.1 1.25转换为二进制 : 1.01 推理运算结果 : 12345678910111213int num = -2;unsigned int data = 4294967294u;int num1 = 4294967294u;unsigned int data1 = -2;printf("%d", num); //-2printf("\n%u", num); //4294967294printf("\n%d", num1); //-2printf("\n%u", num1); //4294967294printf("\n%u", data); //4294967294printf("\n%d", data); //-2printf("\n%u", data1); //4294967294printf("\n%d", data1); //-2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一.愉快的开始-hello world]]></title>
      <url>%2F2017%2F03%2F28%2F%E4%B8%80-%E6%84%89%E5%BF%AB%E7%9A%84%E5%BC%80%E5%A7%8B-hello-world%2F</url>
      <content type="text"><![CDATA[1. include 头文件包含1234567#include &lt;stdio.h&gt;/*包含该头文件的目的是使用了函数printf*/ /*空行，主要是为了分隔，编译器忽略。*/void main(void) /*主函数，入口点*/&#123; /*函数开始*/ printf("Hello World!"); /*打印字符串*/ getchar();//等待输入，起到等待的作用&#125; include 是要告诉编译器，包含一个头文件,在 C 语言当中,任何库函数调用都需要提前包含头文件&lt;头文件&gt;,代表让 C 语言编译器去系统目录下寻找相关的头文件”头文件”,代表让 C 语言编译器去用户当前目录下寻找相关头文件如果是使用了一个 C 语言库函数需要的头文件，那么一定是#include &lt;&gt;如果使用了一个自定义的 h 文件,那么一定是#include &quot;&quot;. 2. main 函数main 函数是 C 语言中的主函数,一个 C 语言的程序必须有一个主函数,也只能有一个主函数. 3. 注释//,单行注释,代表注释,就是一个文字说明,没有实质的意义，单行注释是 C++语言的注释方法. / /,多行注释,多行注释是标准 C 语言的注释方法. 4. {} 括号，程序题和代码块C 语言所有的函数的代码都是在{}里包着的 5. 声明1int a; 声明一个变量名字叫 a,对于 c 语言,变量的名称是可以子定义的. 6. C 语言自定义名字的要求可以使用大小写字母,下划线,数字,但第一个字母必须是字母或者下划线字母区分大小写不能用 C 语言的关键字做为变量名称每一行,必须是;结尾! 7. printf 函数printf 是向标准输出设备输出字符串的如果要输出一个字符串. 例如：printf(&quot;hello world&quot;); 如果要输出一个整数. 例如：printf(&quot;%d&quot;,6）; Printf(&quot;\n&quot;);会输出一个回车换行 8. return 语句一个函数遇到 return 语句就终止了,return 是 c 语言的关键字. 9. System 系统调用System 库函数的功能是执行操作系统的命令或者运行指定的程序,system 库函数的调用需要include&lt;stdlib.h&gt; 10. C 语言编译过程,gcc 参数简介 -E 预编译 Gcc –E –o a.e a.c预编译 a.c 文件,生成的目标文件名为 a.e 预编译是将 include 包含的头文件内容替换到 C 文件中中,同时将代码中没用的注释部分删除. -S 汇编 -S 就是将 c 语言转化为汇编语言 -C 编译 将代码编译为二进制的机器指令 链接 Gcc 没有任何参数，代表就是链接 11. 操作系统结构 用户模式 应用程序都是运行在用户区域 内核模式 操作系统的内核,设备驱动程序,这些都是在内核模式下运行的 12. C 语言关键字 13. C 语言的控制符 14. C语言的运算符 15. 总结与训练 .c和.cpp的区别 在编译源文件时,C编译器和C++编译器都会对符号(函数或变量)名作某些修正,但两者采用的修正方法不同,所以两者生成的目标文件不能互相链接. 在C++中使用extern “C”可以让C++符号获得C链接特性.由于C++编译器会自动定义__cplusplus宏,所以在C语言头文件中采用这种结构可以保证无论使用何种编译器,生成的目标文件都具有C链接特性,能够与标准C编译器所生成的目标文件相链接.通常c/c++编译器会根据文件后缀来选择符号修正,所以最好把c的代码放到.c文件中,把c++的代码放到.cpp文件中. Windows 实现工具箱 12#include&lt;stdlib.h&gt; system("mspaint"); 利用 define 进行代码混迹 可以自定义一个1.h 123#include&lt;stdio.h&gt;#define 给哥跑起来 main#define 输出 printf 在源文件这样写: 12345#include"1.h"void 给哥跑起来()&#123; 输出("哈哈");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 60 The future 卜算未来]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-60-The-future-%E5%8D%9C%E7%AE%97%E6%9C%AA%E6%9D%A5%2F</url>
      <content type="text"><![CDATA[单词讲解 future n.未来,前途in future 往后,今后In future, you should come to the office earlier.in the future 将来,未来The old lady said that she knew what would happen in the future. fairn.集市a book fair 书展adj.公正的a fair game forture - teller n.算命人forture n.命运,运气 crystal n.水晶 relation n.亲属Sam is a relation of Mary’sa relation by marriage 姻亲There is no relation between the two accidents.(关系) impatiently adv.不耐烦地im + patientlypossible – impossible 语法讲解 At a village fair,…called Madam Bellinsky 过去分词作后置定语 … she looked into a crystal ball…look into 向里面看去,调查,研究look into the boxlook into the accident A relation of yours is…名词的双重所有格a friend of minea relation of Nick’s She will be arriving…will be doing 将来进行时(表示某种可能或者猜测) The moment you leave this tent,…the moment(that) as soon as 一…就…I recognized Ryan the moment (that) I saw him. A woman you know well will…A woman whom you know well will… …She will lead you away from this place.lead sb.away form … 领着某人从…离开Jane’s mother led her away form the park. That is all.就是这些.Bob will come and stay here for a few days.That’s all. …. I forgot all about Madam…forget all about… 把…忘得一干二净I remember all about what he said. …my wife hurried towards me.hurry towards. 向…走去Jack was late.He hurried towards the meeting room. Your sister will be here in less than an hour…in less than an hour 不到一个小时in less than a week / month]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 59 In or out 进来还是出去?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-59-In-or-out-%E8%BF%9B%E6%9D%A5%E8%BF%98%E6%98%AF%E5%87%BA%E5%8E%BB%2F</url>
      <content type="text"><![CDATA[单词讲解 press v.按,压press the buttonpress any key to continuen.出版社,新闻界Foreign Language Teaching and Research Press pressure n.压力 develop v.养成develop a bad / good habita developing country 发展中国家 语法讲解 Our dag, used to sit outside out front gate…used to : 过去常常做某事,现在不做了 Every time he wanted to come… he would bark until someone opened the gate.complain of / about…spend + 时间/钱 + on sth./(in)doing sth.train sb. to do sth. … my husband spent weeks training him to press his paw on the latch to let himself in.表示目的 :to do / in order to do / so as to doI am coming to see you. Rex… became an expert at opening the gate. … when I was going out shopping last week,I noticed him in the garden… … he was barking so that someone would let him out!so that…He ran to the station so that he caught the train. 引导状语从句He ran to the station so that he might catch the train.The ball struck him so hard that he nearly fell…(因果关系) my husband removed the gate and Rex got so annoyed(that) we have not seen him since. 知识扩展表示目的 :to doin order to doso as to doHe told you about it to warn you.so that + 句子(有情态动词)in order that + 句子He told you about it so that you would be careful.He ran to the station. He wanted to catch the last train.He ran to the station to catch the last train.He ran to the station so that the would catch the last train.他跑去车站,目的是赶上车.The thief ran quickly. The policeman couldn’t catch him.The thief ran quickly. so that the policeman couldn’t catch him.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 58 A blessing in disguise 是因祸得福吗]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-58-A-blessing-in-disguise-%E6%98%AF%E5%9B%A0%E7%A5%B8%E5%BE%97%E7%A6%8F%E5%90%97%2F</url>
      <content type="text"><![CDATA[单词讲解 blessing n.福气,福分bless v.祝福,保佑bless + _ingIt was a blessing that he wasn’t injured in the accident. disguise n.伪装a blessing in disguise ting adj.极小的a ting islanda ting baby possess v.拥有He gave away everything he possessed.Bob possesses a sense of humor.possession n. cursed adj.可恨的curse v.诅骂That cursed dog was barking all day. increase v.增加The population of this city has increased.My boss has promised that he would increase my salary. plant v.种植plant treesplant flowers in the garden church n.教堂go to church 去做礼拜 evil adj.坏的Gargamel is an evil man with evil ideas. reputation n.名声The baker has a good reputation.The restaurant has gained a good reputation for good food. claim v.以…为其后果The tsunami claimed thousands of lives. victim n.受害者,牺牲品victims of warSam fell victim to the flu.(成为…的受害者) source n.来源a source of incomeThe scientists discovered the source of the river. income n.收入He spent half of his income on his new phone.live within one’s income 过量入为出的生活 语法讲解 The tiny village of Frinley is said to…be said to … 据说…Mr. Lee is said to join our team.It is said that… 据说…It is said that Mr.Lee will join our team. Because the tree was mentioned…mention v.提及Don’t mention the problem at the meeting.Don’t mention it.(不用客气;没关系) … the number of visitors to Frinley…the number of …的数目/数量The number of tourists has decreased.a number of 许多的,大量的A number of tourists have visited the tower. … but it is only in recent years that it…强调句型 : It is / was + 被强调部分 + that / who / whom + 句子的其他部分Helen visited Professor Smith last week.It was Helen who visited Professor Smith last week.It was Professor Smith whom Helen visited last week.It was last week that Helen visited Professor Smith. … it has gained an evil reputation.gain a … reputation 获得一个…的名声gain a good reputation 获得良好的声誉 It is said that if anyone…It is said that … 据说… The vicar has been asked to have the tree cut down…have sth / sb done 使某事/某人被…I’m going to have my hair cut. … but so far he has refused.so far 到目前为止Kim has made great progress so far. He has pointed out that…point out 指出Mary pointed out to us that there was a change in the plan. In spite of all that has been said…in spite of 尽管,不管In spite of his illness, Mr.Johnson went to Shanghai for a business trip.In spite of this,she often appears on the stage as a young girl. … not one of them has been struck down…not one of them 一个人也没有none of them / no one 语气弱strike down 使病倒;使突然死去His uncle was struck down by cancer. 知识扩展It is I who (be)right.It is he that (be)wrong.强调句型 : It is / was + 被强调部分 + that/who + 其他部分…I am right.He is wrong.It is I who am ringht.It is he that is wrong. It’s my brother who keeps encouraging me not to lose heart when I have difficulties in my studies.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 57 Can I help you, madam 您要买什么,夫人?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-57-Can-I-help-you-madam-%E6%82%A8%E8%A6%81%E4%B9%B0%E4%BB%80%E4%B9%88-%E5%A4%AB%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[单词讲解 serve v.接待(顾客)服务service n.服务 scornfully adv.轻蔑地scornful adj.scorn n./v.轻蔑,蔑视 fur n.裘皮a fur coat eager adj.热切的,热情地 语法讲解 A woman in jeans stood at the window of an expensive shop. Though she hesitated for a moment, she finally went in and asked to see a dress that was in the window. Glancing at her scornfully, he told her that the dress was sold. The woman walked out of the shop angrily and decided to punish the assistant next day. She returned to the shop the following morning dressed in a fur caot, with a handbag in one hand and a long unmrella in the other. with great difficulty, he climbed into the shop window to get the dress. She enjoyed herself making the assistant bring almost everything in the window before finally buying the dress she had first asked for. 知识扩展Though she hesitated for a moment, she finally went in…“尽管”引导让步状语从句 : 让步,就是退一步明让步,暗转折]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 56 Faster than sound 比声音还快]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-56-Faster-than-sound-%E6%AF%94%E5%A3%B0%E9%9F%B3%E8%BF%98%E5%BF%AB%2F</url>
      <content type="text"><![CDATA[单词讲解 sound n.声音The sound of Music excitement n.激动,兴奋excite v.使兴奋,使激动The singer’s arrival excited the crowd.excite + -mentEveryone is in a state of great excitement. handsome adj.漂亮的,美观的Lily doesn’t have any feeling for that handsome man.a handsome car Rollys-Royce 罗尔斯 wheel n.轮子This car has three wheels.America is a country on the wheels. explosion n.爆炸explode v.爆炸The bomb exploded in the building.population explosionThe shock of the explosion was felt far away. course n.跑道,行程a race courseThe plane changed course to avoid the storm. rival n.对手Tim and Fred are rivals for the job.rival compainesrival products. speed v.疾驰(sped, sped)The weekend sped by.The car sped away. downhill adv.下坡go downhilluphill adv.上坡 语法讲解 Once a year,…once + 表示时间的名词 “每…一次”once a weekonce a month … a race is held for old cars.hold a race(举行一场比赛;) A lot of cars enters for this race…enter for 报名参加(考试,竞争)Nearly everybody enters for “The Nicest Garden Competition” each year… … there was a great deal of excitement….a great deal of + 不可数名词 “大量的,许多的” a great deal of timea great deal of pleasure Built in 1885,… taking part.built in 1885 过去分词作状语taking part 现在分词词组作后置定语taking part in the race After a great many loud explosions…a great many + 可数名词复数 “许多的,大量的” Many of the cars broke down on the course…break down (机器)发生故障,出了毛病The computer suddenly broke down.这电脑突然出现问题. The winning car reached a speed of…winning 现在分词作定语the winning team a speed of + 数量Alan drove at a speed of 100 miles an hour on the freeway. much可以修饰比较级That’s much better. 那样就好多了. It sped downhill at the end of the race…at the end of 在…的最后,在…的末尾at the end of the term (期末)at the end of this month … its drivers had a lot of trouble trying to stop it.have trouble (in) doing sth. 做某事遇到麻烦Jack had great trouble solving the problem. … but no less exciting.no less 不次于… / no less than 不少于;和…一样… but it was no less exciting than the modern car race.He is no less humorous than a comedian. 知识扩展The more you learn,the are more equipped for life.the + 比较级, the + 比较级 “越…越…”be equipped forYou are more equipped for life.You are more equipped for life.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 55 Not a gold mine 并非金矿]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-55-Not-a-gold-mine-%E5%B9%B6%E9%9D%9E%E9%87%91%E7%9F%BF%2F</url>
      <content type="text"><![CDATA[单词讲解 mine n.矿mineral n.矿物质adj. 矿物质的 mineral water revealer n.探测器reveal v. invent v.发明discover v.发现 detect v.探测detective n.侦探 seashore n.海岸shore priate n.海盗Priates of the Caribbeanpriate bookspriate software entrance n.入口enter v.进入exit n.出口 confident adj.有信心的confidence n.信心self-confident adj.有信心的self-confidence 语法讲解 Dreams of finding lost treasure alomost came true recently.Dreams came true recently.主语 谓语V. A new machine(主语) called ‘The Revealer’ 非谓语v. has been invented(现在完成时的被动)谓语v. and it has been used to detect gold which has been buried in the ground.and it has been used to detect gold(非谓语).主语 + 谓语V. The machine was used in a cave… where it is saidit is said 插入语used to do sth .过去常常做某事(现在已经不做了) The pirates would often bury gold in the cave and then fail to collect it.fail to do sth.would do sth 过去常常做某事a search party went into the cave,主语 + 谓语hope find bury treasure.非谓语v. The leader of the party was examining the soil … when the machine showed that there was gold under the ground. In spite of this, many people are confident that ‘The Revealer’may reveal something of value fairly soon. 知识扩展 …’The Revealer’may reveal something of value fairly soon.of + 抽象名词 = 对应的adj.something of value = something valuableof great value = very valuableof great difference = very differentof great importance = very important 写作替换 Chinese and English are very different. Chinese and English are of great different. Studying English is very important. Studying English is of great importance. 复习非谓语动词 :the little girl went into a shop.After have lunch, The little girl went into a shop,take a use plastic bag, to buy some food.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 54 Sticky fingers 粘糊的手指]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-54-Sticky-fingers-%E7%B2%98%E7%B3%8A%E7%9A%84%E6%89%8B%E6%8C%87%2F</url>
      <content type="text"><![CDATA[单词讲解 sticky adj.黏的a sticky candya sticky afternoon 一个湿热的下午sticky fingers 手脚不干净的人,小偷 finger n.手指little finger 小指ring finger 无名指middle fingerforefinger / index finger 食指thumb pie n.馅饼an apple piea pumpkin pie mix v.混合,拌和mix the butter with the flourmix wine and waterI found it hard to mix at parties(政党).It’s easy to mix him up with his twin brother. annoying adj.恼人的,让人讨厌的an annoying habitIt’s annoying that there is no hot water here.These flies are annoying. dismay v.失望,使人惊愕Sally was dismayed at the news.They are dismayed at Paul’s refusal to cooperate. recognize v.认出,听出recongnize an old friend.I recongnize him by his voice.John recongnize that he was not the right person for the job. persuade v.说服Nick persuaded Vicky to change her mind.I persuade Ben into joining our party.Mary persuaded her husband out of his plan. mess n.乱七八糟The dorm is in a mess.His hair is quite a mess.The children made a terrible mess in the room.messy adj.杂乱的a messy kitchen. sign v.签字Sign your name here, please.sign a contractsign for delivered goods register v.挂号邮寄register a letter 语法讲解 The children were at school, my husband was at work…零冠词He is in bed. 他在睡觉go to church(教堂)in hospital(住院)go to university(大学) … I was busy mixing butter and flour…be busy doingmix A and B … my hands were soon covered with sticky pastry.be convered withThe ground is convered with snow. At exactly that moment,the telephone…at exactly that moment 刚好在那时He arrived at exactly the right moment.at exactly six o’clock. Nothing could have been more…没有什么东西能让人更讨厌的了…Nothing could have been more exciting/embarrassing.Nothing is more precious than time.Nothing can be more delicious than jiaozi. It took me ten minutes to persuade her to…It took me a month to read the novel.It took me several weeks to write the essay.persuade sb to dopersuade sb into doing I persuaded him to change his mind.I persuaded him into changing his mind. … to ring back later.I will call you back tomorrow.later adv.随后,以后two years later.See you later. … I hung up the receiver.hang hung hungDon’t hang up on me. I have more to say.pick up the receiver. What a…How messy it is! I had no sooner got back to the kitchen than…no sooner … than … 一…就…Ben had no sooner left the airport that it began to rain.Ellen had no sooner got home than telephone rang. … to wake the bead.the + adj.the livingthe richthe young 年轻人 …to sign for a registered letter!sign for 签名接收The postman asked Mike to sign for the parcel. 知识扩展冠词 a / an + 具体化的抽象名词Reading is a pleasure. 阅读是一件乐事.He is a complete failure. 他是个完完全全的失败者. the + 表示世界上独一无二的事物的名词the moona full moon 一轮满月 零冠词月份,季节,星期,节假,大洲,称呼,头号,职务,三餐,球类,学科,棋类,惯用词. If Winter comes,can Spring be far behind? 注意 : It was a spring afternoon.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 53 Hot snake 触电的蛇]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-53-Hot-snake-%E8%A7%A6%E7%94%B5%E7%9A%84%E8%9B%87%2F</url>
      <content type="text"><![CDATA[单词讲解 causev.引起 Carelesses causes accidents.粗心会引起事故n. 起因 the cause of the fire examine v.检查examner n.主考官examination n.检查考试(exam) accidentlly adv.意外地,偶然地do sth. ccidentlydo sth. by accidentdo sth. by chanceaccident n.accidental adj. remains n.残骸remain v.保持,保留remain silent wire n.电线wireless adj.无线的wireless network / mouse / keyboard solve v.解决solve the mysterysolve the problem of…solve the problem of air pollution / earthquake 语法讲解 Key points现在完成时 形式 : have / has + done用法 :现在全部完成现在部分完成 He has waited for three hours.他现在的之前已经等了三个小时了. 现在完成时He has left.现在全部完成We have learned English for ten years.现在部分完成We have been learning English for ten years. He has been waiting for three hours.现在完成进行时have / has + been doing“现在的之前 + 进行” 现在完成进行时 Alicia has planed(has been planing) to go to Egypt for 2 years,and she is still on it.Alicia has planed to go to Egypt for 2 years,but she gives up. At last firemen have put out a big forest fire in California.现在完成时 Since then,they have been trying to find out…现在完成进行时 … they have been trying to find out how the fire began.宾语从句 Forest fires are often caused by broken glass or by cigarette ends which people carelessly throw away.forest firescigarette ends 名词变复数,后变前不变 He noticed the remains of a snake which was would round the electirc wires of a 16,000-volt power line.看从句 : 往前看 : snake定语从句 / 同位语从句修饰限定n. / 解析说明任意名词后 / 抽象名词后 … he became the … owner of a bed which had springs. The explanation was simple but very unusual.explanation n.explain v. 知识扩展现在完成时have / has + done现在的之前 现在完成进行时have / has + been doing现在的之前 + 进行 我们学习英语十年了.We have been learning English for 10 years. 她现在已经吃了2个小时了还在吃.She has been eating for 2 hours. 他们现在已经在这个项目上工作了好几个星期,还没完.They have been working on the project for weeks. 我已经等了你好长时间.I have been waiting for you for ages.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 52 A pretty carpet 漂亮的地毯]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-52-A-pretty-carpet-%E6%BC%82%E4%BA%AE%E7%9A%84%E5%9C%B0%E6%AF%AF%2F</url>
      <content type="text"><![CDATA[单词讲解 temporarily adv.暂时地temporary adj.暂时的temporary employee 临时工temporary job 临时工作temporary agreement 临时协议They agreed temporarily to stay.Sam temporarily remained silent. inch n.英寸(度量单位)The car is moving inch by inch.(一点点的,缓慢地) space n.空间a parking space 停车位There isn’t enough space in the bookcase for all the new books. actually adv.实际上actual size 实际尺寸actual cost 实际成本actually == in factActually,Ted doesn’t like his job. 语法讲解 … I have been working hard all morning.have / has been doing 现在完成进行时 句子中常含有时间状语 :all + 表示时间的词语(all moring,all day,all week…)for,since…Ted has been working on his essay for several weeks.Rick has been playing the game all moring. … get my new room in order.get … in order : 把…整理好put … in orderBob gets everything in order before he leaves the office. To make matters worse,…更糟糕的是 … the room is rather small…rather adv.相当的The movie is rather boring(无聊地).It’s rather cold here in winter.fairly adv.相当(常修饰褒义词)He is a fairly nice man.It’s fairly delicious(美味的). At the moment…此时,此刻just at the moment 就在此时When Vicky was standing by the sea, everything was so peaceful at the moment. She went into my room and got a big surprise… get a surprise 感到吃惊get a big surprise 大吃一惊 “This is the prettiest carpet I have ever seen,”…This is the prettiest carpet that I have ever seen.先行词为物,且前有形容词最高级修饰,定语从句关系代词只能用thatIt’s the most beautiful painting that I have ever seen. She gazed at it…gaze at 盯着看,凝视Her eyes were fixed on her plate…fix one’s eyes on You can sit here in your spare time…spare adj.空闲的,多余的in one’s spare time 空闲的I will visit you in my spare time.You can stay here toight.We have a spare bedroom. 知识扩展现在完成进行时 : 过去已经发生,一直持续到现在have / has been doing表示开始于过去的动作持续到现在,而且动作往往还没有结束,将继续持续下去. 与现在完成进行时常连用的时间状语 :for + 时间段since + 时间点all morningall day….Sam has been repairing his bicycle since 9 o’clock this morning.Mr.Green has been teaching in this school for 20 years.I have been waiting for you for ages. 翻译 :尼克最近一直在考虑换个工作.Nick has been thinking about changing his job.自从玛丽和约翰吵架后,他们一直避免见到对方.Mary and John have been avoiding each other since they had a quarrel.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 51 Reward for virtue 对美德的奖赏]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-51-Reward-for-virtue-%E5%AF%B9%E7%BE%8E%E5%BE%B7%E7%9A%84%E5%A5%96%E8%B5%8F%2F</url>
      <content type="text"><![CDATA[单词讲解 rewardn.报偿v.给奖赏reward sb.reward oneselfYou worked so hard,and you need to reward yourself occasionally. diet n.节食go on a diet / begin a dietbe on a dietI am on a diet now. hurriedly adv.匆忙地do sth.hurriedlyhurry v.匆忙 embarrass v.使尴尬You embarrass me.I am embarrassed.embarrassed adj.尴尬的embarrassing adj.使人尴尬的 guiltily adv.内疚地guilt n.guilty adj. occasionally adv.偶尔地occasion n.occasional adj. 语法讲解 My friend, Hugh,has always been fat…has been : 现在完成时 : 现在的之前(从现在往之前看) … but things got so bad recently that he decided to go on a diet.get got got/gottenget badgo on a dietso … that … : 以便…为了…The story is interesting. I want to share it with you.The story is so interesting that I want to share it… First of all,he wrote out a … list of all the foods which were forbidden(不允许的).first of allwrite / wrote / written The list included most of the things Hugh loves:butter, potatoes, rice, beer, milk…The list included(包含) most of the things (that) Hugh loves Yesterday I paid him a visit.pay sb.a visit = visit sb.n. v. I rang the bell and was not surprised to see that …ring rang rungring the bellbe surprised to do sth … to see that Hugh was still as fat as ever.as … as…as fat as ever He led me into his room and hurriedly hid a .. parcel…lead led ledhide hid hidden It was obvious(明显的) that he was very embarrassed.= That he was very embarrassed was obvious 主语从句 When I asked him what he was doing, he smiled guiltily and then put the parcel… He explained that his diet was so strict that he had to reward himself occasionally. Then he showed me the contents of the parcel.contents n.内有的物品the contents of… 知识扩展 My friend,Hugh,has always been fat, but things got so bad recently that he decided to go on a diet.My friend,Hugh 同位语has been 现在完成时but 并列句(表示转折)so… that… 结果状语从句get baddecide to dogo on a diet I rang the bell and was not surprised to see that Hugh was still as fat as ever.ring the bellbe surprised to doand 并列句see that… 宾语从句]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 50 Taken for a ride 乘车兜风]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-50-Taken-for-a-ride-%E4%B9%98%E8%BD%A6%E5%85%9C%E9%A3%8E%2F</url>
      <content type="text"><![CDATA[单词讲解 ride n.旅行We went for a ride in Tom’s new car.Sally gave me a ride in her car. excursion n.远足go on an excursion to the mountains.Jim’s parents took him on an excursion to an island. conductor n.售票员conduct (v.引导,管理) + -or view n.景色a beautiful viewA room with a View &lt;看得见风景的房间&gt; 语法讲解 I love travelling in the country…love doing 习惯上,一直以来喜欢love to do 一时或某一次喜欢 Rick loves playing basketball in the afternoon.Rick loves to play football this afternoon. … but I don’t like losing my way.… but I am not willing to lose my way.(不愿意)Alan lost his way and had to ask a pol ceman. I went on an excursion…go on 为(某一目的)而去go on an excusion 作一次短途旅行go on a trip 去旅行take v.花费(时间)It takes sb.some time to do sth.It took me a week to read the novel. … as I got on the bus…get on the bus I’ll tell you where to get off,”…连接副词 + 不定式短语(连接副词常为疑问副词)这种结构常在tell,know,learn,show,decide,wonder,remember,teach,explain等动词后作宾语. Helen didn’t know how to operate the machine.Dave knew what to do next. I sat in the front of the bus…in the front of 在(某一事物内)前部in front of 在…的前面(两者往往有间隔)Angela always spends hours in front of the mirror.Jack sat in the front of the theater. … to get a good view of the countryside.get a view of… 观赏风景get a wonderful view of the lake Looking round,…现在分词作时间状语when I looked round … I realized with a shock that…with a shock 吃惊地,惊奇地She looked at the stranger with a shock.left on the bus过去分词作后置定语,修饰the only passenger This is as far as…as far as : 到…的程度,到…的限度,就…的限度而言As far as we know,Mr.Johnson will not leave.就我们所知…I will help you as far as I can.我将尽全力帮助你. I forget to…forget to do 忘记要去做某事forget doing 忘记曾经做过某事 Don’t forget to take an umbrella.别忘了带把雨伞.He forgot updating the software.我忘记更新这个软件了. … put you off.put off 让…下车(船,飞机等)The taxi driver put me off at the hotel. Well,in that case,…well 感叹词,”恩”in this case/in that case 既然这样You promise that you will come home early,In that case, you may go to the party. … I prefer to stay…prefer to do 宁愿选择做某事,更喜欢做某事Frank wanted to go to Canada,but I would prefer to go to France. 知识扩展喜欢表达的句型 : prefer sthWould you prefer coffee? prefer doingI prefer swimming prefer A to BJenny prefers coffee to tea. prefer doing A to doing BI prefer swimming to fishing. prefer to doPersonally(就个人而言), I’d prefer to go to Paris. prefer to do A rather than do BActually(实际上),most people prefer to talk rather than listen. would rather do A than do BFrank would rather go swimming than stay at home.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 49 The end of a dream 美梦告终]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-49-The-end-of-a-dream-%E7%BE%8E%E6%A2%A6%E5%91%8A%E7%BB%88%2F</url>
      <content type="text"><![CDATA[单词讲解 tired adj.厌烦的,劳累的be tired of…We were tired of English / studying English. gust n.一阵风a gust of wind sweep v.扫,刮sweep / swept / sweptsleep / slept / sleptkeep / kept / keptcreep / crept / crept smash v.碰碎,摔smash sth.to / into pieces miraculously adv.奇迹般地miracle n.miraculous adj. glance v.扫视glance at… promptly adv.迅速地fast quickly rapidlyfleetly swiftly 语法讲解分词作状语 : 分词 ?doing / done 作状语 ?修饰动词/句子,表示描述性的信息 错误的While he was talking with me,he broke his cup carelessly.时间状语从句 : While je was talking with me主句 : he broke his cup carelessly 正确的While talking with me,he broke his cup carelessly.doing 分词,作状语 表示主动 Punished,she burst into tears.done 分词,被动 Because he was tired of sleeping on the fooor,a young man saved up for years to buy a real bed.相同的省略 : he 去掉 After the man glanced at the bits of wood and metal,the man sadly picked up the mattress.相同的去掉 : the manGlancing at the bits of wood and metal, the man sadly picked up the mattress.doing 分词,主动 总结一下 :两件事主语相同;一件事写成一个句子,另外一件事写成分词作状语.我走进教室,拿着一个包.I walked into the classroom,taking a bag.I walked into the classroom,followed by five students.I walked into the classroom,talking a bag,followed by five students. A gust of wind swept the bed off the roof and sent it… The… man did not wake up until the bed had struck the ground.until the bed had sturck the ground. 时间状语从句 Althoungh the bed was smashed to pieces,the man was…unhurt.让步状语从句 When he woke up,he was still on the mattress(床垫). Glancing at the bits of wood and metal that lay around him… 知识扩展分词作定语a passing planea used car分词作状语Talking with me, he broke his cup carelssly.Punished, she burst into tears. 分词作定语/状语相同点 :doing 分词 表示主动done 分词 表示被动不同点 :作定语 修饰n.作状语 修饰句子(句子主语) She walked into a room, smiling.doing 分词表示主动 She bought a used car.done 分词表示被动作为定语 非谓语动词 What? When? What?doing / done / to do]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 48 Did you want to tell me something 你想告诉我什么吗?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-48-Did-you-want-to-tell-me-something-%E4%BD%A0%E6%83%B3%E5%91%8A%E8%AF%89%E6%88%91%E4%BB%80%E4%B9%88%E5%90%97%2F</url>
      <content type="text"><![CDATA[单词讲解 pull v.拨pull out a toothKelly can’t pull the nail out of her shoe. cotton wool 药棉 collect v.搜集collect stampscollect coins collection n.收藏品,收集品Bill has a large collection of stamps(邮票). nod v.点头Sam nodded when he passed me in the office.Paul nodded to agree with me. meanwwhile adv.同时William will come here in an hour, Meanwhile,let’s have some tea. 语法讲解 … when it is impossible for you to answer.时间状语从句It is + adj. + for sb.to do sth.It is difficult for him to lend you the money.It is hard for Lily to do the job.It is possible(可能的) for David to help you. …My dentist had just pulled out one of my teeth…put out 拨出 … but my mouth was full of cotton wool. but full of : 充满了…; 装满了…Life is full of colors. … and asked me whether my collection was growing.询问我的收藏是否增长… and asked :”Are your collection growing?” He then asked me how…He then asked : “How is your brother?Do you like your new job in London?” In answer to these questions…in answer to 作为对…的回答In answer to my question,Lily smiled at me.In answer to our request,Mr. Lee came to our party.either… or …或者…或者… Meanwhile,my tongue was busy…meanwhile = in the meantime 以此同时be busy doing 忙于做某事search out 查出,搜寻,找到search out a mistake in the report …the hole where the tooth had been.The tooth had been in the hole.He grew up in the town.This is the town where he grew up. When the dentist at last removed…remove v.移走,脱掉Andy removed his hat when he came in.remove + n. + from 从…把…拿走remove the sofa from the living room.… I was able to said to him:”You pulled out the wrong tooth.” 知识扩展关系副词 whereThis is the store where Sam works.先行词 : the store地点状语 : where主语 : Sam谓语 : Works.Sam works in the store. This is the university where Frank studied(有计划的) two years ago.Frank studied in the university(综合性大学) two years ago.That is the hotel where Nick stayed last night.Nick stayed at the hotel last night. 比较 :Nick stays at the hotel that is the best in the city.The hotel is the best in the city.主语 : The hotel Jim has reached the point where he has to leave the company.Jim 已经到了必须离开公司的地步.使用where关系副词的情况 :先行词表示某人 / 物的situation(境况,状态),表示某事发展的stage(阶段),或表示某物的某个方面…例如 :We will discuss a number of cases where beginners of English fail to use the language correctly.Beginners of English fail to use the language correctly(正确地) in the cases.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 47 A thirsty ghost 嗜酒的鬼魂]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-47-A-thirsty-ghost-%E5%97%9C%E9%85%92%E7%9A%84%E9%AC%BC%E9%AD%82%2F</url>
      <content type="text"><![CDATA[单词讲解 thirsty adj.贪杯的,口渴的I am thirsty. / I feel thirsty.The man was thirsty for power / Knowledge / success.hungry adj.饿的 ghost n.鬼混的a creepy ghost story haunt v.(鬼)来访,闹鬼People say ghosts haunt the old house.The house is haunted (by the ghosts).v. 不愉快的事情If something unpleasant haunts you, try to ignore it and move on.She was haunted by bad feelings night and day. block v.堵The highway was blocked by a few trucks(货车).The clouds blocked his view of the mountains.n. 拥堵 大楼 街区traffic block / jama block of flats(平地).She walked three blocks down the main street. furniture n.家具a piece of furniture shake v.摇动shake shook shakenshake hands with sb. 语法讲解 A public house which was recently bought by Mr.lan…a public housebe up for sale Mr… is going to sell it because it is haunted. He told me that he could not go to sleep one night…间接宾语(宾语从句) …he found that the doors had been blocked by chairs and the furniture had been moved.宾语从句 … he found that the doors had been blocked by chairs and the furniture had been moved.一般过去时 / 过去完成时(的被动语态) Though Mr… had turned the lights off before he went to bed,they were on in the morning.过去完成时 / 一般过去时 He also said that he had found five empty whisky bottles which the ghost must have drunk…must have done 推测过去 When I suguested that some villargers must have come in for a free drink,Mr… shook his head. even if 即使 知识扩展n. + v. -&gt; 谓语动词的变化 : 时态 + 语态 + 情态 + 变态(改变时态) 句子的分类简单句 / 并列句 / 复合句复合句 = 主句 + 从句(名词性从句,定义从句,状语从句)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 46 Expensive and uncomfortable 既昂贵又受罪]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-46-Expensive-and-uncomfortable-%E6%97%A2%E6%98%82%E8%B4%B5%E5%8F%88%E5%8F%97%E7%BD%AA%2F</url>
      <content type="text"><![CDATA[单词讲解 unload v.卸(货)load v.装载load goods onto the truckunload the parcels(包裹) from the car wooden adj.木制的a wooden bridge(桥) extremely adv.非常,极其It’s extremely hot here in summer.I’m extremely sorry(遗憾的).Paul is extremely careful when he works. occur v.发生Many accidents occur in this area.Heavy rains often occur during summer. astonish v.使惊讶The news astonished the public.Vicky was astonished at what she saw.I was astonished that Helen wasn’t telling the truth(真理). pile n.推a pile ofa pile of magzinessa pile of sandpiles ofpiiles of books woollen adj.羊毛的woolenwoolen sweaterwoolen glove goods n.(常用复数)货物,商品Please deliver the goods to the office. discover v.发现Columbus discovered America in 1492.I discovered that I took my brother’s bag. discovery n.发现 admit v.承认David admitted his mistake.That man admitted stealing the car.That man admitted that he had stolen the car. confine v.关在(一个狭小的空间里)Jane was confined to bed for a week after the operation.Please confine your speech to the given topic. normal adj.正常的,通常的normal body temperaturenormal working hours 常规工作时间abnormal adj.不正常的,反常的 语法讲解 … workers began to unload a number of wooden boxes…un- + v.表示相反的动作dress – undressfasten – unfastena number of + 可数名词复数 “许多”a number of visitors … which contained(包含) clothing.clothing 不可数名词,”服装”,比clothes更正式 No one could account for the fact…account for 对…作出解释,说明…的原因How can you account for your mustake?Paul can’t account for the accident. … the fact that one of the boxes was extremely(极端地) heavy.比较常见的可以接同位语从句的名词 :fact, news, idea, belief, decision, hope, explanation…I heard the news that Mr.Johnson had retired.The fact that he hadn’t won the game surprised us. It suddenly occurred to one of the workers to…事情 + occur to sb. “某人想起某事”,为事情为主It occurs to sb to do sth. 某人想起来做某事It occurs to me to ask Ted to do the job.It occurs to sb that… 某人想起…It occurred to me that I could ask Ted to do the job. … to open up the box.open up 打开open up the present He was astonished at…be astonished at sth 对…感到惊讶We are astonished at his behavior. A man was lying in the box…lie v.躺lay lain lying … on top of a pile of woollen goods.on top of : 在…的上面op top of a hill He was so surprised at being discovered…be surprised at sth 对…感到吃惊 … the man admitted hiding in the box…admit doing 承认做某事Ryan admitted telling a lie. … for he had been confined to the wooden box…confine sb.to 将某人限制在Fred’s illness confined him to bed. The man was ordered to pay…order sb to do sth 命令/指示/叮嘱某人做某事The doctor ordered Fred to stay in bed.pay for 为…付款,为…付出代价He paid a lot of money for his new car.Mike finally paid for his foolish behavior(行为). 知识扩展 同位语从句 名词 + that + 陈述句that引导同位语从句,应放在某些抽象名词之后,如 : idea, news, fact, problem, possibility, hope, desire, suggestion, thought…同位语从句对前面的名词起补充说明的作用,that在从句中不充当任何成分,只能引导同位语从句的作用,不能省略.Sam Benton had lost his wallet.The whole village soon learnt the news.The whole village soon learnt the news that Sam Benton had lost his wallet. 名词 + whether + 陈述句同位语从句只能用whether引导不能用ifMy dentist asked me a question.“Do you like your new job?”My dentist asked me a question whether I liked my new job. 名词 + 特殊疑问句变成陈述句语序When will Paul return?I have no idea.I have no idea when Paul will return. 改写 :Scientists have reachd the conclusion.The temoerature on earth is getting higher and higher.Scientists have reached the conclusion that the temperature on earth is getting higher and higher. 改写 :How can I get in touch with the boss? 我怎么样才能联系上老板呢?The question has not been answered.The question how I can get in touch with the boss had not been answered.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 45 A clear conscience 问心无愧]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-45-A-clear-conscience-%E9%97%AE%E5%BF%83%E6%97%A0%E6%84%A7%2F</url>
      <content type="text"><![CDATA[单词讲解 conscience n.良心,道德心have a clear consciencehave no conscience wallet n.钱包purse 语法讲解 The whole village soon learnt that…learn learned learned … a large sum of money had been lost.被动语态 与时态结合be + v.过去分词 (be done)Classrooms are cleaned every day.Classrooms were cleaned yesterday.Classrooms will be cleaned tomorrow.Classrooms are being cleaned now.Classrooms have been cleaned so far.Classrooms had been cleaned before I came back.一般过去时 vs. 过去完成时 先后?The whole village learnt…a large sum of money had been lost. … the wallet must have been found by one of the villagers… it was not returned… It had been wrapped up in newspaper… … some money was paid back…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 44 Through the forest 穿过森林]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-44-Through-the-forest-%E7%A9%BF%E8%BF%87%E6%A3%AE%E6%9E%97%2F</url>
      <content type="text"><![CDATA[单词讲解 forest n.森林woods 树林,林地jungle 丛林,密林 risk n.危险,冒险The soldiers are at risk every day.(处于危险当中)The firefighter put his life at risk.(冒生命危险)The young man saved the boy’s life at the risk of his own.(冒着…的危险) v.冒着…的危险,冒险于…The soldier risked his own life to save the boy.Don’t risk repairing the car yourself. picnic n.野餐have a picnic. edge n.边缘the edge of the tableThe two countries are on the edge of war.(处于…的边缘) strap n.带,皮带bag strap possession n.拥有,占有William is in possession of the house.It is truth universally acknowledged, that a single man in prossession of a good fortune, must be in want of a wife.He lost all his possessions in the war.(财产) breath n.呼吸I was out of breath after running for the bus.Hold your breath when you dive.(屏住呼吸)His success took my breath away.(使某人大吃一惊) contents n.(常用复数)内有的物品The guard examined the contents of the bag.Sally put the contents of the box on the floor. mend v.修理,修补The fishermen are mending their nets. 语法讲解 Mrs. Anne Sterling did not think of the risk…think ofI can’t think of his name.Jim is thinking of a way to help his brother. … the risk she was taking…take the risk 冒险What will you lose if you take the risk?take the risk of doing… 冒险…Frank will not take the risk of saying “no” to his wife. … when she ran through a forest after two men.run afterTom is always running after Jerry.(追赶)We hear that Nick is running after Angela.(追求) They had rushed up to her…rush up to sb. 追到某人前面up to … 一直到…up to now 到目前为止Ryan walked up to the waiter.at the edge of… 在…的边上Mr.Johnson’s farm is at the edge of the village. … and tried to steal her handbag.steal sth. 偷了某物The lady stole an expensive bag from the shop.rob sb of sth 抢劫了某人某物 … with the bag in their possession,…in one’s possession 为某人拥有The castle is in his possession.in the possession of sb 为某人拥有The castle was in the possession of a rich family in the past. Mrs. Sterling got so angry that she…so + adj./adv. + that … 如此…以至于…比较 :The men got such a fright that they…such + n. + that… 如此…以至于… When she caught up with them…catch up with : 赶上 …and were going through the contents of the bag…go through : 仔细检查,搜查 … so she ran straight at them.straight adv.笔直地,直接地He went straight to the manager’s office.at prep. 对着;朝…的方向Mary shouted at her boyfriend. “The strap needs mending,”…need doing = need to be doneThe strap needs to be mended.The vase needs cleaning.The vase needs to be cleaned. 知识扩展 动名词动名词作主语,宾语 动名词作表语His hobby is playing football.Playing football is his hobby. 动名词作定语The reading room is large and bright.There is a swimming pool in the school. need, want, require 后跟动名词和不定式的区别当need,want,require表示”需求”的时候,后加动名词主动式等于加不定式的被动式.The room needs cleaning.The room needs to be cleaned. be worth + 动名词, “值得做…” 表示被动的意义The museum is worth visiting. 这个博物馆值得参观.be worthy of + n.The museum is worthy of a visit.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 43 Over the South Pole 飞越南极]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-43-Over-the-South-Pole-%E9%A3%9E%E8%B6%8A%E5%8D%97%E6%9E%81%2F</url>
      <content type="text"><![CDATA[单词讲解 pole n.地球的(极)the South Pole 南极the North Pole 北极fishing pole 鱼竿 flight n.飞行 航班Flight CA112 is boarding.Please get ready. explorer n.探险家,探测器Internet Explorer == IEexplore v.探测,探险,探索exploration n.考察,探险adventure n.冒险 lie v.躺 / 处于,位于 lie lay lain serious adj.严重的,严肃的The problem of air pollution is serious.I am serious. I’m not joking. point n.地点at one pointv.点出,指出They pointed out the problem.point at / to… endless adj.无尽的endless white plainsEndless Love lesscareless adj.worthless adj. 语法讲解 In 1929,three years after his flight over the North Pole,the American explorer,R.E.Byrd,sucessfully flew over the South Pole for the first time. 同位语fly over… Though, at first, Byrd and his men were able to take a great many photographs of the mountains …, they soon ran into serious trouble. at firstbe able to do sth 能够做某事a great many…take photographs of…run into trouble 陷入困境之中 区别 can / be able to : 相同点 : 都表示能力,”能够”(can / could; be able to 时态更灵活) that lay below 定语从句 At one point, it seemed certain that their plane would crash.seem + adj.it?that their plane would crash 主语从句That their plane would crash seemed certain. 主语从句 :含义 :位置 :It seemed certain that their plane would crash.That their plane would crash seemed certain.写法 :同宾语从句复习宾语从句 :I know that you are right.I know what she will say.I know whether he is happy. 你不能跟我们一块去真是个遗憾.That you can’t go with us is a pity.It is a pity that you can’t go with us. 他们是否将会准时到达这不确定.Whether they will arrive here on time is uncertain. It could only get over the mountains if it rose to 10,000 feet.rise rose risen 上升 Byrd at once ordered his men to throw out … food sacks order.keep the orderMay I take your order,please? The plane was then able to rise and it cleared the mountains by 400 feet.by : 想差 Byrd now knew that he would be able to reach the South Pole which was 300 miles away, for there were no more mountains in sight. The aircraft was able to fly over the endless white plains without difficulty. 知识扩展seem v.似乎,好像seem + adj. / seem to be adj.He seemed nervous.It seemed certain.You seem happy.seem to do sth.You seemed to get lost. 这则消息似乎比我们原来预想的传播的更快.The news seemed to spread faster / more quickly than we had expected.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 42 Not very musical 并非很懂音乐]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-42-Not-very-musical-%E5%B9%B6%E9%9D%9E%E5%BE%88%E6%87%82%E9%9F%B3%E4%B9%90%2F</url>
      <content type="text"><![CDATA[单词讲解 musical adj.精通音乐的music + -almusical filmmusical instrumentKelly is very musical market n.市场,集市market informationmarket researchoverseas market snake charmer 玩蛇者 charming adj.迷人的,诱人的a charming lady pipe n.(吹奏的)管乐器My grandfather smokes a pipe. tune n.曲调The piano is out of tune. glimpse n.一瞥She caught a glimpse of herself in the mirror.v.瞥见Nick glimpsed someone standing there. movement n.动作move + -mentexcite(v.) –excitement(n.) continue v.继续He continued his work day after day.continue doing 一直做(同一件事情)If you continue talking like that, I will leave.continue to do 继续做某一件事情After having some tea, Fred continued to read newspaper. dance v.跳舞The little girl danced to the tune.(随着曲子跳舞)They danced a tango. obviously adv.显然obvious adj.明显的,显而易见的The mistake is abvious.It’s obvious that Bob is wrong. difference n.差别the differences between men and women.Tom’s decision makes no difference to my plan.(没有影响,没有差别)The invention has made a great difference to the world. Indian adj.印度的 语法讲解 As we had had a long walk…当我们走过长长的路have a + 动作名词have a walkhave a resthave a lookhave a smell类似的动作名词 : dance,flght,ride,sleep,swim,wash … We stopped at a square…stop at : 在…停留,逗留The train will stop at a small town.The palne has to stop at the city airport to fuel up. after a time 过了一会after a whileAfter a time, Sally felt tired and stopped her work. … at the other side of square…at the other side of : 在…的另一边Mike saw a friend at the other side of the road. … so we went to have a look at him.have a look at 看一看…Let me have a look at that plane model. … he picked up a long pipe…pick upJack picked up a coin from the floor.(拾起)Sam picked up a little Italian when he was traelling in Italy.(学会) … whick was covered with coins…cover with 用…覆盖cover the box with a piece of paper.The ground is covered with leaves. When he began to play a tune,…play a tune 演奏一曲play a tune on tha piano … we had our first glimpse of the snake.have a glimpse of 看见catch a glimpse ofget a glimpse of It rose out of the basket…rise rose risenThe sun rises from the east(东方). … tell the difference between Indian music and jazz!tell v.辨别,分辨(常与can,could,be able to连用) I can’t tell her from her twin sister.tell the difference between A and BVicky can’t tell difference between bee(蜂蜜) and wasp(黄蜂).]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 41 Do you call that a hat? 你把那个叫帽子吗?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-41-Do-you-call-that-a-hat-%E4%BD%A0%E6%8A%8A%E9%82%A3%E4%B8%AA%E5%8F%AB%E5%B8%BD%E5%AD%90%E5%90%97%2F</url>
      <content type="text"><![CDATA[单词讲解 rude adj.无理的rudely adv.无理地A rude man was shouting redely. mirror n.镜子look at oneself in the mirror. remark v.评说 n.评论 remind v.提醒remind sb.of sth.remind sb.to do sth.reminder n.提醒,提示物 语法讲解need 作实义动词need sth.need to do / need sb. to doneed doingHe needs some time.He needs to have a rest.He needs friends to heip him.His bag needs mending. 做情态动词need toneed have doneNeed I finish it now? 否定形式 : don’t need “You needn’t be so rude…”,my wife answered as she looked at herself in the mirror. I sat down on one of those modern chairs with holes in it …a piece of paper with her name and address on ita wallet with 200 dollars in ita bus with 50 people on it We had been in the… shop for half an hour and my wife was still in front of the mirror.she is sitting in the front of the bus. “We mustn’t buy things we don’t need,” I remarked suddenly.things we don’t need 定语从句need 实义动词don’t needneed + things I regretted saying it almost at once.regret regretted regrettedregret sth.regret doing sth. 后悔做某事 “You needn’t have said that”, my wife answered.need have done 本来需要做某事,但实际上没有做(虚拟)needn’t have done 本来不需要做某事,但现在做了 “I needn’t remind you of that… tie you bought yesterday.’remind sb of .sththat … tie you bought yesterday 定语从句 “You needn’t have said that,”my wife answered.needn’t to (真实的) “A man can never have too many ties.”My wife was wearing a hat that looked like a lighthouse.定语从句She lookes like her father. 知识扩展 实义动词need sth.need to do / need sb. to doneed doing 静态动词need do(常用于否定疑问)need have done]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 40 Food and talk 进餐与交谈]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-40-Food-and-talk-%E8%BF%9B%E9%A4%90%E4%B8%8E%E4%BA%A4%E8%B0%88%2F</url>
      <content type="text"><![CDATA[单词讲解 hostess n.女主人hostHe is the host for a TV talk show.prince(王子) princess(公主) unsmiling adj.不笑的,严肃的happy - unhappy tight adj.紧身的tight jeansThis shirts is tight under the arms.a tight game 一场难分胜负的比赛 fix v.凝视fix one’s eyes onHe stood there and fixed his eyes on the painting.His eyes were fixed on the painting. globe n.地球travel all around the globeglobal adj.全球的,全世界的global warming despair n.绝望They gave up the struggle in despair.v.绝望,放弃希望despair ofHis parents have despaired of him. 语法讲解 … sit next to Mrs.Rumbold.next to == besideHe put his suitcase next to the sofa.The store is next to a Chinese restaurant. … a large,unsming lady in a tight black dress.a large lady == a fat lady.in 穿戴(衣物)the woman in redThe girl is in high-heeled shoes. She did not even look up…Kyle looked up and saw me.I have to look up the word in the dictionary. …when I took my seat beside her.take a seat 坐下take one’s seat (在指定的位置)坐下He went into the theater and took his seat. Her eyes were fixed on her plate…fix one’s eyes on …she was busy eating.be busy(in)doingJack is busy cleaning his dorm. be busy with sthJohn is busy with his essay. … try to make conversation.make conversation 闲谈,聊天At a party, I have to think of things to say,so it’s very hard to make conversation. A new play is coming to…Helen is leaving tomorrow. Will you be seeing…will be doing 将来进行时表示委婉的语气How will you pay for this?How will you be paying for this? How long will you stay? Will you be spending your holodays abroad…spend one’s holodays abroad In despair, I asked her…in despair 在绝望中George tried everything to help his friend in despair. If you ate more and talked less,we would both enjoy… 虚拟的时间 if从句 主句 现在 were/did would(should,could,might)do if you game me more time, I would do it better.If I were you,I should seize the chance.If Ted were the boss,he would make some changes. 知识扩展虚拟语气 非真实语气 从句 主句 与现在的事实相反的假设 If+主语+动词的过去式(be动词用were) 主语+should/would/could/might 动词原形 If kevin should come here tomorrow,the boss would meet him in person.If I were to write the novel,I could write it in a different way.If I were the president of a university I should establish a compulsory course in “How to use Your Eyes”.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 39 Am I all right 我是否痊愈?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-39-Am-I-all-right-%E6%88%91%E6%98%AF%E5%90%A6%E7%97%8A%E6%84%88%2F</url>
      <content type="text"><![CDATA[单词讲解 operation n.手术have an operaationn.操作,运转,经营business operationn.行动rescue operaion successful adj.成功的successfully adv.success n.succeed v. alone adj.独自的 advlonely adj.偏僻的,孤单寂寞的The old lady lived alone,so she felt lonely.Leave me alone! 语法讲解他说 : “我是笨蛋.” 直接引语 变 间接引语他说我是笨蛋. When will Mr.Gilbert be allowed to go home?He than asked when Mr.Gilbert will be allowed to go home. “Was my operation successful?”He asked his doctor to tell him whether my operaion was successful. … he asked his doctor to tell him whether his operation had been successful…whether : 其中,可能 知识扩展直接引语变间接引语 陈述句变宾语从句You are right?I know (that) you are right. 特殊疑问句变宾语从句?What will she say?I know what she waill say. 一般疑问句变宾语从句Is he happy?I know whether/if he is happy. 我承诺我会帮助你.I promise that I will help you. 你从来没告诉过我,你对我的电脑做了什么.You never told me what you had done to my computer. 我想知道什么时候我们将会出发.I wonder when we will set out. 他们不知道他们是否会按时完成工作.They don’t know whether they will finsh the work on time. 我想知道什么时候我们将会出发.I wonder when we will set out. My friends know where do I work.where I work I asked my sister what kind of movies does she like.she likes. I want to know does Peter have a laptop.whether peter has a laptop.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 38 Everything except the weather 唯独没有考虑到天气]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-38-Everything-except-the-weather-%E5%94%AF%E7%8B%AC%E6%B2%A1%E6%9C%89%E8%80%83%E8%99%91%E5%88%B0%E5%A4%A9%E6%B0%94%2F</url>
      <content type="text"><![CDATA[单词讲解 except prep.除了They are all here except Cathy.No one except me knew about the plan.Except for Bob, everyone has sent Vicky a present. complain v.抱怨complain to sb.about / of sth.We complained to the manager about the food.complain that…We complained to the manager that the food had gone bad. continually adv.不断地I explained to George continually.(repeatedly)The dog continually chased its tail for fun. bitterly adv.刺骨地bitter adj.苦的,严寒的Black coffee tastes bitter.bitter windIt was bitterly cold that day. sunshine n.阳光You’re my sunshine.sit out in the warm sunshine. 课文讲解 He had often dreamed of…dream of 梦想,幻想,向往The little girl dreamed of living in the fairyland. … settle down in the country.settle down : 定居,安顿Paul plans to settle down in a small town.Tony will settle down after he gets married. He had no sooner returned than he…no sooner… than… 一…就 (as soon as)I had no sooner opened the door than the phone rang.倒装 : No sooner + 助动词 + 主语 + 动词No sooner had he returned that he bought a house and went to live here.No sooner had I opened the door than the phone rang. … for even though it was still summer,…for conj. 表示原因,作为上文的补充说明,不可用于句首Tom ate three hamburgers,for he was so hungry.even though : 即使,虽然 引导让步状语从句Even though they lost the game, they wouldn’t lose heart. … Harrison got a shock.get a shock 感到惊讶,震惊 He acted as if…as if : 好像,仿佛 引导方式状语从句Lee talked about Paris as if he had been there before.He behaved as if he had owned this house. In the end,it was more than…in the end == at last, finallymore than : 超出了…的范围I love you more than I can say. 我爱你已经超出了我能表达. He had hardly had time to settle down when…hardly … when… 还没来得及,…就…;刚…就…; 知识扩展 as if / as though 仿佛,好像在look,seem等系动词后引导表语从句It seems as if it’s going to rain.引导方式状语从句Nick behaved as if he hadn’t grown up.as if 从句用虚拟语气,表示句子说述的不是真实或很少有可能的发生,存在的事情. 从句表示与现在事实相反,谓语动词用一般过去时.Sam talks as if he were a millionaire. 从句表示与过去事实相反,谓语动词用”had + 过去分词”.Nick sat there as if he had fallen asleep. 从句表示与将来事实相反,谓语动词用”would / could / might + 动词原形”.It looks as if it might rain. as if 从句所述是真实或是有可能发生或存在的情况,则用陈述语气.It looks as if it’s going to rain. as if从句是”主语 + 系动词”结构,可省略主语和系动词,这样形成”as if + 名词/不定式/形容词(短语)/分词”.Bob acts as if (he were) a fool.Vicky went into the room as if(she were) in search of something.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 37 The Olympic Games 奥林匹克运动会]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-37-The-Olympic-Games-%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E8%BF%90%E5%8A%A8%E4%BC%9A%2F</url>
      <content type="text"><![CDATA[单词讲解 Olympic adj.奥林匹克the Olympic Games immense adj.巨大的fantastic adj.巨大的fantasy n.幻想big / large / huge / vast / enormous / tremendous / colossal / gigantic / titanic 语法讲解 The Olympic Games will be held … in four years’ time. As a great many people will be visiting … the government will be building…will be done(将来时的被动语态) vs. will be doing They will also be building new roads… Workers will have completed the new roads by the end of this year.by + 时间将来完成时形式 : will / shall + have done … are looking forward to the Olympic Games because they have never been held before… 知识扩展 will be done : 一般将来时的被动 will be doing : 将来进行时 will have done : 将来完成时]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 36 Across the channel 横渡海峡]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-36-Across-the-channel-%E6%A8%AA%E6%B8%A1%E6%B5%B7%E5%B3%A1%2F</url>
      <content type="text"><![CDATA[单词讲解 record n.记录an Olympic recordbreak the latest recordhold the world record strong adj.强壮的strong muscles 强健的肌肉strong tea 浓茶a strong believer 坚定的信徒 swimmer n.游泳运动员swim v.run – runner succeed v.成功They tried hard and succeeded finally.Bob is sure to succeed in business.Alan succeeded in solving(解决) the problem. train v.训练Lee is trained as an engineer.train a horse for a race.Willian trained his dog to fetch the keys. anxiously adv.焦急地anxious adj.担忧的,忧虑的The mom is anxious about the baby’s health.Lily is anxious for her safety.Mike is anxious to meet his girlfriend.He is waiting for the result anxiously. intend v.打算We intend to complain to the manager.They intend to go. / They intend going.Mr.Williams intends that his son shall take over the business. solid adj.固体的,硬的solid good 语法讲解 She is going to set out from…set out from : 从…出发Paul will set out later on his journey to London. … she hopes to set up a new world record.set up : 创造(记录)set up a club : 创立一个俱乐部Tazieff was able to set up his camp … 结账缝 … she is sure to succed.be sure of : 确信Daisy is sure of herself.be sure that…I’m sure that Jack is honest. Tomorrow he will be watching her anxiously…will / shall be doing : 一般将来进行事The manager will be attending a meeting tomorrow moring.When Dave comes to my dorm tomorrow,I will be working on my essay. Debbie intends to… every two hours.intend to do sthSally intends to keep a pet.every two hours : 每两个小时every three weeksevery five days Among them will be Debbie’s mother,who…介词短语 + 谓语(vi.) + 主语On top of the mountain stands an old temple.Around the corner(驾车) came a sports car.当先行词是地名,人名,世上独一无二的事物或家庭唯一成员时,通常只能用非限定性定于从句. 比较 :Mr. Johnson has a son who is a doctor.MrJohnson先生有一个当医生的儿子.(不止一个儿子)Mr. Johnson has a son,who is a doctor.约翰逊先生有一个儿子,他是个医生.(只有一个儿子) 知识扩展 倒装句so + 助动词/be动词/情态动词 + 主语某人(物)也是这样neither + 助动词/be动词/情态动词 + 主语某人(物)也不/没Franks is generous.so is George.I watched that movie yesterday.So did Zac.Frank isn’t generous. Neither is George.I didn’t watch that movie yesterday.Neither did Zac. There be … “存在” 主语在be动词后There is a dog in the yard.There are five apples on the table. 表示方位或方式的副词或介词短语,如:here,there,up,down,away,back,off,out,on,in front of the building等,位于句首,且主语是名词时.In front of the building stands a tower(塔).Away went the old lady.In came the manager.Here comes the bus. 注意 :主语是代词时,不到装.Here you are.In he came. such 置于句首时.Such is human nature.Such are the facts(事实). There was a sudden gust of wind and his hat went away.There was a sudden gust of wind and awany went his hat. The door burst open and the crowd rushed in.The door burst open and in rushed the crowd.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 35 Stop thief! 抓贼!]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-35-Stop-thief-%E6%8A%93%E8%B4%BC%2F</url>
      <content type="text"><![CDATA[单词讲解 while n.一段时间a short while agofor a whileconj. 当…的时候some of the detectives were waiting inside the main building while others were waiting on the airfield. regret v.后悔regret regretted regrettedregret sth. straight adv.径直的drive straight at…run straight at… fright n.害怕get a frightfrighten v. battered adj.撞坏的batter v. 语法讲解 Roy … used to drive a taxi. He is finding his… work far more exciting.far more exciting : 兴奋得多 When he was driving … recently, he saw two thieves rush out of a shop and run towards a waiting car.see sb. do sth.see sb. doing sth. The one with the money got such a fright that he dropped the bag.such … that… : 因果关系,结果状语从句It is an interesting story. / I want to share it with you.It is such an interesting story that I want to share it.so … taht…The story is interesting. / I want to share it with you.The story is so interesting that I want to share it… As the thieves were trying… ,Roy drove his bus into the back of it. While the battered car was moving away… 知识扩展 He is finding his… work far more exciting.Letters will cost a little more…I am even less lucky. 修饰比较级的词 他的哥哥甚至比他的爸爸高.His brother is even taller than his father. 那个电影比我想要的更有趣很多.The film is much more interesting than I thought. 我认为你可以花更多一点的钱买书.I think you can spend money buying books. so / such … that…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 34 Quick work 破案神速]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-34-Quick-work-%E7%A0%B4%E6%A1%88%E7%A5%9E%E9%80%9F%2F</url>
      <content type="text"><![CDATA[单词讲解 station n.警察局a police stationa fire station 消防站a train stationa bus station must adv.相当,非常It’s a most funny story.It’s most kind(仁慈的) of you to meet me at the airport. 语法讲解 Dan Robinson has been worried…(现在完成时)be worried about 对…担心Mr. Johnson is worried about his health. … the local police.local adj.当地的,本地的local newslocal calls 本地电话,市话local dish 地方菜 … he was asked to call at the station.call at 拜访(某场所)call at a neighbor;s housecall at Mr.Johnson’s office Dan wondered why he was wanted…wonder + 疑问词引导的从句”想知道…”I wondered why Helen was so upset(心烦意乱).Tim wondered where he would spend his holidays.want v.通缉,需要(某人);想要(和某人见面,交谈)He is a wanted man.You are wanted on the phone.You are wanted in the manager’s office. …he is not worried anymore.not … anymore / not any longer / no longer : 不再…He will not work for that company any longer. … he was told by a smiling policeman…a running boya flying bird Five days ago,…The policeman told him that five days ago the bicyle was picked up(拿起) in a small village… It is now being sent …be being doneIt is being repaired by a friend of my father’s.The shoe is being mended by Paul. Dan was most surprised…most — veryDan was very surprised…It’s the most beautiful garden in our town. He was amused too,…amused adj.被逗乐的,开心的Ryan was amused at the joke. … when Dan was a boy of fifteen!Daisy is a girl of sixteen. 知识扩展被动语态 带双宾语的谓语动词变为被动语态Fred gave me a present.I was given a present by Fred.(间接宾语改为主语)A present was given to me by Fred.(直接宾语改为主语) 动词短语变为被动语态,不可扔掉构成动词短语的介词或副词.The bobysitter took good care of the kid.The kid was taken good care of by the bobysitter(临时照顾幼儿者).(of不能省略) 带复合宾语的动词变为被动语态,只能把宾语变为被动句的主语,宾语补足语保留在原处,变为主语补足语.I saw Lily dancing in the gym.Lily was seen dancing in the gym. 感官动词,如 : see,hear,watch,feel,notice等,以及使役动词,如 : let,make,have等在主动句后跟省略to的不定式,变为被动句时要加上不定式符号to.The boss made Jim work ten hours a day.Jim was made to work ten hours a day by the boss. 含有情态动词的被动语态.The task must be completed today.谓语结构 : 情态动词 + be + 过去分词 “get + 过去分词”表示被动,多用于口语.Mary will get married next month.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 33 Out of the darkness 冲出黑暗]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-33-Out-of-the-darkness-%E5%86%B2%E5%87%BA%E9%BB%91%E6%9A%97%2F</url>
      <content type="text"><![CDATA[单词讲解 darkness n.黑暗的dark adj. nesshappinessnervousnesscarelessness explain v.解释,叙述explanation n. storm n.暴风雨rain stormsnow stormsand stormbrain storm towards prep.向,朝;接近towards eveningwalk towards the doorThe ball flew towards me. ahead adv.在前面go ahead 走在前面 语法讲解 Nearly a week passed before the girl… explain what had happened to her.pass v. A week passedpast prep. It is eleven past ten. … she set out from the coast in a small boat and was caught in a storm.set out / off : 出发be caught in… : 被抓住(被困住)I was caught in the traffic jam yesterday. Towards evening, the boat struck … and the girl jumped into the sea. Then she swam(游泳) to the shore after spending the… night in the water.strike struck struckswim swam swum She knew she was near… because the light was high up on the cliff.know knew known On arriving at the shore,the girl struggled…struggled : 奋斗 … the girl struggled up the cliff towards the light she had seen.the light (that/which) she had seen That was all she remembered(纪念).all(that) she remembered 表示地点的介词(prep)set out from the coastswam to the shore(岸).towards the light she had seenarriving at the shore.on the cliff(悬崖).in a small boat / in a storm / in hospital 知识扩展arriving at the shoreon the cliffin a small boat / in a storm / in hospital]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 32 Shopping made easy 购物变得很方便]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-32-Shopping-made-easy-%E8%B4%AD%E7%89%A9%E5%8F%98%E5%BE%97%E5%BE%88%E6%96%B9%E4%BE%BF%2F</url>
      <content type="text"><![CDATA[单词讲解 once adv.曾经,以前He cleans his room once a week.(一次)I met the president once.They left the building at once.(immediately)Read the words once more. (once more)Once in a while I eat out. (occasionally) temptation n.诱惑tempt v.引诱,诱惑I’m always tempted by the delicious - looking food.The serpent tempted Eve to eat the forbidden fruit.I can’t resist the temptation to live in Paris.The boy is a strong temptation to the kid. article n.物品,东西an article on business (文章)an article of clothing 一件衣服article of clothing 衣服,衣物 wrap v.包裹wrap up the parcelwrap the present in paperSam wrapped himself up in a coat.unwrap v.打开,解开unwrap the Chirstmas present simply adv.仅仅It’s simply a matter of time.He’s simply a child. arrest v.逮捕arrest a thiefThat young man was arrested for theft. 语法讲解 People are not so honest as…as… as…not as / so…so…Tony is not as patient as he used to be.Nick plays piano as well as his sister(does).Vicky has read as many novels as Ryan has. The temptation to steal…I can’t resist the temptation to live in Paris.The boy is a strong temptation to the kid. … is greater than ever before.The temptation to steal is greater now than it was ever before. … a well-dressed woman…a well-educated young mana well-known actorThe tunnel would be well-ventilated… …on Monday mornings. … there were fewer people in the shop than usual…than usual 比平常He was busier than usual.Jane left earlier than usual. … she chose one of…choose / chose / chosen … handed it to an assistant(助理)…hand to sb.I handed the keys to him.hand in 提交hand in the papers.hand out 分发hand out the presents to everyone. … as quickly as possible.as … as possible 尽可能Read the passage as carefully as possible.Zan tries to be as patient as possible when he answers. … once a week.once a month / yeartwice a day 知识扩展平级比较 as + adj./adv. + asThe movie is as boring as you think. not as / so … asThe movie is not so boring as you think. as + adj./adv. + a(n) + 可数名词单数 + asArchitecture is as much an art as it is a science.建筑学是一门科学,同时也是一门艺术. Justin is as outstanding an actor as he is a singer.Justin 当演员和当歌手都一样的出色. as + 形容词 + as + 数量词 = 数量词 + 形容词The road is as long as 100 meters. = The road is 100 meters long.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 31 Success story 成功者的故事]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-31-Success-story-%E6%88%90%E5%8A%9F%E8%80%85%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[单词讲解 success n.成功successful adj.successfully adv.succeed v. bicycle n.自行车tricycle n.三轮车recyclable adj.可循环利用的 save v.存储save moneysave money for the rainy dayssave timesave the gamesavings n.存款 employ v.雇佣employment n.就业,雇佣unemployment n.失业unemployment rate 失业率 语法讲解 Yesterday afternoon Frank …was telling me about his experiences… Before he retired,Frank was the head of a… business company…head n.头 / 头儿 … but as a boy he used to work in a small shop. 过去常常I used to drink a lot of coffee.We used to live in the countryside.People used to be happy when they were young. It was his job to repair bicycles… = To repair bicycles was his job.修理自行车是他的工作,it是形式主语,非真正主语.It is very important to study English.It is necessary to think about the future. He saved money … and in 1958 he bought a small workshop of his own.his own workshophis own workshopa small workshop of his own In his twenties Frank(坦白的) used to make spare parts… He was still smiling when the door opened… She wanted him to repair their grand 3. 知识扩展used to do sth. : 过去往往做某事Tony usually worked late. = Tony used to work late.I was always late for school. = I used to be late for school.People were very honest in the old days. = People used to be very honest in the old days. It was his job to repair bicycles…it 形式主语to repair bicycles 真正的主语意义 : 避免头重脚轻It is difficult for us to travel alone in foreign cities.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 30 Football or polo? 足球还是水球?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-30-Football-or-polo-%E8%B6%B3%E7%90%83%E8%BF%98%E6%98%AF%E6%B0%B4%E7%90%83%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 polo n.水球water polo cut v.穿过(cut,cut)Grandpa usually cuts across the park on his way home.The road cuts through the forest(森林). row v.划(船)We rowed the boat across the river. kick v.踢The boy kicked the ball into the lake. towards prep.朝,向(toward)walk towards the entrancelook out towards the seaSally turned her back towards Kim. nearly adv.几乎It’s nearly midnight.They nearly won the game.Bob is nearly late for the meeting. sight n.眼界,视域The plane is still in sight(在视域之内).The mountain is out of sight.They fell in love at first sight.I laughed at the sight of(一看到) the clown. 2. 语法讲解 … that cuts across the park near my home.cut across : 横穿,走捷径,抄近道I can get there earlier if I cut across the field. I like sitting…Dave likes drinking coffee.like doing (经常性的,习惯性的)Dave likes to drink some tea now.like to do (具体的某一次) … on fine afternoons.in the morningon s sunny morningon a rainy nighton sunny mornings … sat on the river bank(河岸) as usual.as usual : 照常,像往常一样On Sundays Nick gets up early as usual. … a passing boat.a passing traina passing plane … called out to the man…call out : 大声叫嚷Someone is calling out for help.Ryan called out his firend’s name in the street. The bll struck him so hard that he nearly fell…strike / struck / struckfall / fell / fallenso + adj./adv. + that … 如此…以至于…The movie is so great that I want to watch it again.Alan was so tired that he fell asleep instantly(立即).Fred moved so quietly that no one noticed him.There is no star in sight.The car is soon out of sight. 3. 知识扩展定冠词的用法 在姓氏复数前表示一家人.The Johnsons are having a picnic. 用在年代,朝代名词以及逢十数词(表某个年代)前.the Ming Dynastyin the 1980’s 用在表度量单位的名词前表示”每一”We rent a car by the hour. 我们按每个小时租了一辆车. 句型 “动词 + sb. + 介词 + the + 身体的某一部分”中的the不能用人称或物主代词替代.hit sb. in the face. 在一些固定结构中要用the.at the same time,in the end,by the way… 在名词的词组中,定冠词一般放在最前面,但名词词组中如果有exactly, just, all, both, double, twice, half, of, 等修饰时,定冠词要放在这些词的后面.exactly(确切地) the same song.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 29 Taxi 出租汽车]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-29-Taxi-%E5%87%BA%E7%A7%9F%E6%B1%BD%E8%BD%A6%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 taxi n.出租汽车cab flat n.公寓房apartment lonely adj.偏僻的,感到孤单寂寞的 block n.一座大楼a block of flats / apartmentsa flat blockan office blocka tower blocktraffic block / jam 2. 语法讲解 Captain Ben Fawcett has bought an unusual taxi and has begun a new service.现在完成时形式 : have/has + done用法 : 现在的之前 The “Taxi” is a small Swiss aeroplane called a “Pilatus…”.过去分词作后置定语,修饰名词a used carwasted timea ploughed fielda deserted car parka woman called “Dragon Lady” The most surprising thing …,however,is that it can land anywhere : on snow,water,or even… The most surprising thing… is that it can land anywhere.表语从句 Captain Fawcett’s first passenger was a doctor who flew from Birmingham to a lonely village…定语从句 Since then,Captain Fawcett has flown passengers to many… places.He has lived in Beijing since 1993 / for 20 years.He has lived in Beijing since he has born. Once he landed on… a block of flats and on another occasion, he landed in a deserted car park.refuese a request 同位语 : … but … because 3. 知识扩展现在完成时形式 : have/has + done用法 : 现在的之前Since then, Captain Fawcett has flown passengers to many … places. 现在完成时 + since + 过去的时间 / since + 过去的动作(一般过去时的句子) This / It is is the first time(次数) + that 从句 (现在完成时)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 28 No parking! 不准停车]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-28-No-parking-%E4%B8%8D%E5%87%86%E5%81%9C%E8%BD%A6%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 rare adj.罕见的a rare birdPandas are rare today.It’s rare to see such a thing.It’s rare for him to go to the movies. ancient adj.古代的,古老的ancient historyancient civilizationancient poem myth n.神话故事ancient Greek myths trouble n.麻烦He has trouble with his teeth.The plan ran into trouble.Peter got into trouble when he climbed the mountain.His new car gave him a lot of trouble.If you can’t get there on time, you will be in trouble. effect n.结果,效果The action movie has quite an effect on the little boy.Does the medicine have any effect?The new regulation came into effect last month.The law is still in effect. 语法讲解 … is one of those rare people who believes in…one of + 名词/代词(of后的名词需用复数)One of your classmates is going to meet you at the airport.believe in 信仰;信赖believe in religionI don’t believe in that young man. … but ever since he moved in,…ever since 从哪以后一直 (语气比since强)Ever since he met Helen,he has changed completely(完整地). … he has had trouble with cars and their owners.have trouble with … 与…有麻烦Fred has trouble with his new neighbor. Because of this,…because 连词 因为 (引导原因状语从句)because of 介词短语 因为(后接名词,代词) … he has not been able to get…can / be able to 在完成时中一般用be able toThey have never been able to get together since graduation. Jasper has put up…put up 张贴,挂起put up a poster on the wall … but these have not had any effect.hve an effect on 对…什么有影响What parents say or do will have an effect on children. It is one of the ugliest(丑陋的) faces…He is the tallest man I have ever met. 他曾经是我见过最高的人.It’s one of the most exciting movies I have ever seen. Jasper hopes that…hope for sth. 希望 / 期待某物He is hoping for a letter.hope to do sth. 希望做某事Sam hopes to win the game.hope that… 希望…Sam hopes that he can win the game.wish sb. to do sthWhat do you wish me to do?I wish you to go at once. … turn cars and their owners to stone.turn … to / into … 把…变成…The witch turned the prince into a frog. 3. 知识扩展定语从句I have a friend who runs a restaurant.先行词 + 关系词 + 定语从句 关系词 作用 先行词 that, who, whom(只作宾语) 主语,宾语,表语 人 George is a college student who studies history. 主语In the office sat a stranger whom I had never met before. 宾语Frank is no longer a little boy that he used to be. 表语 关系词 作用 先行词 that, which 主语,宾语,表语 物 Paul bought a car that was made in France. 主语That’s the gift which I’m going to send to my parents. 宾语Our hometown is not the city that it was. 表语 关系词 作用 先行词 whose 定语 人或物 The lady whose hair is blond is a famous singer. 定语Please pass me the book whose cover is blue. 定语 关系代词的用法 : 在下列情况中,先行词指物时,只能用that引导定语从句,而不能用which引导. 先行词是all,little,much,none,everything,anything,nothing等代词.Vicky told us all that had happened. 先行词前有the very(正好的),the only,the last等修饰.This is the only ticket that we can get. 先行词前有序数词或形容词最高级修饰,先行词本身是序数词或形容词最高级.It’s the most exciting movie that I have ever seen.This is the best that has been used to solve the problem. 先行词前有only,all,any,no,few,little等修饰.That man bought all the chocolate that was in the shop. 主句是以疑问句which开头的特殊疑问句.Which is the city that you want to visit? 先行词既有人又有物.The flowers and the kids that are in the photo look so lovely. 有两个定语从句的时候,其中一个关系代词宜用which,另一个宜用that.It’s a famous cafe, which sells coffee that is prepared with great care. 先行词在主句中作表语,关系代词在从句中也作表语.Our hometown is not the city that it used to be. 一般情况下that,which,whom在定语从句中作宾语时可以省略.It’s the novel(that) I’m reading now. 关系代词在定语从句中作主语时,不可省略,而且定语从句中的谓语动词在人称,数的方面应该与先行词保持一致. one of + 复数名词 + 关系代词 + 动词复数形式It is one of the worldwide famous cities that attract millions of visitors. the only one of + 复数名词 + 关系代词 + 动词单数形式Jack is the only one of the students who speaks French.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 27 A wet night 雨夜]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-27-A-wet-night-%E9%9B%A8%E5%A4%9C%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 tenk n.帐篷 field n.田地,田野 smell (smelled / smelt) v.闻起来The food smelled good.She smelled the meat to see if it was flesh. wonderful adj.极好的fabulous excellent fantastic terrific campfire n.营火go camping creep v.爬行creep / crept / creptsleep / slept / sleptkeep / kept / keptsweep / swept / swept sleeping bag 睡袋doing 表示功能,用途a swimming poola fishing boata packing boata waiting room comfortable adj.舒适的,安逸的 soundly adv.香甜的sleep soundly / deeply / wellbe fast asleep leap (leapt,leapt) v.跳跃,跳起 heavily adv.大量地rain heavily / smoke heavily form v.形成 n.形式,表格 wind (wound,wound) v.蜿蜒wind one’s wayThe stream wound its way across the field.wind round sth.A snake wound round the wires. right adv.正好 2. 语法讲解 Late in the afternoon, the boys put up their tent …late in the afternoonearly in the morningin the middle of a field / the nightin the centre of Australia … they told stories and sang songs by the campfire.by the campfire(在营火边).I like sitting by the Wayle on fine afternoons. But some time later it began to rain.some time 一段时间sometimebegin / began / begunsing / sang / sungring / rang / rangdrink / drank / drunkswim / swam / swum … two boys woke up and began shouting.wake / woke / wokenbeging doing sth. = begin to do sth. 3. 知识扩展一般过去时形式 : v.过去式(did)用法 : They were all hungry and the food smelled good. We had a good time at the party yesterday.We sang songs and drank beer. Last night around midnight, I slept soundly.Suddenly the telephone rang and it woke me up. Some years ago I was offered a writing assignment that would require three months of travel through Europe. It seemed impossible, and with considerable regret I sat down to write a letter begging off. So I accepted the assignment.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 26 The best art critics 最佳艺术评论家]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-26-The-best-art-critics-%E6%9C%80%E4%BD%B3%E8%89%BA%E6%9C%AF%E8%AF%84%E8%AE%BA%E5%AE%B6%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 art n.艺术art moviea work of artmodern art critic n.评论家music criticart critic paint v.画The little boy paints well.paint a picturepaint a landscape pretend v.假装Tom pretended illness.Tom pretended to be ill.Tom pretended that he was ill. pattern n.图案a checkered patternThe girl wears a dress with a pattern of flowers on it. curtain n.窗帘,幕布draw the curtaina shower curtain material n.材料building materialsThere is enough(足够的) material for a dress.collect(收集) material for an article(资料) appreciate v.鉴赏appreciate English poetryappriciate good wine.appriciate oil paintings. notice v.注意到I didn’t notice him coming in / come in.I noticed that he was a little upset. whether conj.(连词)是否weather n.天气Tell me wheter you garee with us or not.I wondered whether to go or to stay. hang v.悬挂 (hung,hung)hang the coat on the hook.hang the picture on the wall.hang the windows with curtains. critically adv.批评地We should examine our work critically. upside down 上下颠倒The painting was hung upside down. inside out 翻过来,里在外He was wearing the shirt inside out. 2. 语法讲解 … what a picture is “about”.This movie is about youth.They talked about the movie for a long time. … just pretty patterns. We like them in the same way that…in the same way that … 和 … 一样Nick behaves in the same way that his father does.Jill tried to cook the fish in the same way that her mother did. … better than anyone else.else adj.其他的,别的 (经常与不定代词,疑问代词连用)Do you have anything else to say? 你还有别的要说的吗?It’s someone else’s key. It’s not mine.What else do you want to say? … whether my pictures are good or not.whether … or not “是否”,表示选择Tell me whether I should accept the job or not.Tell me whether I should accept the job.Tell me whether or not I should accept the job. for a moment 一会儿,片刻I stood there for a moment. 3. 知识扩展宾语从句的连接词 宾语从句是陈述句时,引导词用that.I know (that) Helen went to New York yesterday. 在以下的情况中,引导词是that不可省略 : 宾语从句的主语是thatLily told us that that was her favorite toy. 宾语从句中含有主从复合句John said that if he was free, he would come and visit us. 两个或多个宾语从句由并列连词链接时,除第一个从句中的that可以省略外,其余从句中的that都不能被省略.Nick said (that) he would not go to work next week and that he would have a holiday. 含疑问语气的句子构成宾语从句时,用whether或if连接,句尾的标点符号取决于主语.“Are you free?” Jim asked Bob.Jim asked Bob if / whether he was free. 宾语从句是特殊疑问句时,连接词就用原来的疑问词,但要用陈述句语序.“When are you free?” Jim asked Bob.Jim asked Bob when he was free.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 25 Do they speak English? 英国人讲的是英语吗?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-25-Do-they-speak-English-%E8%8B%B1%E5%9B%BD%E4%BA%BA%E8%AE%B2%E7%9A%84%E6%98%AF%E8%8B%B1%E8%AF%AD%E5%90%97%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 railway n.铁路railway station porter n.搬运工 several quantifier 几个several timesseveral people foreigner n.外国人foreign adj.外国的,外国人的a foreign language wonder v.感到奇怪feel surprised 2. 语法讲解 I arrived in London…arrive at the airportarrive on the sceneat last 最好终于 / in the end / finally / eventually I did not know the way to my hotel, so I asked a porter.句子的分类 : 简单句 / 并列句 / 复合句They walked into the room. They sat down.They walked into the room and they sat down.They walked into the room and sat down.She is very beautiful. She is very smart.She is not only very beautiful but she is very smart as well.She is not only very beautiful but very smart as well.He can not read. He cannot write.He can neither read nor write. I not only spoke English very carefully, but very clearly as well. I repeated my question … ,and … he understood. …, but he spoke neither slowly nor clearly. The he said … and I understood … The English understand … , but I don’t understand … 3. 知识扩展 并列句并列句的并列连词I washed my shirt, but it didn’t get clean.She was hungry and ate on the way home.Who did this? Did you do it, or did Bob do it?并列句的省略I am a student and I major(主修) in English.I am a student and major in English.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 24 It could be worse 不幸中之万幸]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-24-It-could-be-worse-%E4%B8%8D%E5%B9%B8%E4%B8%AD%E4%B9%8B%E4%B8%87%E5%B9%B8%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 manager n.经理shop manager upset adj.不安的He was upset by the noise(噪音).Mary was upset about her mother’s words(说话). sympathetic adj.表示同情的a sympathetic smileI was sympathetic to / towards him when he was sick. complain v.抱怨Jane complained to the police about the noise.He complained of the bad weather.Tony complained that nobody had helped him. wicked adj.很坏的,邪恶的a wicked look 不怀好意的事情It’s wicked of him to say such things. contain v.包含,内装The big box contains Mike’s toys.The book contains the information you need. honesty n.诚实in all honesty 坦白说In all honesty, I can’t agree with you. 2. 语法讲解 I entered…enter == go into I had just lost…lose - lost - lostJill lost her purse. … but he could do nothing.You have nothing to do with it.Is there anything I can do for you? “Everyone’s losing money these days,”…现在进行时表示动作的频繁,现在进行时与频度副词always,constantly等连用,表示夸奖 / 不满等感情He is always saying such nice words. 他总是说好话.She is always coming late.Nick is always doing well. He started to complain about…start to do / start doingIt started to snow / started snowing … was interrupted by a knock at the door.interrupt v.打断The ringing phone interrupted his speech.Someone is knocking at the door. “Well,” I said to the manager,…well 感叹词,表示惊讶 / 无可奈何等感情Well, here we are finally! 3. 知识扩展 宾语从句 主句和从句的时态主句是现在的某种时态(包括一般现在时 / 现在进行时 / 现在完成时),宾语从句的时态 可根据实际情况而定.I know that Helen went to New York yesterday.Tom has told us that he will go to New York tomorrow.主句是过去的某种时态(包括一般过去时,过去进行时),宾语从句一般要用过去的某种时态(包括一般过去时,过去进行时,过去将来时,过去完成时).Tom told us that he would go to New York next week.宾语从句表示的客观事实或真理,即是主句是过去时,从句也是用一般现在时.The teacher told the students that the moon goes around the earth. 宾语从句的语序宾语从句的语序要用陈述句语序.What is Cathy reading? Do you know? = Do you know what Cathy is reading?The teacher told us that the earth is round.I don’t know whom I should ask for help.Could you please tell me where the supermarket is]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 23 A new house 新居]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-23-A-new-house-%E6%96%B0%E5%B1%85%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 complete v.完成complete / finish the workA few cars completed the race. adj. 完整的He told us a complete story. strange adj.奇怪的We heard a strange sound.The modern building looks strange to some people. stranger n.陌生人 district n.地区 2. 语法讲解 I had a letter … yesterday. She lives in… She said that she was going to England next year. If she comes, she will get… We are living now in a beautiful new house… Work… had begun before my sister left. The house was completed five months ago. … I told her that she could stay with us. The house has many… rooms and there is a … garden.There be 句型There be + n. / There is a girl.There be + n. + 介词短语There is a girl in the classroom.There was a book on the table. 3. 知识扩展 简单句 时态一般现在时 do/does一般过去时 did一般将来时 will / shall do am / is / are going to do现在进行时 am / is / are doing过去将来时 was / were doing将来进行时 will / shall be doing现在完成时 have / has done过去完成时 had done过去将来时 would do was / were going to 被动语态 be(被动的时间) + done(被动的动作) 情态动词must / may / can]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 22 A glass envelope 玻璃信封]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-22-A-glass-envelope-%E7%8E%BB%E7%92%83%E4%BF%A1%E5%B0%81%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 dream v.做梦,梦想(dreamed / dreamt)I dreamed a sweet dream.I dreamed about / of you last night.Kim dreamed of having a sports car.Kim dreamed that he had a sports car. age n.年龄at the age of eightShe doesn’t look her age at all.Lee is just my age.a man of middle ageI have waited for ages. channel n.海峡the English ChannelIt’s my favorite channel.(频道) throw v.扔,抛(threw,thrown)The boy threw the ball up and caught it again.He threw himself onto the sofa.Jim threw on his coat.Cathy threw him an angry look. 2. 语法讲解 … from a girl of her own age in Holland.Tony is a boy of my own age. 某人和某人年龄一样大. … We were travelling across the Channel…travel across the country She never thought of it again, …think of 想起,考虑He just thought of the movie I mentioned yesterday.think over 仔细思考I will think over your suggestion.think about 想,思考We are thinking about going to the seaside. Letters will cost a little more,…cost v.花费,价钱为(cost,cost)The meal cost us 50 dollars.How much does the shirt cost? 3. 知识扩展英文电子邮件常用句型 : Attached please find my resume.请在附件中查找我的个人简历. I add some comments to the document for your reference.我在文档中添加了一些备注,仅此参考. Look forward to your feedbacks and suggestions soon.期待您的反馈建议! We’d like to hold a meeting tomorrow about the project.我方建议明天的项目问题召开会议. For the next step of the plan, we are proposing…关于下一步计划的问题,我方提议…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 21 Mad or not? 是不是疯了]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-21-Mad-or-not-%E6%98%AF%E4%B8%8D%E6%98%AF%E7%96%AF%E4%BA%86%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 mad adj.发疯的I know I was wrong. Please don’t be mad at me.go mad : 自己发疯了drive sb. mad 受到某人发疯(外力影响)His behavior really drives me mad. 他的行为使我发疯了.dirve / drove / driven reason n.原因for some reasons //因为一些原因for some reason //因为某一种原因for one reason or another //种种原因reasonable adj.合理的unreasonable adj.不合理的 sum n.量a large sum of moneyto sum up 总而言之 determined adj.坚定的,下定决心的be determined to do sth..He is determined to go abroad for further education.We are determined to hold on to the last. 我们坚持到最后 2. 语法讲解 … passing planes can be heard night and day. 被动语态be*(被动的时间,还要考虑主语的单复数) + done(被动的动作)狗吃了那个蛋糕. The dog ate the cake.? 吃了那个蛋糕. - &gt; 蛋糕被吃了.狗(主语)吃了那个蛋糕(宾语). - &gt; 蛋糕被狗吃了.被动语态主要是用于及物动词(因为要接宾语)被动语态用不及物动词需要介词(因为要接宾语)教室每天都打扫(教室不能主动打扫,每天应为一般现在时). Classrooms are cleaned every day.一座新的大楼去年建造的. A new building was build last year. 与时态相结合他每天被打. He is beaten every day.他昨天被打了. he was beaten yesterday.他明天将被打. He will be beaten tomorrow.他现在正在被动. He is being beaten.他现在已经被动了. He has been beaten. English is spoken all over the world.The stadium was build in 1998.His bike will be repaired by his grandfather tomorrow.The new machine has been used in our factory for two weeks.Our morning paper is read by over 200,000 people every day. 罗马不是一天建成的. Rome was not built in a day.人们现在正在被广告营销. People are being influenced by advertisements.这封信必须马上寄出. The letter must be sent immediately.天气不能被人们所控制. The weather cannot be controlled by people.西红柿可以做菜或是生吃. Tomatoes may be cooked or eaten raw.我的钥匙肯定落在什么地方了. My keys must be left somewhere. … passing planes can be heard…doing 修饰名词,作定语a waiting car / a sleeping baby / boiling water / a developing countrya woman wearing a white coatused cars done 修饰名词,作定语wasted time / a desterted car park. / a ploughed field(运动场) / a car called Blue Bird The airport was built … but … it could not be used then. Over a hundred people must have been driven away … by the noise.must have v.过去分词 + be done = must have been done 推测 过去 的被动 #3. 知识扩展 被动语态与时态 / 情态动词相结合 / be(被动的时间) + done(被动的动作)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 20 One man in a boat 独坐孤舟]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-20-One-man-in-a-boat-%E7%8B%AC%E5%9D%90%E5%AD%A4%E8%88%9F%2F</url>
      <content type="text"><![CDATA[1. 单词讲解-catch v.抓到 (caught,caught) Cats catch mice. The thief was caught by the police. catch a train Kim has to work had to catch up with the other students. They were caught in a storm. fisherman n.钓鱼人,渔民 fishermen waste n.浪费 It’s a waste of time. It’s a waste of money. v.Don’t waste your time.You don’t have to waste your words on this matter. realize v.意识到 Jim has realized his own mistakes. Kate realized that Nick was lying all the time. Tom realized his dream finally. Tom实现了它的梦想 2. 语法讲解 Fishing is my favorite… fishing 动名词 : 由动词演变的名词 Skiing is fun. 滑雪 Reading is an art. John likes playing tennis. 动名词也能作为宾语 … fish for hours without catching anything. without sth (没有做某事) He solved the problem without difficulty. without doingDavid went away without taking leave. Instead of catching fish,they catch… instead adv.替代 There is no coffee,We will have tea instead. Nick is absent(缺席的) today, I will do the job instead. instead of 代替,而不是Paul will take the business trip instead of Eric.Let’s go to the movies instead of staying at home. … less lucky. less adv.更少 He is less smart. 他没有那么聪明 The story is less colorful. After having spent whole mornings on the river,I… after doing After visiting the museum, we will take a rest. after having done 已经做了某事之后After having met a friend at the cafe, I went to the coffee.After having taken the exam, he waited for the result anxiously. … give up fishing! give up 放弃 He give up the decision. 放弃这种决定 Nick decided to give up smoking and drinking. I’m not really interested in… be interested in 对…感兴趣Michael is interested in history.Roy is interested in taking photos. 3. 知识扩展 give awayLee can’t believe that his best friend gave him away.(背叛)Bob gave away all his money to the poor.(捐赠) give in 屈服In the end,Nick was forced to give in. give off 发出(光);散发(味道)This flower gives off a rich perfume.这花散发出浓郁的芳香. give up 放弃Paul decided to give up dringking. give back 归还Don’t forget to give me back my book.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 19 Sold out 票已售完]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-19-Sold-out-%E7%A5%A8%E5%B7%B2%E5%94%AE%E5%AE%8C%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 hurry v.匆忙 hurry to the ticket office Hurrp up! hurriedly adv.匆忙地 do sth. hurriedly pity n.令人遗憾的事 What a pity! return v.退回 return the books return home n. 返回,回来Sir,may I see your return ticket? sandly adv.悲哀地 sad adj. 2. 语法讲解 msut 也可以表示推测 “The play may begin at any moment,”… at abt moment : 随时 “It may have begun already,”… may 情态动词 表示推测 :The play may begin at any moment.It may have begun already. 请求,允许 :May I come in?You may come in and have something to drink.may -&gt; might “May I have two tickets please?” “I’m sorry, we’ve sold out”… we’ve = we have “What a pity!”Susan exclaimed(欢呼道) “Can I return these two tickets?” can 情态动词Trust yourself! You can do it. 相信自己,你能行的!(能力)Can I help you? / What can I do for you?(请求)He is abroad. It can’t be him.(推测)can -&gt; could “Can I return these two tickets?”“Could I have those two tickets please?” 用心情表示了说话的语气 “I might as well have them,” I said sadly.may as well = 表示比较勉强的语气 3. 知识扩展 The play may begin at any moment. It may have begun already. May I come in? You may come in and have something to drink. may as well can 情态动词Trust yourself! you can do it.Can I help you? / What can I do for you?You can help me to find my size.He is abroad. It can’t be him.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 18 He often does this! 他经常干这种事]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-18-He-often-does-this-%E4%BB%96%E7%BB%8F%E5%B8%B8%E5%B9%B2%E8%BF%99%E7%A7%8D%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 pub n.小酒馆 public house They went to the pub for a drink. landlord n.店主 The landlord asked Ted to pay the rent(租金). bill n.账单 telephone bill gas bill pay one’s bill Bill, please a ten-dollar bill 一张十美元纸币 2. 语法讲解 After I had had lunch at a village pub… had done 过去完成时 (have为助动词,无词义) have lunch (have为实义动词,有”吃,喝”) have coffee Dave has a brother …I looked for(寻找) my bag. Nick looked for his dog everywhere. He didn’t find it. I had left it on a chair beside the door… leave sth. + 介词短语He left his bag on the train. beside prep. == next toShe is sitting beside the woindow. besides prep. == in addition toBesides Ellen, five of us have watched the movie. As I was looking for it… as conj. 当…的时候 As I was writing a report(报告), George came up to me. I haven’t got my… have got == haveJack has got a dog / Jack has a dog.否定句 :Jack hasn’t got a dog. / Jack hasn’t a dog.疑问句 :Has Jack got a dog? / Has Jack a dog? … immediately went out. immediately == at once (立即) He often does… he == the dog 3. 知识扩展 have 助动词He has never been abroad before. 他以前从来没有出过国. 实义动词He has two sisters.(有)Jim had breakfast at 7 this morning.(吃)Would you like to have a cup of coffee?(喝)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 17 Always young 青春常驻]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-17-Always-young-%E9%9D%92%E6%98%A5%E5%B8%B8%E9%A9%BB%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 appear v.登场,扮演 disappear v.消失 appearance n.出现,外貌 stage n.舞台 on the stage stage fright 怯场 bright adj.鲜艳的 bright colour(color) bright future / prospect bright ideas The little boy is really bright(聪明). 2. 语法讲解 情态动词 must 表示推测 表示不可避免的义务 She must be … thirty-fine years old. 表示推测 情态(情绪,态度,情感)动词 must may might / can could / will would / shall should … 对比 : She is 35 years old. You must be the new teacher.He looks pale,He must be ill.She must have cried just now. 表示不可避免的义务 I must do it now.She must do it now.You must do it tomorrow.You will have to it tomorrow. In spite of this,she often appears…as a young girl. In spite of : 尽管 Jennifer will have to take part in a … play soon. will have to In the play, she must appear in a bright red dress… 3. 知识扩展 表示推测 “肯定,一定” She must be 35 years old. It must have rained last night. 表示不可避免的义务 “必须” You must do it now.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 16 A polite request 彬彬有礼的要求]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-16-A-polite-request-%E5%BD%AC%E5%BD%AC%E6%9C%89%E7%A4%BC%E7%9A%84%E8%A6%81%E6%B1%82%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 park v.停放(汽车) He parked his car outside the building. You can’t park in this street. parking n.停车 No parking. traffic n.交通 heavy / light traffic / traffic accident (交通事故) / traffic sign / traffic regulations / traffic jam / Bob was caught in a traffic jam. ticket n.交通违规罚款单 move ticket / air ticket / a one way ticket / a round-trip ticket / a parking ticket note n.便条 Vicky left a note to her roommate. The secretary took notes of everything the boss said. 秘书记录着老板所说的一切. area n.地段 a parking area smoking area mountain area sign n.指示牌 a road sign a traffic sign She showed no sign of anger. Green is a sign of spring. reminder n.提示 The waiter gave us a gentle reminder to pay the bill.(服务员提醒我们买账) fail v.无视,忘记,失败 He tired but failed. He failed in persuading his father. Paul failled in business. Sue didn’t fail to keep her word. obey v.服从 You should obey your parents. obey the law. obey traffic regulations(条例). 2. 语法讲解 If you park your car in the wrong place, a traffic policeman will soon… if引导的真实条件句 主将从现(一般现在时) If you don’t take the opportunity, you’ll be really sorry. If it is fine tomorrow,We will go hiking. If you park … , soon find it. you为泛指 If you visit Beijing, you will never miss the Great Wall. one 指代每个人,任何人 One who comes to China never fails to visit Beijing. … if he lets you go(放过) without a ticket. let sb.go 放手,释放 My little nephew grabbed my hand and would not let go. You’re late again. Your boss won’t let you go easily. without prep. 无…;没有… No man could live without food. 人需要靠食物活下去. However, this does not… however adv.可是,然而;不过 He has told me his plan.However, I will do it my own way. but conj.然而,但是 Jane is so sad,but she won’t cry. Traffic police are… 比较 : …a traffic policeman will soon find it. The police are on duty. policeman policemen During a holiday in Sweden… during prep. 在…期间 during October during my stay in New York … if you pay attention to(注意) our street signs. Please pay attention to the traffic regulations. … you cannot fail to(不得不) obey it. 双重否定表肯定(强调)This car is so amazing. You can’t faill to be impressed it. 3. 知识扩展 Please move your vehicle to the side of the road.请把你的车移到路边. This is not a parking zone.You may not park here.这里不能停车,您不能停在这. Please pull over the road.请你靠马路边停车. You just run a red light.您刚刚闯了红灯. Please buckle up your safe belt when driving.请在开车时系好安全带. May I see your driver’s license and vehicle(车辆) registration(登记)?请出示您的驾照和车照.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 15 Good news 好消息]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-15-Good-news-%E5%A5%BD%E6%B6%88%E6%81%AF%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 secretary n.秘书 secret n.秘密 nervous adj.精神紧张的 feel nervous be nervous nerve n.神经 afford v.负担得起 can / could be able to + afford + sth./to do sth. Students cannot afford the books. Nowadays people can afford to travel aborad. interrupt v.插话,打断 Don’t interrupt! inter + internet n. / interview v./n. / international adj.国际的 / interaction(活动) n. 2. 语法讲解 直接引语变间接引语 (宾语从句) I believe (that) you can make it. 他说 : “我是笨蛋.”(直接引语) == 他说他是笨蛋(间接引语). He says, “I am a fool.” He says (that) he is a fool. He said, “I will go to Italy.” He said that he would go to Italy. He said, “I went to Italy.” He said (that) he had gone to Italy. The secretary told me that Mr… would see me. 宾语从句 After I had sat down, he said that business was… bad. 我坐下,他说. (过去完成时) He told me that the film could not afford to pay… could not afford 负担不起… I knew that my turn had came. 我知道我已经进来了 宾语从句 Then he smiled and (he) told me (that) I would receive… 3. 知识扩展 直接引语变成间接宾语 I think (that) you are right. 我相信我能飞.I believe (that) I can fly. 我希望你尽快好起来.I hope that you will be / get better soon. 我的儿子意识到他应该更努力的学习.My soon realizes that he should study / work harder. 老板总告诉我们必须及时完成工作.The boss always tells us that we must finish the work in time.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 14 Do you speak English? 你会讲英语吗？]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-14-Do-you-speak-English-%E4%BD%A0%E4%BC%9A%E8%AE%B2%E8%8B%B1%E8%AF%AD%E5%90%97%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 amusing adj. 好笑的,有趣的 / funnyan amusing jokean amusing story experiece n. [C] 经历a pleasant experiencean unusual experienceThey had many interesting experiences while traveling in Paris. [U] 经验She doesn’t have much work experience.He is a man of great experience. 他是一个经验丰富的人. wave v.招手He waved goodbye to his friends.Bob waved at the taxi driver to stop. lift n.搭顺风车Alan gave me a lift to the subway station. reply 回答 vi.Kelly asked him a question,but ge didn’t reply.I will reply to this letter later. vt.He didn’t reply a word.He replied that he didn’t want to say anything. n.He made no reply.In reply to the question,he nodded. language n.语言native languagebody language journey n.旅行take a yourney around the world.A pleasant journey to you!Dave’s away on a journey.go on a journey to New York. 2. 语法讲解 After I had left a small village… had done 过去完成时(过去的过去,在过去之前发生的事情)After I had met an old friend at the cofe,I went to a bookstore.When I got to the office,the meeting had already begun.. … a small village in the south of France,I drove on… Beijing is in the north of China. (in表示在内部) The Pacific is on the east of China. (on表示接壤) Japan is to the east of China. (to表示不接壤) on adv.向前,继续She talked on and on about her family.We will go on with the text tomorrow. On the way… 在路上,在途中 on the way to the airport on the way to the office on he way home 回家的路上 … he asked me for a lift. ask sb.for a lift. give sb.a lift. (坐上顺风车) He got a lift after he went on his journey. As soon as he had got into the car… as soon as -…就… As soon as I get there,I will meet you. As soon as Paul got to the office, he told Fred the result. get into the car … I said good morning to him in French… say good afternoon to sb in prep. 表示用某种语言作为交际手段 write in Chinese reply the question in English 表示讲某种语言时可以不加介词 speak Spanish He can speak French. Apart from a few words… apart from 除了 Apart from the poems,he ahs written a novel. They all watched the movie, apart from lan. Neither of us spoke… Neither answer is correct(答案). Neither of the answers is correct. (复数用of,表示两个答案都不对) Neither you nor Jack is the right person for the job. …I had nearly reached the town… reach == get to;arrive at/in As I soon learnt… As everyone knows,Jim is a nice person. learn learned / learntI learnt that he had left the company. 3. 知识扩展 交际英语 Nice to meet you. May I know your name? A lovely day,isn’t it? Is it your first visit to China? Are you visiting for business or pleasure? I’m sorry, I didn’t quite catch what you said. See you later. Take care. 当心]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 13 The Greenwood Boys 绿林少年]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-13-The-Greenwood-Boys-%E7%BB%BF%E6%9E%97%E5%B0%91%E5%B9%B4%2F</url>
      <content type="text"><![CDATA[1.单词讲解 group n.小组,团队 pop singer 流行歌手 pop music / pop songs club n.俱乐部 a football club a club member a night club performance n.演出 give a performance working performance perform v.表现 occasion n.场合 on these occasions once… and on another occasion… occasionally adv.偶尔 2. 语法讲解 At present, they are visiting… present n.现在 / 礼物 Yesterday is history. Tomorrow is a mystery. Today is a gift - That’s why it is called “the present”. all parts of the country = all over the country They will be arriving here tomorrow. will be doing 将来进行时 形式 : will/shall+be doing 用法 : They will be waiting here at 10:00 tomorrow. 含义 : 将来确定能发生 练习 :You will be enjoying yourself.They will be discussing(谈论) it again.I will be taking care of the children while you are busy. 否定 / 疑问 :They will not be waiting here.Will be waiting here? 补充 : 一般将来时(只是表示将来) / 将来进行时(强调正在进行) …will be arriving… …will be staying… …will be singing… …will be coming… and … will be meeting… the Workers’ Club 名词所有格Lily’s book (相互所拥有的)a teacher’s books.teachers’ books 如果有s结尾就直接加‘. As usual, the police will have a difficult time. as usual (像往常一样)She is late as usual. They will be trying to keep order. try to do sth. 努力做某事 try doing sth. 尝试做某事 order n.顺序 get sth.in order May I take your order,please? 3.知识扩展 将来进行时 形式 : will/shall + be doing 用法 : They will be waiting here at 10:00 tomorrow. on time : 按时]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 12 Goodbye and good luck 再见,一路顺风]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-12-Goodbye-and-good-luck-%E5%86%8D%E8%A7%81-%E4%B8%80%E8%B7%AF%E9%A1%BA%E9%A3%8E%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 luck n.运气,幸运 Good luck bad luck Better luck next time! 下一次更好运气 I hope this present will bring you luck. I had the luck to meet my idol. 我今天有幸遇到我的偶像. lucky adj.幸运的 lucky number It’s my lucky day. unlucky adj.不幸的 captain n.船长 Captain Ben Fawcett 机长 sail v.航行 go sailing sail around the world sail across the English Channel(海峡). The ship will sail from Hong Kong for New York tomorrow. harbour n.港口 harbor neighbour / neighbor pround adj.自豪 be pround of His family are pround of his success. be pround to do I’m pround to join the team(团队). pride n.自豪,骄傲,傲慢 His family take pride in his success. imporant adj.重要的 an imporant decision It’s imporant for you to make the decision. 做这个决定是非常重要的. 2. 语法讲解 Our neighbour, Captain Charles Alison,… … will sail from … tomorrow. 一般将来时 will + 动词原形 be going to + 动词原形 be about to + 动词原形 …meet him at the harbour early in the morning.(离早上早一些) …will be meeting them at the station. 在火车站去迎他们. late in the afternoon. 下午晚些时间 …in his small boat,Topsail. … a famous little boat. a little kid a little garden. …sailed across… across prep.横渡,横过 go across the street swim across the river across from 在…的对面 The store is across from the restaurant. through prep.通过,穿过 go through a door …set out at eight o’clock. set out 出发 They set out in the morning. He will set out on his journey(旅行) to New York. He set off down the main street… … have plenty of time. plenty of 充足的… plenty of food 充足的食物 plenty of good ideas 可数名词记得要复数(注意不单一个) we’ll say goodbye to him. say goodbye to sb. say hello/hi to sb. say good moring to sb. He will be away… away adv.离开,离去 He is away in the country. He is away on a trip. away from 相距 The store is two hundred meters away from here. We are very pround of… be pround of sb. 为某人感到自豪 be prund of sth. He will take part in… take part in 参与 take part in a metting take part in a research(研究) 3.知识扩展 be gonna / e going to Mom’s going to make some apple pies. Mom’s gonna make some apple pies. Ryan is going to be here soon. Ryan is gonna be here soon.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 11 One good turn deserves another 礼尚往来]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-11-One-good-turn-deserves-another-%E7%A4%BC%E5%B0%9A%E5%BE%80%E6%9D%A5%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 turn n.行为,举止One good turn deserves another. n.轮流的机会It’s my turn. / My turn had come. v.旋转turn left / right / round v.变得Her face turned red. deserve v.应得的,值得He worked really hard,and he deserved the promotion.You deserve it! salary n.工资wages immediately adv.立刻at once 2. 语法讲解 一般现在时 / 现在进行时现在进行时重在过程 一般过去时 现在完成时 过去进行时 I was having dinner at a restaurant when Tony… come in. He has never borrowed money from me. 一直都这样.对比 : He never borrowed money from me. 他过去从来没有还钱. While he was eating, I asked him … “I have never borrowed any money from you,”…现在完成时 3. 知识扩展 turn onon : 打上线了,所以是打开 turn offoff : 表示关闭 turn up (出现) turn down (拒绝,减少)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 10 Not for jazz 不适于演奏爵士乐]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-10-Not-for-jazz-%E4%B8%8D%E9%80%82%E4%BA%8E%E6%BC%94%E5%A5%8F%E7%88%B5%E5%A3%AB%E4%B9%90%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 jazz n.爵士音乐 pop music / classical music / country music / rock and roll musical adj.音乐的 musical film 音乐片 She has a musical voice. music + al / nature – natural instrument n.乐器的 musical instrument clavichord n.古钢琴 recently adv.最近的 recent adj.最近的,近来的 in recent years recent news They have recently discovered an island. Lee came to see me recently. damage v.损害 The car was damaged in the accident. Smoking can damage your health. n. 损害,损失 Smoking can do damage to your health. key n.琴键 the key to the front door 前门的钥匙 a key to the exercise 练习答案 shock v.使不悦或生气,震惊 Jane was shocked at the news. His words shocked us. n. 震惊 His words gave us a shock. allow v.允许,让 allow doing We allow smoking only in smoking area. allow sb to do His parents won’t allow him to smoke. touch v.触摸 Don’t touch the painting. I touched him on the shoulder. The story touched me deeply. (感动) 2. 语法讲解 We have an… 表示状态的动词通常不用在被动语态中 have / fit / cost / lack / possess / belong to … The shirt cost me $99. It is called… We call it a clavichord. It was made in… make / made / made Made in China. … is kept in… keep / kept / kept We keep our clavichord in the living room. It has belonged to… belong vi.属于… 不及物动词不用于被动语态 The bike belongs to Sam. He belongs to a golf club. … was bought by… buy / bought / bought My grandfather bought the instrument many years ago. …it was damaged by… Recently a visitor damaged it. She tried to play… 动词的宾语是不定式或动名词,通过不能变为被动语态 I hope to see you soon. She likes singing. … play jazz on it. play the piano She struck … were broken. strike / struck / struck break / broke / broken … was shocked. It shocked my father. … we are not allowed to… allow sb.to do sth. sb. is allowed to do sth. Now my father doesn’t allow us to touch it. It is being repaired. be being done A friend of my father’s is repairing it. a friend of my father’s 双重所有格 Mike is a friend of mine. 3. 知识扩展 这件衬衫容易洗干净.This shirt cleans easily. 水果在冰箱里能保鲜.Fruit can keep fresh in the fridge. 这种布不耐洗.This cloth won’t wash well. 表示主语的某种属性特征的动词,以主动形式表示被动的意义.这类动词一般不单独使用,常有一个修饰词. 如:sell / clean / wash / write / iron / cut / draw / open / cook / shut / dry …]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 09 A cold welcome 冷遇]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-09-A-cold-welcome-%E5%86%B7%E9%81%87%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 welcome n.欢迎 a cold welcome / a warm welcome v.欢迎 welcome you / the New Year / Welcome to Beijing. adj.受欢迎的 You are welcome. crowd n.人群 a large crowd of people crowded adj.拥挤的 hand n. (表或机器的)指针 v.传递hand sth.to sb. refuse refuse sb./sth. refuse to do sth. 2. 语法讲解 On Wednesday evening ,we went to the Town Hall. On Wednesday evening in the evening It was the last day… 一般过去时 and a large crowd of people had gathered 过去完成时 站在过去往之前看 a large crowd of people It would strike twelve in twenty minutes’ time. 过去将来时 twenty minutes’time / 名词所有格 a teacher’s books / teachers’ books 如果以s结尾直接加 ‘ We waited and waited … nothing happened. sth. happen to sb. I looked at my watch. / 介宾结构 looked vi. 不及物动词不能直接接宾语 / 我们可以通过介词(prep.). 犹如婚姻中介,因为不及物动词不能加宾语,我们需要介词连接. It was true. true adj.真实的 / truth n.事实,真相 / false adj.不真实的,错误的. At that moment, everybod began to laugh… begin / began / begun begin to do sth. = begin doing sth. 表示时间的介词 (prep.) before / after from … to … since / until during at 8 o’clock / night / midnight / noon on Monday in 1992 / January / summer in the morning / afternoon / evening. 3. 知识扩展 at 8 o’clock / night / midnight / noon == 通常接上时间点 on Monday == 通常表示一天上 in 1992 == 大的范围内用in]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 08 The best and the worst 最好的和最差的]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-08-The-best-and-the-worst-%E6%9C%80%E5%A5%BD%E7%9A%84%E5%92%8C%E6%9C%80%E5%B7%AE%E7%9A%84%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 competition n.比赛,竞争 complete v.比赛,竞争 The kids completed with / against each other for the prize. neat adj.整齐的,整洁的 a neat garden neat handwriting keep the room neat path n.小路,小径 I took the path across the garden. wooden adj.木头的 a wooden house gold - golden wool - woolen pool n.水池 swimming pool 2. 语法讲解 Joe Sanders has the most beautiful garden in… Kim is the tallest student in the class. / 需要给定范围 It’s the most exciting move I have watched. Nearly everybody enters for … nearly – almost Edward nearly / almost missed the flight. … is larger than Joe’s. n.+-‘s 表示所属关系,构成名词所有格 Mary’s parents the twin brother’s parents / the babies’ parents Mary and Tom’s parents 玛丽和汤姆的父母(两人共有的) They are Mary’s and Tom’s parents. He has made neat paths and has built… make / made / made / build / built / built The shirts is made in China. … a wooden bridge over a pool. over prep.从某物的一边到另一边;横越 a bridge over the river run over the field 跑过田野 … I always win a little prize… prize n.奖品,奖金 3. 知识扩展 比较级和最高级My trip to Paris is more than sightseeing. / 我去巴黎不仅仅是为了旅行观光.David is more hardworking than smart. / 与其说大卫聪明,不如说他勤奋.The more he thought about it, the more excited he became. / 他越想越兴奋.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 07 Too late 为时太晚]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-07-Too-late-%E4%B8%BA%E6%97%B6%E5%A4%AA%E6%99%9A%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 detective n.侦探 detect v.探测 valuable adj.贵重的 value n.价值 precious adj.珍贵的 main adj.主要的 the main building the main streets / the side streets / the main idea (中心思想) guard n.警戒,守卫 keep guard 保持守卫 2. 语法讲解 The plane was late and detectives were waiting … all morning. 一般过去时 They were expecting a valuable parcel … from South Africa. 过去进行时 形式 : was/were doing 用法 :She was reading a book at 11:00 last night. 否定疑问 :She was not reading a book…Was she reading a book…? 补充 :While you were sleeping,a thief sneaked in. (过去进行时与一般过去时结合) A few hours earlier, someone had told the police that thieves would try to steal the diamonds. try to do sth. 努力做某事 try doing sth. 尝试,试图做某事 过去完成时 形式 : had done 用法 : 从过去的角度回头看过去的问题Before 8:00 yesterday, she had finished her homework. (过去 : yesterday / 之前 : before)When he got there, she had leaved she was not there. 否定疑问句 补充 :It is 10:00. I have waiting for 2 hours.It was 10:00. I had waiting for 2 hours. A few hours earlier, someone had told police that thieves would try to steal the diamonds. 过去将来时 形式 : would do / was/were going to do 用法 : 过去的将来 (过去的之后发生的事情 小时候,你长大希望干什么?)He said that he would go abroad next year. A few hours earlier, someone had told the police that thieves would try to steal the diamonds. tell sb.sth 双宾语结构 … that thieves would try to steal the diamonds ( 宾语从句) 写法 : 陈述句变宾语从句?I think you are right.I think that you are right. When the plane arrived, some of the detectives were waiting inside … while others were waiting on the airfield. Two men took the parcel off the plane … carried it into the Customs House. take off : 拿-&gt;脱离 3. 知识扩展四种表示过去的时态]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 06 Percy Buttons 珀西.巴顿斯]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-06-Percy-Buttons-%E7%8F%80%E8%A5%BF-%E5%B7%B4%E9%A1%BF%E6%96%AF%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 beggar n.乞丐 beg v. 乞求;行乞 food n.食物 fast food 快餐 frozen food 速冻食品 junk food 垃圾食品 pocket n.衣服口袋 jacket pocket pocket dictionary pocket money Money burns a hole in his pocket. 人花钱如流水 call v.拜访 光顾 I called at Mr. Green’s house yesterday. Ted will can on his professor tomorrow. I will call you back later. Someone called you up just now. 2. 语法讲解 I have just moved to… 移动的对象 Who moved my cheese? He moved in last week. move out … a beggar knocked at my door. The bat knocked him on the head. He asked me for a meal… ask for : 请求;向…要 He asked Percy for help when he was in trouble. In return for this… in return(for) 回报;作为报答 I hope I can do something for you in return. In return for his help,I treated him to an ice-cream. …the beggar stood on his head… stand / stood / stood He can stand on his hands. stand on one’s own feet 独立;不依赖别人 … ate the food…drank the beer. eat / ate / eaten drink / drank / drunk … put a piece of cheese in his pocket… put / put / put He put the wallet in his bag. Then he put the bag in the drawer. … a neighbor told me about him. tell / told / told tell sb about sth Tina told me about her name. I read about his adventures. (奇遇). Everyone(每一个人,强调单数意义) knows… Everybody is here. Nobody knows him. Everything is ready. He calls at(拜访) every house… I called at my neighbor’s house yesterday. call on 拜访(某人) We’ll call on our professor(教授) next Monday. 3. 知识扩展 冠词 在有些表示家居生活,社会事业机构的名词前,有或没有冠词的意义是不一样的. in hospital 住院 in the hospital 在医院 at table 吃饭,进餐 at the table 在桌边,在餐桌旁边 in bed 在睡觉 in the bed 卧在床上 in school 在校念书 in the school 在学校里]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 05 No wrong numbers 无错号之虞]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-05-No-wrong-numbers-%E6%97%A0%E9%94%99%E5%8F%B7%E4%B9%8B%E8%99%9E%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 pigeon n.鸽子 dove message n.信息 send a message receive / get a message leave a message 留一封信 an urgent message 紧急消息 short message service = SMS information n.抽象信息 看不见摸不着 (不可数) destance n.距离 distant adj.遥远的 difference n.不同的,差异的 different adj.不同的 importance n.重要的 important adj.重要的 confidence n.信心 confident adj.有信心的 convenience n.方便 convenient adj.方便的 request n.请求,要求 Their request is absurd. We will refuse the request. spare part 备件 spare time service n,业务,服务 2. 课文语法 现在完成时 形式 : have/has + done 用法 : 完成? 全部完成 | 部分完成 现在全部完成 现在部分完成 用法 : 现在的之前 (站在现在回头看之前) He has left. (现在的全部完成) We have learned English for ten years. (现在的部分完成) 变否定疑问 : He has left. He has not left. Has he let? 补充 : 现在完成时与一般过去时的区别 He has left. 现在全部完成 可以换成 一般过去时 He has left,so I cannot find him now. He left two hours ago. We have learned English for ten years. 现在部分完成 不能换成 一般过去时 Mr.James Scott has a garage… and now he has just bought another garage… 现在完成时 (现在的之前) have/has + just / already / ever(曾经) / never + done … so he has just bought twelve pigeons. Yesterday, a pigeon carried the first message form…to… 一般过去时 Up to now,Mr.Scott has sent a great many requests… up to now = up till now one … the other some … others In this way, he has begun his own private “telephone” service. begin / began / begun one’s own + n my own room (单独拥有的) 比较 : my room 3. 知识扩展 现在完成时 形式 : have/has + done 用法 : 现在的之前 He has left. 现在全部完成 We have learned English for ten years. 现在部分完成 I have lived here for … years. They have known each other for … years. I have watched the movie … times.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 04 An exciting trip 激动人心的旅行]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-04-An-exciting-trip-%E6%BF%80%E5%8A%A8%E4%BA%BA%E5%BF%83%E7%9A%84%E6%97%85%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 exciting adj.令人兴奋的 (主动意义) an exciting game It’s the most exciting movie I have ever watched. excited adj. 兴奋的 (被动意义) the excited children 兴奋的孩子们 (孩子们不会无缘无故的兴奋) They are all excited by the news. (消息使它们感到兴奋) receive v.接受,收到 (客观) receive a present (礼物) receive a good education (教育) Sally has received John’s present, but she won’t accept(主观) it. firm n.商行,公司 a law firm a trading firm adj. 坚固的,牢固的 firm soil a firm handsnake (握手) different adj.不同的 They have different ideas. The twin brothers are so different from each other. center n.中心 trade center (贸易中心) shopping center The table is in the center of the room. abroad adv.在国外 go abroad (出国) travel abroad study abroad live abroad 2. 语法讲解 I have just received a letter from… 现在完成时,由于 just 配合现在完成时候的时态,对现在有影响. receive a letter from a friend receive an email from my professor (教授) … from my brother,Tim. Tim,同位语 My boss, Mr.Williams, will meet me in the afternoon. I’d like you to meet my friend ,James. in Australia 在国名前要加in in China …for six months. for + 时间段 He has been in London for ten years. (现在完成时) since + 时间点 I haven’t met him since Monday. for + 时间段 | since + 时间点 一般都是现在完成时 He is working for a big firm… work for an IT company work in a lawyer’s office work at a bank …he has already visited (already 现在完成时的标志) I’ve already seen that firm. (肯定句) Jane hasn’t read that novel yet. (否定句) …a great number of different places… a number of + 可数名词复数 a large number of a great number of a small number of There are a large number of visitors in the meseum. …and has gone to Alice Springs. have gone to 已经去了某地 have been to 曾经去过某处 have been in/at 已在某地待了多久 Where is Shryy? She has gone to New york. Dan has been to Africa twice. Mr.Green has been in Beijing for two years. …Alice Spring, a small town in the center of Australia. a small town in the center of Australia 同位语 …he will fly to Perth. fly to 乘坐飞机去某处 My brother has never been abroad before… (现在完成时) Sue has never heard of such a thing. Sue hasn’t heard of such a thing before. …so he is finding this trip very exciting. very exciting 宾语补主语 I find Tim’s office very tidy. This trip is very exciting. 3. 知识扩展 仿写 我刚刚收到了朋友巴里的电子邮件.I have just received an email from my friend,Barry. 他正在意大利.He is in Italy. 他在那儿已经住了一年了.He has been there for a year. 他刚买了一辆意大利的小汽车,现在去了意大利北部的水上城市威尼斯.He has just boght an Italian car and has gone to Venice a city on water in the north of Italy. 他不久还将到罗马.He will soon visit Rome. 我朋友以前从未出过国,因此,他觉得这次旅行非常有意思.My firend has never been abroad before, so he is finding this trip very interesting.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 03 Please send me a card 请给我寄一张明信片]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-03-Please-send-me-a-card-%E8%AF%B7%E7%BB%99%E6%88%91%E5%AF%84%E4%B8%80%E5%BC%A0%E6%98%8E%E4%BF%A1%E7%89%87%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 send v. (sent,sent)寄,送 send a letter send a message sned a card send me a card = send a card to me send sb.sth = send sth. to sb. send for a doctor / a taxi postcard n.明信片 post + card | post office | post code | post man | post box / mail box 邮筒,信箱 a Christmas card a credit card play card spoil v.(spoiled or spoilt)使索然无味,损坏 dream dreamed / dreamt learn learned / learnt 宠坏,溺爱 Don’t spoil your children. 食物腐烂 Put the food in the fridge,or it will spoil soon. damage(精神上的损坏) | destory(可以修复的坏) | ruin (慢慢的损坏) museum n.博物馆 a historical museum a science museum the Palace Museum (宫殿的博物馆) public adj. 公共的 public gardens / schools / opinions We are not used to talking in English in public. n. 公众,大众 The museum is open to the public on Sundays. private adj. 私人的 friendly adj. 友好的 He is friendly to all of us. brotherly (兄弟的) | lovely (可爱的) | lonely (孤独的) | timely (适时的) waiter n. 服务员,招待员 waitress n. 女服务员 lend v. (lent,lent) 借给 lend sb. sth. = lend sth. to sb. lend me a book = lend a book to me Can you lend me 200 Yuan? lend 借出 / borrow 借入 decision n. 决定 It was my final decision. make a decision (名词不能直接用,只能搭配动词) She couldn’t make a decision about the dress. decide v.决定 decide to do I decide to go abroad for further education. whole adj. 整个的 a whole day / week A Whole New World whole milk single adj. 唯一的,单一的 a single bed / ticket (单一的车票) 2. 课文语法 一般过去时 | 形式 : v.过去式 (did) 用法 : Last summer I went to Italy. They had a meeting yesterday. Tom was a student when he was ten years old. 注意 : She had a boyfriend. (与过去有关和现在无关) 以前的男朋友与现在没有关系 Tom was a student. (过去是学生) 一般过去式 v.过去式 (did) 否定 / 疑问 : You were happy. You were not happy. They did not have a meeting. 补充 : (过去式一般要用在过去时当中,过去分词可以用在完成时被动语态当中) V.原形 V.过去式 V.过去分词 look looked looked teach taught taught go went gone write wrote written Then he lent me a book. 同时能接人和物,就能使用主谓双宾结构. The he lent a book to me. 为了谁用 for / 表示动作的方向用 to I read a few lines,but I did not understand… read / read / read understand / understood / understood Every day I thought about… every day = everyday I got up early and bought… get / got / got/gotten buy / bought / bought I spent the whole day in my room… spend time / money + on sth./ in doing sth. 3. 知识扩展 single adj. 唯一的,单一的 / 单身的 Are you married or single? I am single. I am available.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 02 Breakfast or lunch 早餐还是午餐?]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-02-Breakfast-or-lunch-%E6%97%A9%E9%A4%90%E8%BF%98%E6%98%AF%E5%8D%88%E9%A4%90%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 until prep. 直到…为止 介词后面接名词 until lunchtime I go to school until Friday. not…until 直到…才 I’m not free until Friday. I didn’t get up until 10 o’clock this morning. outside adj. 在外面的 outside world prep. 在…的外面 outside the downtown area n. 外面;外部 He seems gentle on the outside. adv. 在外面 Please wait outside. ring v. (铃/电话等)响;打电话 The phone is ringing. I will ring you (up) later. n. 打电话;戒指 Give me a ring later. a wedding ring. repeat v. 重复 Pardon? Would you please repeat it? Would you please explain that world? 2. 课文语法 It was… 表示时间:It’s 10 o’clock in the morning. 表示天气:It’s snowing now. 表示距离:It’s 2 kilometers to the store. 确定人的身份:It’s Tim on the phone. I never get up early… always | usually/often/frequently | sometimes | seldom | rarely | never | 频率词往往可能与一般现在时搭配在一起 Helen rarely goes to the movies. … on Sundays. on 表示在某一天 on Monday on Sept.10 on that day (在那一天) Sundays 复数表示经常性的行为 I don’t go to work on Fridays. 我经常在星期五都是不上班的. I sometimes stay… (一般现在时的结构) …stay in bed… 表示卧床/睡觉时bed前不加冠词 go to bed He was sick in bed. …until lunchtime. until在肯定句中和表示持续性状态的动词连用 表示动作持续到某时 Wait until two o’clock in the afternoon. until在否定句和表示短暂动作的动词连用 表示”直到…才” He didn’t come home until midnight. (midnight 午夜) Last Sunday… 比较:on Sunday next Saturday 下个星期六 I looked out of… look out of 朝…外看 look out of the door look out 小心;注意 Look out when you go across the street. It was dark… It gets dark early in winter. “What a day!” It is a terrible day. What + a/an + adj. + n.(名词单数) + 主语 + 谓语 + ! What a terrible day it is! He is a hardworking young man. What a hardworking young man he is! They are hardworking young men. What + adj. + n.(可数名词复数) + 主语 + 谓语 + ! What + hardworking + young men they are! How + adj./adv + 主语 + 谓语 + ! The movie is amazing. How amazing movie is! …the telephone rang. ring rang rung The telephone is ringing. It was my… it 中性代词,指一物/一事/或一个人 It’s me. It’s the postman. “I’ve just arrived by train,…’” by bus | by bike | by air | by car | on foot| will’s car broke down and he had to return home on foot. I’m coming to see… (现在进行时) 瞬间动词用于现在进行时表示计划,安排将来要发生的动作或状态. come,go,arrive,leave… He’s leaving tomorrow. …I’m still having breakfast… 零冠词 have breakfast | have lunch | have dinner Dear me! My goodness! | Oh,my god! 3. 知识扩展 感叹句 Gosh! | Thank goodness! | How time flies! | How sweet of you! | What a nice present! - What a meal!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lesson 01 A private conversation 私人谈话]]></title>
      <url>%2F2017%2F03%2F27%2FLesson-01-A-private-conversation-%E7%A7%81%E4%BA%BA%E8%B0%88%E8%AF%9D%2F</url>
      <content type="text"><![CDATA[1. 单词讲解 private adj. 私人的 a private conversation a private school / cardo sth.in private public adj. 公共的,公开的 privacy n. 隐私 conversation n. 谈话 have a conversation hold a conversation theatre n. 剧院,戏院 go to the theatre seat n. 座位 have / take a seat have your seat angry adj. 生气的 angrily adv. 生气地 The angry boy shouted angrily. attention n. 注意 pay attention to sb./sth May I have your attention,please? Attention,please. 2. 课文语法 简单句的构成 n. + v.主语 + 谓语1 + 1 简单句的分类 Birds fly. 主谓 vi(不及物动词). I love you. 主谓宾 vt(及物动词). You ask me a question. 主谓双宾 vt. I find Hong kong beautiful. 主谓宾补 vt. I am very happy. 主系表 - 无实义 vi./vt.? 由自己能单独完成,就为不及物动词完成,如果需由他人与你一起完成,就为及物动词. 系动词 be动词 (单独出现) get become turn go grow “变得” look sound smell taste feel “看起来/听起来/闻起来/品尝起来/感觉起来…” 简单句的变化 Birds fly. / Birds will fly. / Birds will not fly. / Little birds fly happily. / In autumn birds fly in the sky. 简单句 Last week I went to the theatre. 主谓 I had a … good seat. 主谓宾 The pay was … interesting. 主系表 I did not enjoy it. 主谓 A … man and a … woman were sitting behind me. 主谓 They were talking loudly. I got … angry. 主系表 I turned round. 主谓 In the end, I could not bear it. in the end at last finally eventually “It’s none of your business,”the young man said rudely. none of … 都不 neither of … 简单陈述句的语序The policeman arrested the thief.The thief arrested the policeman. 3. 知识扩展 简单句的分类 简单句的变化 Girls play games. 主谓宾 Girls are playing games. Lovely Girls are playing games happily. Thousands of lovely girls are playing games very happily. After class thousands of lovely girls are playing games very happily on the playground. 判断简单句的类型? Last night I was driving from Harrisburg to Lewisburg… 主谓 I was alone on the road by now… 主谓宾 Some owners will leave their animals outside… 主谓宾补]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[01.Html]]></title>
      <url>%2F2017%2F03%2F27%2F01-Html%2F</url>
      <content type="text"><![CDATA[什么是HTML?Hyper Text Markup Language : 超文本标记语言超文本 : 功能比普通文本更加强大标记语言 : 使用一组标签对内容进行描述的一门语言(它不是编程语言) 语法和规范?HTML文件都是以.html或者.htm结尾的,建议使用.html结尾.HTML文件分为头部分(&lt;head&gt;&lt;/head&gt;)和体部分(&lt;body&gt;&lt;/body&gt;)HTML标签都是由开始标签和结束标签组成.(&lt;hr /&gt;)HTML标签不区分大小写,建议使用小写. HTML相关标签学习标题标签&lt;hn /&gt;水平线标签&lt;hr /&gt;段落标签&lt;p&gt;&lt;/p&gt; 字体标签&lt;font&gt;&lt;/font&gt; 属性 :size : 指定内容的大小color : 指定内容的颜色face : 指定内容的字体加粗 : &lt;b&gt;&lt;/b&gt;斜体 : &lt;i&gt;&lt;/i&gt;下划线 : &lt;u&gt;&lt;/u&gt; 网站图片显示页面 图片标签 : &lt;img /&gt;属性 : src : 指的是图片显示的路径(位置) 绝对路径：E:\Users\ThinkPad\Desktop\image 相对路径：同一级：直接写文件名称或者./文件名称上一级：../文件名称下一级：写上目录名称/文件名称 width : 指定图片的宽度,取值可以是像素值,也可以是百分比 height：指定图片的高度,取值可以是像素值,也可以是百分比 alt : 当图片无法正常显示的时候给出的提示信息(该属性的显示效果与浏览器以及浏览器版本有关) 网站友情链接显示页面列表标签 有序列表 : 123&lt;ol type="I" start="" reversed="reversed"&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 无序列表 123&lt;ul type=""&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 超链接标签 123&lt;a href="" target=""&gt;&lt;/a&gt;href : 指定跳转的位置target : 指定跳转页面显示的位置(取值 : _self 、_blank) 网站首页显示页面 表格标签 12345678910111213&lt;table border="" width="" height="" align="" bgcolor="" cellpadding="" cellspacing=""&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 跨行跨列操作跨行 : rowspan跨列 : colspan 网站后台系统页面 框架集标签 :1234&lt;frameset rows="" cols=""&gt; &lt;frame src=""/&gt; &lt;frame name=""/&gt;&lt;/frameset&gt;]]></content>
    </entry>

    
  
  
</search>
